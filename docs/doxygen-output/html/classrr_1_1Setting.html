<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>roadrunner: rr::Setting Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">roadrunner
   &#160;<span id="projectnumber">2.0.8</span>
   </div>
   <div id="projectbrief">Fast simulator for SBML models</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>rr</b></li><li class="navelem"><a class="el" href="classrr_1_1Setting.html">Setting</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classrr_1_1Setting-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rr::Setting Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Store a roadrunner option (or setting) as a <a class="el" href="classrr_1_1Variant.html" title="A basic type to hold a variety of data types.">Variant</a> type.  
 <a href="classrr_1_1Setting.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Setting_8h_source.html">Setting.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af49342a0fabdeeafe649246089a72b40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#af49342a0fabdeeafe649246089a72b40">TypeId</a> { <br />
&#160;&#160;<b>EMPTY</b> = 0, 
<b>STRING</b> = 1, 
<b>BOOL</b> = 2, 
<b>INT32</b> = 3, 
<br />
&#160;&#160;<b>UINT32</b> = 4, 
<b>INT64</b> = 5, 
<b>UINT64</b> = 6, 
<b>FLOAT</b> = 7, 
<br />
&#160;&#160;<b>DOUBLE</b> = 8, 
<b>CHAR</b> = 9, 
<b>UCHAR</b> = 10, 
<b>DOUBLEVECTOR</b> = 11
<br />
 }</td></tr>
<tr class="memdesc:af49342a0fabdeeafe649246089a72b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">types that correspond to the index of the position of the type in the variant template.  <a href="classrr_1_1Setting.html#af49342a0fabdeeafe649246089a72b40">More...</a><br /></td></tr>
<tr class="separator:af49342a0fabdeeafe649246089a72b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ca419f9b706d09cef6d90991e194fee"><td class="memItemLeft" align="right" valign="top"><a id="a4ca419f9b706d09cef6d90991e194fee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a4ca419f9b706d09cef6d90991e194fee">Setting</a> (setting_t value)</td></tr>
<tr class="memdesc:a4ca419f9b706d09cef6d90991e194fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor to take any type accepted by setting_t and store as a variant. <br /></td></tr>
<tr class="separator:a4ca419f9b706d09cef6d90991e194fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace675cf68c9885e451535578e3c2eff9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ace675cf68c9885e451535578e3c2eff9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ace675cf68c9885e451535578e3c2eff9">Setting</a> (T settingValue)</td></tr>
<tr class="memdesc:ace675cf68c9885e451535578e3c2eff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for creating a <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> from a supperted type T.  <a href="classrr_1_1Setting.html#ace675cf68c9885e451535578e3c2eff9">More...</a><br /></td></tr>
<tr class="separator:ace675cf68c9885e451535578e3c2eff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe62fdd022c03a9542db4cca43aa6a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a9fe62fdd022c03a9542db4cca43aa6a5">Setting</a> (const char *settingValue)</td></tr>
<tr class="memdesc:a9fe62fdd022c03a9542db4cca43aa6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for enabling creation of a <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> from a string literal.  <a href="classrr_1_1Setting.html#a9fe62fdd022c03a9542db4cca43aa6a5">More...</a><br /></td></tr>
<tr class="separator:a9fe62fdd022c03a9542db4cca43aa6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f608e0145800200b7795eea56a93cd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a2f608e0145800200b7795eea56a93cd5">Setting</a> (std::int64_t settingValue)</td></tr>
<tr class="memdesc:a2f608e0145800200b7795eea56a93cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct from a long.  <a href="classrr_1_1Setting.html#a2f608e0145800200b7795eea56a93cd5">More...</a><br /></td></tr>
<tr class="separator:a2f608e0145800200b7795eea56a93cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3f6beff36ad237ca6493dfaa19741f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> ()=default</td></tr>
<tr class="memdesc:a2f3f6beff36ad237ca6493dfaa19741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor.  <a href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">More...</a><br /></td></tr>
<tr class="separator:a2f3f6beff36ad237ca6493dfaa19741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479708abc63de00aca3d56b7e28bee04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1Setting.html#af49342a0fabdeeafe649246089a72b40">TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">type</a> () const</td></tr>
<tr class="memdesc:a479708abc63de00aca3d56b7e28bee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the type of std::variant contained within this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>.  <a href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">More...</a><br /></td></tr>
<tr class="separator:a479708abc63de00aca3d56b7e28bee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b42145e5c0dab9a86a5faa790f1d7f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab0b42145e5c0dab9a86a5faa790f1d7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ab0b42145e5c0dab9a86a5faa790f1d7f">isType</a> ()</td></tr>
<tr class="memdesc:ab0b42145e5c0dab9a86a5faa790f1d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines whether the current value of <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> is of type T.  <a href="classrr_1_1Setting.html#ab0b42145e5c0dab9a86a5faa790f1d7f">More...</a><br /></td></tr>
<tr class="separator:ab0b42145e5c0dab9a86a5faa790f1d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ebea12f30b1b3e84bf2ebd35c18d06"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a44ebea12f30b1b3e84bf2ebd35c18d06"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a44ebea12f30b1b3e84bf2ebd35c18d06">get_if</a> ()</td></tr>
<tr class="memdesc:a44ebea12f30b1b3e84bf2ebd35c18d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> as type T if the value in this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> is of type T.  <a href="classrr_1_1Setting.html#a44ebea12f30b1b3e84bf2ebd35c18d06">More...</a><br /></td></tr>
<tr class="separator:a44ebea12f30b1b3e84bf2ebd35c18d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b66c72a2cf9b9215733f554b6cd466e"><td class="memTemplParams" colspan="2">template&lt;class SettingType &gt; </td></tr>
<tr class="memitem:a7b66c72a2cf9b9215733f554b6cd466e"><td class="memTemplItemLeft" align="right" valign="top">SettingType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a7b66c72a2cf9b9215733f554b6cd466e">get</a> ()</td></tr>
<tr class="memdesc:a7b66c72a2cf9b9215733f554b6cd466e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value held by this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> as a type SettingType.  <a href="classrr_1_1Setting.html#a7b66c72a2cf9b9215733f554b6cd466e">More...</a><br /></td></tr>
<tr class="separator:a7b66c72a2cf9b9215733f554b6cd466e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab029a70cdac39e82fba2a7857de00679"><td class="memTemplParams" colspan="2">template&lt;class As &gt; </td></tr>
<tr class="memitem:ab029a70cdac39e82fba2a7857de00679"><td class="memTemplItemLeft" align="right" valign="top">As&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ab029a70cdac39e82fba2a7857de00679">getAs</a> () const</td></tr>
<tr class="memdesc:ab029a70cdac39e82fba2a7857de00679"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly convert this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> to type As.  <a href="classrr_1_1Setting.html#ab029a70cdac39e82fba2a7857de00679">More...</a><br /></td></tr>
<tr class="separator:ab029a70cdac39e82fba2a7857de00679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84a4c084c67e19d37327aa6ebfa61c"><td class="memTemplParams" colspan="2">template&lt;class SettingType &gt; </td></tr>
<tr class="memitem:afc84a4c084c67e19d37327aa6ebfa61c"><td class="memTemplItemLeft" align="right" valign="top">SettingType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#afc84a4c084c67e19d37327aa6ebfa61c">get</a> () const</td></tr>
<tr class="memdesc:afc84a4c084c67e19d37327aa6ebfa61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value held by this setting as type SettingType.  <a href="classrr_1_1Setting.html#afc84a4c084c67e19d37327aa6ebfa61c">More...</a><br /></td></tr>
<tr class="separator:afc84a4c084c67e19d37327aa6ebfa61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76e883343a714ee58ee6025ebd0fefa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa76e883343a714ee58ee6025ebd0fefa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#aa76e883343a714ee58ee6025ebd0fefa">operator T</a> () const</td></tr>
<tr class="memdesc:aa76e883343a714ee58ee6025ebd0fefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">implicit type conversion support for the <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> class.  <a href="classrr_1_1Setting.html#aa76e883343a714ee58ee6025ebd0fefa">More...</a><br /></td></tr>
<tr class="separator:aa76e883343a714ee58ee6025ebd0fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72b6486d1e76a711eeebaef6c806f70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#aa72b6486d1e76a711eeebaef6c806f70">operator std::vector&lt; double &gt;</a> ()</td></tr>
<tr class="memdesc:aa72b6486d1e76a711eeebaef6c806f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">implicit cast this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> to a std::vector&lt;double&gt;.  <a href="classrr_1_1Setting.html#aa72b6486d1e76a711eeebaef6c806f70">More...</a><br /></td></tr>
<tr class="separator:aa72b6486d1e76a711eeebaef6c806f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a86d3d0bd3a722a37f26d6afeef5a2"><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr class="memitem:ac2a86d3d0bd3a722a37f26d6afeef5a2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ac2a86d3d0bd3a722a37f26d6afeef5a2">visit</a> (Func function) const</td></tr>
<tr class="memdesc:ac2a86d3d0bd3a722a37f26d6afeef5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality operator for comparing object otherSetting of type T against the <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> contained within this Setting.value_.  <a href="classrr_1_1Setting.html#ac2a86d3d0bd3a722a37f26d6afeef5a2">More...</a><br /></td></tr>
<tr class="separator:ac2a86d3d0bd3a722a37f26d6afeef5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c1f37c3e43dd1850e4a4dd1e96b305"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a66c1f37c3e43dd1850e4a4dd1e96b305">typeInfo</a> () const</td></tr>
<tr class="memdesc:a66c1f37c3e43dd1850e4a4dd1e96b305"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the std::type_info for the object type contained within this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>.  <a href="classrr_1_1Setting.html#a66c1f37c3e43dd1850e4a4dd1e96b305">More...</a><br /></td></tr>
<tr class="separator:a66c1f37c3e43dd1850e4a4dd1e96b305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf3783161d25aa1082673116eb44df0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1Setting.html">Setting</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#adcf3783161d25aa1082673116eb44df0">operator=</a> (const <a class="el" href="classrr_1_1Setting.html">Setting</a> &amp;setting)</td></tr>
<tr class="memdesc:adcf3783161d25aa1082673116eb44df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment operator for when rhs is a <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>.  <a href="classrr_1_1Setting.html#adcf3783161d25aa1082673116eb44df0">More...</a><br /></td></tr>
<tr class="separator:adcf3783161d25aa1082673116eb44df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732b55592cf2f1ce8a12135b2c147420"><td class="memItemLeft" align="right" valign="top"><a id="a732b55592cf2f1ce8a12135b2c147420"></a>
<a class="el" href="classrr_1_1Setting.html">Setting</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a732b55592cf2f1ce8a12135b2c147420">operator=</a> (<a class="el" href="classrr_1_1Setting.html">Setting</a> &amp;&amp;setting) noexcept</td></tr>
<tr class="memdesc:a732b55592cf2f1ce8a12135b2c147420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> with another <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. <br /></td></tr>
<tr class="separator:a732b55592cf2f1ce8a12135b2c147420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50ac7ee57ce021f05b336d3d4c0137"><td class="memItemLeft" align="right" valign="top"><a id="aff50ac7ee57ce021f05b336d3d4c0137"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#aff50ac7ee57ce021f05b336d3d4c0137">Setting</a> (const <a class="el" href="classrr_1_1Setting.html">Setting</a> &amp;setting)</td></tr>
<tr class="memdesc:aff50ac7ee57ce021f05b336d3d4c0137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> with another <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. <br /></td></tr>
<tr class="separator:aff50ac7ee57ce021f05b336d3d4c0137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6b0ac9f9de9746d65dcd5dc2d116c9"><td class="memItemLeft" align="right" valign="top"><a id="aac6b0ac9f9de9746d65dcd5dc2d116c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#aac6b0ac9f9de9746d65dcd5dc2d116c9">Setting</a> (<a class="el" href="classrr_1_1Setting.html">Setting</a> &amp;&amp;setting) noexcept</td></tr>
<tr class="memdesc:aac6b0ac9f9de9746d65dcd5dc2d116c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> with another <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. <br /></td></tr>
<tr class="separator:aac6b0ac9f9de9746d65dcd5dc2d116c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861cc76edbf64525ccf1c1f5c6e7a553"><td class="memItemLeft" align="right" valign="top"><a id="a861cc76edbf64525ccf1c1f5c6e7a553"></a>
const setting_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a861cc76edbf64525ccf1c1f5c6e7a553">getValue</a> () const</td></tr>
<tr class="memdesc:a861cc76edbf64525ccf1c1f5c6e7a553"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the std::variant_t underlying this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. <br /></td></tr>
<tr class="separator:a861cc76edbf64525ccf1c1f5c6e7a553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca92fd79b60e0dfbf9b3f14893b766b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#aca92fd79b60e0dfbf9b3f14893b766b6">pythonRepr</a> () const</td></tr>
<tr class="memdesc:aca92fd79b60e0dfbf9b3f14893b766b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to Python-compatible representation.  <a href="classrr_1_1Setting.html#aca92fd79b60e0dfbf9b3f14893b766b6">More...</a><br /></td></tr>
<tr class="separator:aca92fd79b60e0dfbf9b3f14893b766b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499f1510451d2871797bfc3d26c18f1d"><td class="memItemLeft" align="right" valign="top"><a id="a499f1510451d2871797bfc3d26c18f1d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a499f1510451d2871797bfc3d26c18f1d">isString</a> () const</td></tr>
<tr class="memdesc:a499f1510451d2871797bfc3d26c18f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">is this variant a std::string. <br /></td></tr>
<tr class="separator:a499f1510451d2871797bfc3d26c18f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2f542b2952e6280399a1f89736341f"><td class="memItemLeft" align="right" valign="top"><a id="adc2f542b2952e6280399a1f89736341f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#adc2f542b2952e6280399a1f89736341f">isInteger</a> () const</td></tr>
<tr class="memdesc:adc2f542b2952e6280399a1f89736341f"><td class="mdescLeft">&#160;</td><td class="mdescRight">was an integer stored here. <br /></td></tr>
<tr class="separator:adc2f542b2952e6280399a1f89736341f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60624a988dc8231d26ad87850cbb3a3"><td class="memItemLeft" align="right" valign="top"><a id="ac60624a988dc8231d26ad87850cbb3a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ac60624a988dc8231d26ad87850cbb3a3">isNumeric</a> () const</td></tr>
<tr class="memdesc:ac60624a988dc8231d26ad87850cbb3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">is this a numeric type. <br /></td></tr>
<tr class="separator:ac60624a988dc8231d26ad87850cbb3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69a91585985c14cff53b770d559eddd"><td class="memItemLeft" align="right" valign="top"><a id="af69a91585985c14cff53b770d559eddd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#af69a91585985c14cff53b770d559eddd">isBool</a> () const</td></tr>
<tr class="memdesc:af69a91585985c14cff53b770d559eddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">is this a boolean type. <br /></td></tr>
<tr class="separator:af69a91585985c14cff53b770d559eddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6325294c5a5961ea2425b63898552aba"><td class="memItemLeft" align="right" valign="top"><a id="a6325294c5a5961ea2425b63898552aba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a6325294c5a5961ea2425b63898552aba">isEmpty</a> () const</td></tr>
<tr class="memdesc:a6325294c5a5961ea2425b63898552aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if empty. <br /></td></tr>
<tr class="separator:a6325294c5a5961ea2425b63898552aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88fb6abc4e46931b13a7d8501821356"><td class="memItemLeft" align="right" valign="top"><a id="ac88fb6abc4e46931b13a7d8501821356"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ac88fb6abc4e46931b13a7d8501821356">isSigned</a> () const</td></tr>
<tr class="memdesc:ac88fb6abc4e46931b13a7d8501821356"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if this is a signed number. <br /></td></tr>
<tr class="separator:ac88fb6abc4e46931b13a7d8501821356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcde472a8b1e12715fc87ff59d30563"><td class="memItemLeft" align="right" valign="top"><a id="a3fcde472a8b1e12715fc87ff59d30563"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a3fcde472a8b1e12715fc87ff59d30563">isDoubleVector</a> () const</td></tr>
<tr class="memdesc:a3fcde472a8b1e12715fc87ff59d30563"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if this is a std::vector of doubles <br /></td></tr>
<tr class="separator:a3fcde472a8b1e12715fc87ff59d30563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602da5dcede622d5912669b7a66ddb54"><td class="memItemLeft" align="right" valign="top"><a id="a602da5dcede622d5912669b7a66ddb54"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a602da5dcede622d5912669b7a66ddb54">isDouble</a> () const</td></tr>
<tr class="memdesc:a602da5dcede622d5912669b7a66ddb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if this is a double <br /></td></tr>
<tr class="separator:a602da5dcede622d5912669b7a66ddb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee105bd7e3f37b7109004f9fa056e78"><td class="memItemLeft" align="right" valign="top"><a id="a1ee105bd7e3f37b7109004f9fa056e78"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#a1ee105bd7e3f37b7109004f9fa056e78">toString</a> ()</td></tr>
<tr class="memdesc:a1ee105bd7e3f37b7109004f9fa056e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets a string representation of the type stored in this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. <br /></td></tr>
<tr class="separator:a1ee105bd7e3f37b7109004f9fa056e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab97b3a831c1ee98cb591c146cff9d52b"><td class="memTemplParams" colspan="2"><a id="ab97b3a831c1ee98cb591c146cff9d52b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab97b3a831c1ee98cb591c146cff9d52b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ab97b3a831c1ee98cb591c146cff9d52b">isValidType</a> ()</td></tr>
<tr class="memdesc:ab97b3a831c1ee98cb591c146cff9d52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">test for membership of type T in setting_t, aka supported types <br /></td></tr>
<tr class="separator:ab97b3a831c1ee98cb591c146cff9d52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b4bb5f092aa767644bf7b59a41f66"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1Setting.html">Setting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1Setting.html#ad62b4bb5f092aa767644bf7b59a41f66">parse</a> (std::string &amp;val)</td></tr>
<tr class="memdesc:ad62b4bb5f092aa767644bf7b59a41f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the std::string which must be in JSON format.  <a href="classrr_1_1Setting.html#ad62b4bb5f092aa767644bf7b59a41f66">More...</a><br /></td></tr>
<tr class="separator:ad62b4bb5f092aa767644bf7b59a41f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Store a roadrunner option (or setting) as a <a class="el" href="classrr_1_1Variant.html" title="A basic type to hold a variety of data types.">Variant</a> type. </p>
<p>Uses a std::variant to hold one of the following types , std::monostate, std::string, bool, std::int32_t, std::uint32_t, std::int64_t, std::uint64_t, float, double, char, unsigned char, std::vector&lt;double&gt; </p><dl class="section note"><dt>Note</dt><dd>for developers: order of the std::variant template specialization is important. Make sure the order always matches the other of the <a class="el" href="classrr_1_1Setting.html#af49342a0fabdeeafe649246089a72b40" title="types that correspond to the index of the position of the type in the variant template.">Setting::TypeId</a> enum. </dd>
<dd>
The function of this class used to be performed by <a class="el" href="classrr_1_1Variant.html" title="A basic type to hold a variety of data types.">rr::Variant</a>. Since C++17 we have replaced this with a standard type.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// implicit type conversions</span></div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting(4); <span class="comment">// is an int</span></div>
<div class="line"><span class="keywordtype">int</span> s = setting.get&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// okay</span></div>
<div class="line"><span class="keywordtype">int</span> t = setting.get&lt;std::string&gt;(); <span class="comment">// not okay, setting contains an int</span></div>
<div class="line"><span class="keyword">auto</span> u = setting.get_if&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// u is pointer to int if setting is int else nullptr</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> v = setting.get_if&lt;<span class="keywordtype">int</span>&gt;()){</div>
<div class="line">    <span class="comment">// do something in context where `setting` is int</span></div>
<div class="line">}</div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting2(-4); <span class="comment">// contains an int with negative value</span></div>
<div class="line"><span class="keywordtype">int</span> q = setting2; <span class="comment">// okay</span></div>
<div class="line"><span class="keywordtype">long</span> r = setting2; <span class="comment">// okay</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> w = setting2; <span class="comment">// error, setting2 contains negative value</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> x = setting2; <span class="comment">// error, setting2 contains negative value</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">long</span> biggest_int = std::numeric_limits&lt;int&gt;::max();</div>
<div class="line"><span class="keywordtype">long</span> out_of_range = biggest_int * 10;</div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting(out_of_range);</div>
<div class="line"><span class="keywordtype">int</span> x = setting; <span class="comment">// error, int isn&#39;t big enough to hold `out_out_range`</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// equality works as expected</span></div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting3(std::int64_t(12345678912345));</div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting4(std::int64_t(12345678912345));</div>
<div class="line">ASSERT_TRUE(setting3 == setting4); <span class="comment">// pass</span></div>
<div class="line">ASSERT_TRUE(setting3 == 12345678912345); <span class="comment">// also okay</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// reassign a setting to different type</span></div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting5(123);</div>
<div class="line">setting5 = <span class="stringliteral">&quot;Now a string&quot;</span>; <span class="comment">// okay</span></div>
<div class="line">std::string expected = <span class="stringliteral">&quot;Now a string&quot;</span>;</div>
<div class="line">ASSERT_TRUE(setting5 == expected); <span class="comment">// pass</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// instantiating a setting from other objects</span></div>
<div class="line">std::string st = <span class="stringliteral">&quot;A String&quot;</span>;</div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting6(st); <span class="comment">//okay</span></div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting7 = st ; <span class="comment">// not okay</span></div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting8 = <span class="stringliteral">&quot;A string&quot;</span>; <span class="comment">// not okay</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// check if Setting supports a type</span></div>
<div class="line"><span class="keywordtype">bool</span> supported = Setting::isValidType&lt;int&gt;(); <span class="comment">// true</span></div>
<div class="line">supported = Setting::isValidType&lt;std::string&gt;(); <span class="comment">// true</span></div>
<div class="line">supported = Setting::isValidType&lt;const char*&gt;(); <span class="comment">// false</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af49342a0fabdeeafe649246089a72b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49342a0fabdeeafe649246089a72b40">&#9670;&nbsp;</a></span>TypeId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrr_1_1Setting.html#af49342a0fabdeeafe649246089a72b40">rr::Setting::TypeId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>types that correspond to the index of the position of the type in the variant template. </p>
<p>i.e. std::string is index 0. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ace675cf68c9885e451535578e3c2eff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace675cf68c9885e451535578e3c2eff9">&#9670;&nbsp;</a></span>Setting() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rr::Setting::Setting </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>settingValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for creating a <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> from a supperted type T. </p>
<dl class="section see"><dt>See also</dt><dd>setting_t for supported types  for developers: clang-tidy will want you to make this constructor explicit. However, we intentionally keep implicit to allow <a class="el" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04" title="returns the type of std::variant contained within this Setting.">type</a> casting from <a class="el" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04" title="returns the type of std::variant contained within this Setting.">type</a> T to <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. </dd></dl>

</div>
</div>
<a id="a9fe62fdd022c03a9542db4cca43aa6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe62fdd022c03a9542db4cca43aa6a5">&#9670;&nbsp;</a></span>Setting() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rr::Setting::Setting </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>settingValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for enabling creation of a <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> from a string literal. </p>
<p>The literal gets converted into a std::string </p><div class="fragment"><div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> s(<span class="stringliteral">&quot;a string&quot;</span>); <span class="comment">//interpreted as string, not const char*</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2f608e0145800200b7795eea56a93cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f608e0145800200b7795eea56a93cd5">&#9670;&nbsp;</a></span>Setting() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rr::Setting::Setting </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>settingValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct from a long. </p>
<p>(std::int64_t is a long long, which matters on windows) </p>

</div>
</div>
<a id="a2f3f6beff36ad237ca6493dfaa19741f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3f6beff36ad237ca6493dfaa19741f">&#9670;&nbsp;</a></span>Setting() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rr::Setting::Setting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor. </p>
<p>Allows instantiating of an empty setting. The empty setting will have a type of std::monostate, which is index 0 in setting_t </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b66c72a2cf9b9215733f554b6cd466e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b66c72a2cf9b9215733f554b6cd466e">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SettingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SettingType rr::Setting::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the value held by this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> as a type SettingType. </p>
<p>simple wrapper around std::get. </p><dl class="section note"><dt>Note</dt><dd>for developers. This is a replacement for <a class="el" href="classrr_1_1Variant.html#a7bb371be936601754f61d5285f834352" title="Convert this variant to a supported data type.">rr::Variant::convert</a> in legacy roadrunner. The name "get" is preferred to "convert" since it follows C++ standard conventions. </dd></dl>

</div>
</div>
<a id="afc84a4c084c67e19d37327aa6ebfa61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc84a4c084c67e19d37327aa6ebfa61c">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SettingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SettingType rr::Setting::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the value held by this setting as type SettingType. </p>
<p>const version of SettingType::get() </p><dl class="section see"><dt>See also</dt><dd>SettingType::get() </dd></dl>

</div>
</div>
<a id="a44ebea12f30b1b3e84bf2ebd35c18d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ebea12f30b1b3e84bf2ebd35c18d06">&#9670;&nbsp;</a></span>get_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* rr::Setting::get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the value of this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> as type T if the value in this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> is of type T. </p>
<p>wrapper around std::get_if </p>

</div>
</div>
<a id="ab029a70cdac39e82fba2a7857de00679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab029a70cdac39e82fba2a7857de00679">&#9670;&nbsp;</a></span>getAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class As &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">As rr::Setting::getAs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly convert this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> to type As. </p>
<p>type contained by this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> must be readily convertible to type As and throws std::invalid_argument if not. </p><div class="fragment"><div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> setting(5);</div>
<div class="line">ASSERT_EQ(setting.get&lt;<span class="keywordtype">int</span>&gt;(), 5); <span class="comment">// fails if setting is not int</span></div>
<div class="line">ASSERT_THROW(setting.get&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;();, std::bad_variant_access); <span class="comment">// bad, setting contains an int</span></div>
<div class="line">ASSERT_EQ(setting.getAs&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(), 5); <span class="comment">// Okay, we can convert from int to unsigned (when int &gt; 0)</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab0b42145e5c0dab9a86a5faa790f1d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b42145e5c0dab9a86a5faa790f1d7f">&#9670;&nbsp;</a></span>isType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::Setting::isType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determines whether the current value of <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> is of type T. </p>
<dl class="section return"><dt>Returns</dt><dd>true is <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> is of type T </dd></dl>

</div>
</div>
<a id="aa72b6486d1e76a711eeebaef6c806f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72b6486d1e76a711eeebaef6c806f70">&#9670;&nbsp;</a></span>operator std::vector&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rr::Setting::operator std::vector&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implicit cast this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> to a std::vector&lt;double&gt;. </p>
<p>If this operator is used and the type contained by this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> is not a double vector, an std::invalid_argument error is thrown.  the generic operator T() method does not cover the case when we have a vector of doubles, so we must implement this manually. We could write another template for the more general case, but only support for std::vector&lt;double&gt; is needed. </p>

</div>
</div>
<a id="aa76e883343a714ee58ee6025ebd0fefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76e883343a714ee58ee6025ebd0fefa">&#9670;&nbsp;</a></span>operator T()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rr::Setting::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implicit type conversion support for the <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> class. </p>
<p>this method is responsible for enabling implicit conversion between <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> and its supported types. Moreover, it enables one to implicitly convert (say) a int to a long, in contexts that make sense (as determined by std::is_convertible_v). Some situations are explicitly prohibited from implicit type conversion. These include</p><ul>
<li>converting a negative int or long to unsigned int or long</li>
<li>converting a long that has a value &gt; the largest possible value for int to int <dl class="section note"><dt>Note</dt><dd>for developers: clang-tidy will ask you to make this explicit, but this method <em>must</em> not be explicit since its entire purpose is implicit type conversion. </dd>
<dd>
for developers: Any additions to types stored in a setting_t <em>must</em> have appropriate unit tests added for the new types in SettingTests.cpp. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="adcf3783161d25aa1082673116eb44df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf3783161d25aa1082673116eb44df0">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1Setting.html">Setting</a> &amp; rr::Setting::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1Setting.html">Setting</a> &amp;&#160;</td>
          <td class="paramname"><em>setting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>move assignment operator for when rhs is a <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. </p>
<dl class="section see"><dt>See also</dt><dd>operator=(const T&amp;setting); </dd></dl>

</div>
</div>
<a id="ad62b4bb5f092aa767644bf7b59a41f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62b4bb5f092aa767644bf7b59a41f66">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1Setting.html">Setting</a> rr::Setting::parse </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the std::string which must be in JSON format. </p>
<p>This is a common way to read a <a class="el" href="classrr_1_1Variant.html" title="A basic type to hold a variety of data types.">Variant</a> from a file or create a new one from a std::string: </p><div class="fragment"><div class="line">Variant v = <a class="code" href="classrr_1_1Variant.html#abe42f3be24595157e92e255ddf5ef082">Variant::parse</a>(<span class="stringliteral">&quot;0.123&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>this function is a tangent to the main <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> class. We should instead have a JSON parser, is that's the function we need. </dd></dl>

</div>
</div>
<a id="aca92fd79b60e0dfbf9b3f14893b766b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca92fd79b60e0dfbf9b3f14893b766b6">&#9670;&nbsp;</a></span>pythonRepr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rr::Setting::pythonRepr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to Python-compatible representation. </p>
<dl class="section author"><dt>Author</dt><dd>JKM </dd></dl>

</div>
</div>
<a id="a479708abc63de00aca3d56b7e28bee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479708abc63de00aca3d56b7e28bee04">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1Setting.html#af49342a0fabdeeafe649246089a72b40">Setting::TypeId</a> rr::Setting::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the type of std::variant contained within this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>an integer which refers to the index of the type contained in this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. The index is resolved by looking at the TypeId enum (or indeed the ordering of the type parameters to setting_t. </dd></dl>

</div>
</div>
<a id="a66c1f37c3e43dd1850e4a4dd1e96b305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c1f37c3e43dd1850e4a4dd1e96b305">&#9670;&nbsp;</a></span>typeInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info &amp; rr::Setting::typeInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the std::type_info for the object type contained within this <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a>. </p>
<p>(aka one of the types within setting_t) </p>

</div>
</div>
<a id="ac2a86d3d0bd3a722a37f26d6afeef5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a86d3d0bd3a722a37f26d6afeef5a2">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) rr::Setting::visit </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equality operator for comparing object otherSetting of type T against the <a class="el" href="classrr_1_1Setting.html" title="Store a roadrunner option (or setting) as a Variant type.">Setting</a> contained within this Setting.value_. </p>
<p>Enables the following types of comparisons </p><div class="fragment"><div class="line">    <a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> s1(<span class="stringliteral">&quot;string&quot;</span>);</div>
<div class="line">    std::string s2 = <span class="stringliteral">&quot;string&quot;</span>;</div>
<div class="line">    s1 == s2; <span class="comment">// true</span></div>
<div class="line">    <span class="comment">// or</span></div>
<div class="line">    <a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> s3(1234);</div>
<div class="line">    <span class="keywordtype">int</span> s4 = 1234;</div>
<div class="line">    s3 == s4; <span class="comment">// true</span></div>
<div class="line">   @details Implemented <span class="keyword">using</span> SFINAE - substitute failure is not an error.</div>
<div class="line">   The seconds <span class="keyword">template</span> argument is only <span class="keyword">true</span> when <a class="code" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">type</a> T is a valid variant</div>
<div class="line">   and when <span class="keyword">this</span> argument evaluates to <span class="keyword">false</span>, the compiler will not generate</div>
<div class="line">   a code <span class="keywordflow">for</span> the <span class="keyword">template</span> types. Thus, <span class="keyword">this</span> <span class="keyword">template</span> is only defined <span class="keywordflow">for</span></div>
<div class="line">   types that are a part of setting_t.</div>
<div class="line">  /</div>
<div class="line">template&lt;typename T, class = typename std::enable_if&lt;isValidVariantType&lt;T, setting_t&gt;::value&gt;<a class="code" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">::type</a>&gt;</div>
<div class="line"><span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> T &amp;otherSetting) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> settingValue = get_if&lt;T&gt;()) {</div>
<div class="line">        <span class="keywordflow">return</span> *settingValue == otherSetting;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</div>
<div class="line">        <span class="keyword">class </span>= <span class="keyword">typename</span> std::enable_if&lt;isValidVariantType&lt;T, setting_t&gt;::value&gt;<a class="code" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">::type</a>&gt;</div>
<div class="line"><span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> T &amp;setting) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == setting);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> &amp;setting);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <span class="keywordtype">char</span> *setting);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <span class="keywordtype">char</span> *setting);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> &amp;setting);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">template&lt;typename T, class = typename std::enable_if&lt;isValidVariantType&lt;T, setting_t&gt;::value&gt;<a class="code" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">::type</a>&gt;</div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> &amp;<a class="code" href="classrr_1_1Setting.html#adcf3783161d25aa1082673116eb44df0">operator=</a>(<span class="keyword">const</span> T &amp;setting) {</div>
<div class="line">    checkValidType&lt;T&gt;();</div>
<div class="line">    <span class="comment">// no need to check self assignment with variant</span></div>
<div class="line">    value_ = setting_t(setting);</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template&lt;typename T, class = typename std::enable_if&lt;isValidVariantType&lt;T, setting_t&gt;::value&gt;<a class="code" href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">::type</a>&gt;</div>
<div class="line"><a class="code" href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">Setting</a> &amp;<a class="code" href="classrr_1_1Setting.html#adcf3783161d25aa1082673116eb44df0">operator=</a>(T &amp;&amp;setting) noexcept {</div>
<div class="line">    checkValidType&lt;T&gt;();</div>
<div class="line">    <span class="comment">// no need to check self assignment with variant</span></div>
<div class="line">    value_ = std::move(setting_t(setting));</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>docs on std::visit </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Setting_8h_source.html">Setting.h</a></li>
<li>Setting.cpp</li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassrr_1_1Setting_html_adcf3783161d25aa1082673116eb44df0"><div class="ttname"><a href="classrr_1_1Setting.html#adcf3783161d25aa1082673116eb44df0">rr::Setting::operator=</a></div><div class="ttdeci">Setting &amp; operator=(const Setting &amp;setting)</div><div class="ttdoc">move assignment operator for when rhs is a Setting.</div><div class="ttdef"><b>Definition:</b> Setting.cpp:119</div></div>
<div class="ttc" id="aclassrr_1_1Variant_html_abe42f3be24595157e92e255ddf5ef082"><div class="ttname"><a href="classrr_1_1Variant.html#abe42f3be24595157e92e255ddf5ef082">rr::Variant::parse</a></div><div class="ttdeci">static Variant parse(const std::string &amp;val)</div><div class="ttdoc">Parses the std::string which must be in JSON format.</div><div class="ttdef"><b>Definition:</b> _Variant.cpp:140</div></div>
<div class="ttc" id="aclassrr_1_1Setting_html_a2f3f6beff36ad237ca6493dfaa19741f"><div class="ttname"><a href="classrr_1_1Setting.html#a2f3f6beff36ad237ca6493dfaa19741f">rr::Setting::Setting</a></div><div class="ttdeci">Setting()=default</div><div class="ttdoc">default constructor.</div></div>
<div class="ttc" id="aclassrr_1_1Setting_html_a479708abc63de00aca3d56b7e28bee04"><div class="ttname"><a href="classrr_1_1Setting.html#a479708abc63de00aca3d56b7e28bee04">rr::Setting::type</a></div><div class="ttdeci">TypeId type() const</div><div class="ttdoc">returns the type of std::variant contained within this Setting.</div><div class="ttdef"><b>Definition:</b> Setting.cpp:22</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
