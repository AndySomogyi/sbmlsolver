<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>roadrunner: rrllvm::LLVMModelSymbols Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">roadrunner<span id="projectnumber">&#160;2.2.0</span>
   </div>
   <div id="projectbrief">Fast simulator for SBML models</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>rrllvm</b></li><li class="navelem"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html">LLVMModelSymbols</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrrllvm_1_1LLVMModelSymbols-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rrllvm::LLVMModelSymbols Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Hold all the un-evaluated symbolic inforamtion in the model.  
 <a href="classrrllvm_1_1LLVMModelSymbols.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LLVMModelSymbols_8h_source.html">LLVMModelSymbols.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rrllvm::LLVMModelSymbols:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrrllvm_1_1LLVMModelSymbols.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrrllvm_1_1LLVMModelSymbols_1_1ReactionSymbols.html">ReactionSymbols</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hold the symbols that belong to a reactions.  <a href="structrrllvm_1_1LLVMModelSymbols_1_1ReactionSymbols.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9fda0c55204e8ffde65564b535be7bbb"><td class="memItemLeft" align="right" valign="top"><a id="a9fda0c55204e8ffde65564b535be7bbb" name="a9fda0c55204e8ffde65564b535be7bbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLVMModelSymbols</b> (libsbml::Model const *m, <a class="el" href="classrrllvm_1_1LLVMModelDataSymbols.html">LLVMModelDataSymbols</a> const &amp;sym)</td></tr>
<tr class="separator:a9fda0c55204e8ffde65564b535be7bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67637dde17c580f01ed1a54476e17e2b"><td class="memItemLeft" align="right" valign="top">libsbml::ASTNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#a67637dde17c580f01ed1a54476e17e2b">createStoichiometryNode</a> (int row, int col) const</td></tr>
<tr class="memdesc:a67637dde17c580f01ed1a54476e17e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an ASTNode for the species id / reaction id std::pair.  <a href="classrrllvm_1_1LLVMModelSymbols.html#a67637dde17c580f01ed1a54476e17e2b">More...</a><br /></td></tr>
<tr class="separator:a67637dde17c580f01ed1a54476e17e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf501a34dd03317a49d5f3ba70839dd"><td class="memItemLeft" align="right" valign="top"><a id="afaf501a34dd03317a49d5f3ba70839dd" name="afaf501a34dd03317a49d5f3ba70839dd"></a>
const <a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAssigmentRules</b> () const</td></tr>
<tr class="memdesc:afaf501a34dd03317a49d5f3ba70839dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment rules are always active <br /></td></tr>
<tr class="separator:afaf501a34dd03317a49d5f3ba70839dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d0e9e5abc92d6295a5f520436f54e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#ad7d0e9e5abc92d6295a5f520436f54e6">getInitialAssignmentRules</a> () const</td></tr>
<tr class="memdesc:ad7d0e9e5abc92d6295a5f520436f54e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">only valid before the model is started.  <a href="classrrllvm_1_1LLVMModelSymbols.html#ad7d0e9e5abc92d6295a5f520436f54e6">More...</a><br /></td></tr>
<tr class="separator:ad7d0e9e5abc92d6295a5f520436f54e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49316f650dfad2cd908e12d61d78be50"><td class="memItemLeft" align="right" valign="top"><a id="a49316f650dfad2cd908e12d61d78be50" name="a49316f650dfad2cd908e12d61d78be50"></a>
const <a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInitialValues</b> () const</td></tr>
<tr class="memdesc:a49316f650dfad2cd908e12d61d78be50"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains the intial symbols along with the intial assignments which override the initial values. <br /></td></tr>
<tr class="separator:a49316f650dfad2cd908e12d61d78be50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386262795c9ce38df4cec2dec51f1104"><td class="memItemLeft" align="right" valign="top"><a id="a386262795c9ce38df4cec2dec51f1104" name="a386262795c9ce38df4cec2dec51f1104"></a>
const <a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getRateRules</b> () const</td></tr>
<tr class="separator:a386262795c9ce38df4cec2dec51f1104"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aab332944da88f5c74e0b6dd11a7c98b1"><td class="memItemLeft" align="right" valign="top"><a id="aab332944da88f5c74e0b6dd11a7c98b1" name="aab332944da88f5c74e0b6dd11a7c98b1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SpeciesReferenceType</b> { <b>Reactant</b>
, <b>Product</b>
 }</td></tr>
<tr class="separator:aab332944da88f5c74e0b6dd11a7c98b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fdc885f2f338870ddd18853a7ab825"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; const libsbml::ASTNode * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#ab3fdc885f2f338870ddd18853a7ab825">ASTNodeList</a></td></tr>
<tr class="memdesc:ab3fdc885f2f338870ddd18853a7ab825"><td class="mdescLeft">&#160;</td><td class="mdescRight">a species can appear more than once in a reaction, there can be several stoichiometries for a species both as a product and as a reactant, for example, we could have  <a href="classrrllvm_1_1LLVMModelSymbols.html#ab3fdc885f2f338870ddd18853a7ab825">More...</a><br /></td></tr>
<tr class="separator:ab3fdc885f2f338870ddd18853a7ab825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346c6aa644b3297b1319a3f619bdfe9e"><td class="memItemLeft" align="right" valign="top"><a id="a346c6aa644b3297b1319a3f619bdfe9e" name="a346c6aa644b3297b1319a3f619bdfe9e"></a>
typedef std::map&lt; int, <a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#ab3fdc885f2f338870ddd18853a7ab825">ASTNodeList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IntASTNodeListMap</b></td></tr>
<tr class="memdesc:a346c6aa644b3297b1319a3f619bdfe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">we reference the reactants and products by the species index <br /></td></tr>
<tr class="separator:a346c6aa644b3297b1319a3f619bdfe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1d24ecf7085ed6d7413963935913d140"><td class="memItemLeft" align="right" valign="top"><a id="a1d24ecf7085ed6d7413963935913d140" name="a1d24ecf7085ed6d7413963935913d140"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const libsbml::Compartment &amp;x)</td></tr>
<tr class="separator:a1d24ecf7085ed6d7413963935913d140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e98cee17cce98a3e09b31f683c5e2a5"><td class="memItemLeft" align="right" valign="top"><a id="a3e98cee17cce98a3e09b31f683c5e2a5" name="a3e98cee17cce98a3e09b31f683c5e2a5"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const libsbml::Species &amp;x)</td></tr>
<tr class="separator:a3e98cee17cce98a3e09b31f683c5e2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402445cf2bacf7dd2acfe84b7af112c4"><td class="memItemLeft" align="right" valign="top"><a id="a402445cf2bacf7dd2acfe84b7af112c4" name="a402445cf2bacf7dd2acfe84b7af112c4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const libsbml::AssignmentRule &amp;x)</td></tr>
<tr class="separator:a402445cf2bacf7dd2acfe84b7af112c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11942961af6c34d90fd7aa33ea2bc8e9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#a11942961af6c34d90fd7aa33ea2bc8e9">visit</a> (const libsbml::InitialAssignment &amp;x)</td></tr>
<tr class="memdesc:a11942961af6c34d90fd7aa33ea2bc8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">InitialAssignments override the initial value specified in the element definition.  <a href="classrrllvm_1_1LLVMModelSymbols.html#a11942961af6c34d90fd7aa33ea2bc8e9">More...</a><br /></td></tr>
<tr class="separator:a11942961af6c34d90fd7aa33ea2bc8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49c19ac0832e343222276be67190bb4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#ab49c19ac0832e343222276be67190bb4">visit</a> (const libsbml::RateRule &amp;rule)</td></tr>
<tr class="separator:ab49c19ac0832e343222276be67190bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c37bbb6a3226e32748383962e58a4c"><td class="memItemLeft" align="right" valign="top"><a id="a62c37bbb6a3226e32748383962e58a4c" name="a62c37bbb6a3226e32748383962e58a4c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const libsbml::Reaction &amp;x)</td></tr>
<tr class="memdesc:a62c37bbb6a3226e32748383962e58a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">visit the reactions so we can get all the SpeciesReferences and stuff them in the initialConditions std::map. <br /></td></tr>
<tr class="separator:a62c37bbb6a3226e32748383962e58a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a829d1b0ddfb1618c4d1536fd841bf9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#a7a829d1b0ddfb1618c4d1536fd841bf9">visit</a> (const libsbml::Rule &amp;x)</td></tr>
<tr class="memdesc:a7a829d1b0ddfb1618c4d1536fd841bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">tell the acceptor to process all rules, even the ones we don't handle so the iteration continues over all rules.  <a href="classrrllvm_1_1LLVMModelSymbols.html#a7a829d1b0ddfb1618c4d1536fd841bf9">More...</a><br /></td></tr>
<tr class="separator:a7a829d1b0ddfb1618c4d1536fd841bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6fb0b90d1ccd464919ac47031ebee8"><td class="memItemLeft" align="right" valign="top"><a id="a9c6fb0b90d1ccd464919ac47031ebee8" name="a9c6fb0b90d1ccd464919ac47031ebee8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const libsbml::Event &amp;event)</td></tr>
<tr class="memdesc:a9c6fb0b90d1ccd464919ac47031ebee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">fatal error if we find these, event not supported yet <br /></td></tr>
<tr class="separator:a9c6fb0b90d1ccd464919ac47031ebee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a77a8995e4fc70336da702e63c2d0f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#a1a77a8995e4fc70336da702e63c2d0f0">processElement</a> (<a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp;currentSymbols, const libsbml::SBase *element, const libsbml::ASTNode *math)</td></tr>
<tr class="memdesc:a1a77a8995e4fc70336da702e63c2d0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The only differences in how initialAssigments and assignmentRules are handled is whether they are stuffed in the initialAssigment or assignmentRules maps.  <a href="classrrllvm_1_1LLVMModelSymbols.html#a1a77a8995e4fc70336da702e63c2d0f0">More...</a><br /></td></tr>
<tr class="separator:a1a77a8995e4fc70336da702e63c2d0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6de412f4d409e3f5e70adaeecd4727"><td class="memItemLeft" align="right" valign="top"><a id="a0d6de412f4d409e3f5e70adaeecd4727" name="a0d6de412f4d409e3f5e70adaeecd4727"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>processSpecies</b> (<a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp;currentSymbols, const libsbml::Species *element, const libsbml::ASTNode *math)</td></tr>
<tr class="memdesc:a0d6de412f4d409e3f5e70adaeecd4727"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized logic to write both amounts and concentrations here. <br /></td></tr>
<tr class="separator:a0d6de412f4d409e3f5e70adaeecd4727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3232506b1afb34e63e18ee4bf56466"><td class="memItemLeft" align="right" valign="top"><a id="add3232506b1afb34e63e18ee4bf56466" name="add3232506b1afb34e63e18ee4bf56466"></a>
const libsbml::ASTNode *&#160;</td><td class="memItemRight" valign="bottom"><b>getSpeciesReferenceStoichMath</b> (const libsbml::SpeciesReference *reference)</td></tr>
<tr class="memdesc:add3232506b1afb34e63e18ee4bf56466"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the MathML element for a SpeciesReference if it is set, otherwise, create a ASTNode from its stoichiometry field. <br /></td></tr>
<tr class="separator:add3232506b1afb34e63e18ee4bf56466"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1f4ad92a3ca40b064d3015c19b849617"><td class="memItemLeft" align="right" valign="top"><a id="a1f4ad92a3ca40b064d3015c19b849617" name="a1f4ad92a3ca40b064d3015c19b849617"></a>
<a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a>&#160;</td><td class="memItemRight" valign="bottom"><b>initialValues</b></td></tr>
<tr class="separator:a1f4ad92a3ca40b064d3015c19b849617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa336e77aebc8b9dd009048e1ce466146"><td class="memItemLeft" align="right" valign="top"><a id="aa336e77aebc8b9dd009048e1ce466146" name="aa336e77aebc8b9dd009048e1ce466146"></a>
<a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a>&#160;</td><td class="memItemRight" valign="bottom"><b>assignmentRules</b></td></tr>
<tr class="separator:aa336e77aebc8b9dd009048e1ce466146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6126d389448969bc819a7d489ed0f7"><td class="memItemLeft" align="right" valign="top"><a id="a4c6126d389448969bc819a7d489ed0f7" name="a4c6126d389448969bc819a7d489ed0f7"></a>
<a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a>&#160;</td><td class="memItemRight" valign="bottom"><b>initialAssignmentRules</b></td></tr>
<tr class="separator:a4c6126d389448969bc819a7d489ed0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b6a5e622ade1443adb370af0c3fe0d"><td class="memItemLeft" align="right" valign="top"><a id="af0b6a5e622ade1443adb370af0c3fe0d" name="af0b6a5e622ade1443adb370af0c3fe0d"></a>
<a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rateRules</b></td></tr>
<tr class="separator:af0b6a5e622ade1443adb370af0c3fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ee8336c24f1b548a08cb62465faf21"><td class="memItemLeft" align="right" valign="top"><a id="af6ee8336c24f1b548a08cb62465faf21" name="af6ee8336c24f1b548a08cb62465faf21"></a>
<a class="el" href="classrrllvm_1_1ASTNodeFactory.html">ASTNodeFactory</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="memdesc:af6ee8336c24f1b548a08cb62465faf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">all ASTNodes we create are stored here. <br /></td></tr>
<tr class="separator:af6ee8336c24f1b548a08cb62465faf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d63fce05b0352af53d391871b6f5a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structrrllvm_1_1LLVMModelSymbols_1_1ReactionSymbols.html">ReactionSymbols</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#ac3d63fce05b0352af53d391871b6f5a8">reactions</a></td></tr>
<tr class="memdesc:ac3d63fce05b0352af53d391871b6f5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">these are indexed by reaction index.  <a href="classrrllvm_1_1LLVMModelSymbols.html#ac3d63fce05b0352af53d391871b6f5a8">More...</a><br /></td></tr>
<tr class="separator:ac3d63fce05b0352af53d391871b6f5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Hold all the un-evaluated symbolic inforamtion in the model. </p>
<p >TODO: some real docs... </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab3fdc885f2f338870ddd18853a7ab825" name="ab3fdc885f2f338870ddd18853a7ab825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fdc885f2f338870ddd18853a7ab825">&#9670;&nbsp;</a></span>ASTNodeList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;const libsbml::ASTNode*&gt; <a class="el" href="classrrllvm_1_1LLVMModelSymbols.html#ab3fdc885f2f338870ddd18853a7ab825">rrllvm::LLVMModelSymbols::ASTNodeList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a species can appear more than once in a reaction, there can be several stoichiometries for a species both as a product and as a reactant, for example, we could have </p>
<p >A + 2A + B -&gt; A + C</p>
<p >In this case, we calculate the stochiometry for each species as S(A) = -1 -2 + 1 = -1 S(B) = -1 + 0 = -1 S(C) = 0 + 1 = 1</p>
<p >Stochiometries can however change, so we have to delay evaluation of them &ndash; if we have a named species reference, we add an ASTNode with a reference to it: this way, when it get evaluated, we can look up to see if we have any assigment rules or intitial assigments overriding the original value. each species has a list of stoichiometry nodes, this way it can appear more than once. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a67637dde17c580f01ed1a54476e17e2b" name="a67637dde17c580f01ed1a54476e17e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67637dde17c580f01ed1a54476e17e2b">&#9670;&nbsp;</a></span>createStoichiometryNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASTNode * rrllvm::LLVMModelSymbols::createStoichiometryNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an ASTNode for the species id / reaction id std::pair. </p>
<p >This assembles the mess of items stored in the reactions array. </p>

</div>
</div>
<a id="ad7d0e9e5abc92d6295a5f520436f54e6" name="ad7d0e9e5abc92d6295a5f520436f54e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d0e9e5abc92d6295a5f520436f54e6">&#9670;&nbsp;</a></span>getInitialAssignmentRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp; rrllvm::LLVMModelSymbols::getInitialAssignmentRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>only valid before the model is started. </p>
<p >There cannot be both an InitialAssignment and an AssignmentRule for the same symbol in a model, because both kinds of constructs apply prior to and at the start of simulated time allowing both to exist for a given symbol would result in indeterminism.</p>
<p >\conservation: In the case of conserved moieties, these are species that are defined by assignment rules, they however can have initial values defined by initial value or assignment rules.</p>
<p >So, at run time, the assignment rule is active, however before run time, the initial value or initial assignment rule is active. </p>

</div>
</div>
<a id="a1a77a8995e4fc70336da702e63c2d0f0" name="a1a77a8995e4fc70336da702e63c2d0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a77a8995e4fc70336da702e63c2d0f0">&#9670;&nbsp;</a></span>processElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rrllvm::LLVMModelSymbols::processElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrrllvm_1_1SymbolForest.html">SymbolForest</a> &amp;&#160;</td>
          <td class="paramname"><em>currentSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libsbml::SBase *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libsbml::ASTNode *&#160;</td>
          <td class="paramname"><em>math</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The only differences in how initialAssigments and assignmentRules are handled is whether they are stuffed in the initialAssigment or assignmentRules maps. </p>
<p >This figures out what they refer to, and stuffs the AST in the appropriate std::map. </p>

</div>
</div>
<a id="a11942961af6c34d90fd7aa33ea2bc8e9" name="a11942961af6c34d90fd7aa33ea2bc8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11942961af6c34d90fd7aa33ea2bc8e9">&#9670;&nbsp;</a></span>visit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rrllvm::LLVMModelSymbols::visit </td>
          <td>(</td>
          <td class="paramtype">const libsbml::InitialAssignment &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>InitialAssignments override the initial value specified in the element definition. </p>
<p >The actions of all InitialAssignment objects are in general terms the same, but differ in the precise details depending on the type of variable being set:</p>
<ul>
<li>In the case of a species, an InitialAssignment sets the referenced species initial quantity (concentration or amount) to the value determined by the formula in math. The unit associated with the value produced by the math formula should be equal to the unit associated with the species quantity.</li>
<li>In the case of a species reference, an InitialAssignment sets the initial stoichiometry of the reactant or product referenced by the SpeciesReference object to the value determined by the formula in math. The unit associated with the value produced by the math formula should be consistent with the unit dimensionless, because reactant and product stoichiometries in reactions are dimensionless quantities.</li>
<li>In the case of a compartment, an InitialAssignment sets the referenced compartment's initial size to the size determined by the formula in math. The unit associated with the value produced by the math formula should be the same as that specified for the compartment's size.</li>
<li>In the case of a parameter, an InitialAssignment sets the parameter's initial value to the value of the formula in math. The unit associated with the value produced by the math formula should be the same as parameter's units attribute value. </li>
</ul>

</div>
</div>
<a id="ab49c19ac0832e343222276be67190bb4" name="ab49c19ac0832e343222276be67190bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49c19ac0832e343222276be67190bb4">&#9670;&nbsp;</a></span>visit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rrllvm::LLVMModelSymbols::visit </td>
          <td>(</td>
          <td class="paramtype">const libsbml::RateRule &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<ul>
<li>In the case of a species, a RateRule sets the rate of change of the species� quantity (concentration or amount) to the value determined by the formula in math. The unit associated with the rule�s math element should be equal to the unit of the species� quantity (Section 4.6.5) divided by the model-wide unit of time (Section 4.2.4), or in other words, {unit of species quantity}/{unit of time}.</li>
<li>Restrictions: There must not be both a RateRule variable attribute and a SpeciesReference species attribute having the same value, unless that species has its boundaryCondition attribute is set to �true�. This means a rate rule cannot be defined for a species that is created or destroyed in a reaction, unless that species is defined as a boundary condition in the model.</li>
<li>In the case of a species reference, a RateRule sets the rate of change of the stoichiometry of the referenced reactant or product to the value determined by the formula in math. The unit associated with the value produced by the formula should be consistent with {unit derived from dimensionless}/{unit of time}.</li>
<li>In the case of a compartment, a RateRule sets the rate of change of the compartment�s size to the value determined by the formula in math. The unit of the rule�s math element should be identical to the compartment�s units attribute divided by the model-wide unit of time. (In other words, {unit of compartment size}/{unit of time}.)</li>
<li>In the case of a parameter, a RateRule sets the rate of change of the parameter�s value to that determined by the formula in math. The unit associated with the rule�s math element should be equal to the parameter�s units attribute value divided by the model-wide unit of time. (In other words, {parameter units}/{unit of time}.) </li>
</ul>

</div>
</div>
<a id="a7a829d1b0ddfb1618c4d1536fd841bf9" name="a7a829d1b0ddfb1618c4d1536fd841bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a829d1b0ddfb1618c4d1536fd841bf9">&#9670;&nbsp;</a></span>visit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rrllvm::LLVMModelSymbols::visit </td>
          <td>(</td>
          <td class="paramtype">const libsbml::Rule &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tell the acceptor to process all rules, even the ones we don't handle so the iteration continues over all rules. </p>
<p >The left-hand side (the variable attribute) of an assignment rule can refer to the identifier of a Species, SpeciesReference, Compartment, or global Parameter object in the model (but not a reaction) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac3d63fce05b0352af53d391871b6f5a8" name="ac3d63fce05b0352af53d391871b6f5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d63fce05b0352af53d391871b6f5a8">&#9670;&nbsp;</a></span>reactions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structrrllvm_1_1LLVMModelSymbols_1_1ReactionSymbols.html">ReactionSymbols</a>&gt; rrllvm::LLVMModelSymbols::reactions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>these are indexed by reaction index. </p>
<p >the stoichiometry matrix is a N species x N reaction matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>llvm/<a class="el" href="LLVMModelSymbols_8h_source.html">LLVMModelSymbols.h</a></li>
<li>llvm/LLVMModelSymbols.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
