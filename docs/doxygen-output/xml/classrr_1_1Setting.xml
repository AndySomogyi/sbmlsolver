<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classrr_1_1Setting" kind="class" language="C++" prot="public">
    <compoundname>rr::Setting</compoundname>
    <includes refid="Setting_8h" local="no">Setting.h</includes>
      <sectiondef kind="public-type">
      <memberdef kind="enum" id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40" prot="public" static="no" strong="no">
        <type></type>
        <name>TypeId</name>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a8bec612d048217db0cea10fea5a23076" prot="public">
          <name>EMPTY</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a03855a1cff62b6b572b1e19e6004f85d" prot="public">
          <name>STRING</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a11844ec161871ca0e925169745e701ac" prot="public">
          <name>BOOL</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a28f0f8b78dff8e83397475b648821e48" prot="public">
          <name>INT32</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a8b0928141e8a776994aaf39a3156c2b6" prot="public">
          <name>UINT32</name>
          <initializer>= 4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a7a8edb7e6c60b983cd857d10b046c819" prot="public">
          <name>INT64</name>
          <initializer>= 5</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40af4cf765a2e944d51e75aa7a01075bc63" prot="public">
          <name>UINT64</name>
          <initializer>= 6</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a41ac399df0179cb4b1eea21c45f6fca4" prot="public">
          <name>FLOAT</name>
          <initializer>= 7</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a7bb8d0caf7028003b5a58440846733a1" prot="public">
          <name>DOUBLE</name>
          <initializer>= 8</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40aa335b652c80ae1c67db1b681371dab91" prot="public">
          <name>CHAR</name>
          <initializer>= 9</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a8eb14432429fa7917b3c0e5343ee5711" prot="public">
          <name>UCHAR</name>
          <initializer>= 10</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a073a134dc3228be068a0367a45a78fdc" prot="public">
          <name>DOUBLEVECTOR</name>
          <initializer>= 11</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>types that correspond to the index of the position of the type in the variant template. </para>
        </briefdescription>
        <detaileddescription>
<para>i.e. std::string is index 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="132" column="9" bodyfile="Setting.h" bodystart="132" bodyend="145"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classrr_1_1Setting_1a9ca4e1518db200636fc293ed727126ea" prot="private" static="no" mutable="no">
        <type>setting_t</type>
        <definition>setting_t rr::Setting::value_</definition>
        <argsstring></argsstring>
        <name>value_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="553" column="19" bodyfile="Setting.h" bodystart="553" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classrr_1_1Setting_1a4ca419f9b706d09cef6d90991e194fee" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>rr::Setting::Setting</definition>
        <argsstring>(setting_t value)</argsstring>
        <name>Setting</name>
        <param>
          <type>setting_t</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>constructor to take any type accepted by setting_t and store as a variant. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="86" column="18" bodyfile="Setting.cpp" bodystart="19" bodyend="20"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1ace675cf68c9885e451535578e3c2eff9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>rr::Setting::Setting</definition>
        <argsstring>(T settingValue)</argsstring>
        <name>Setting</name>
        <param>
          <type>T</type>
          <declname>settingValue</declname>
        </param>
        <briefdescription>
<para>constructor for creating a <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> from a supperted type T. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para>setting_t for supported types</para>
</simplesect>
for developers: clang-tidy will want you to make this constructor explicit. However, we intentionally keep implicit to allow type casting from type T to <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="98" column="9" bodyfile="Setting.h" bodystart="98" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a9fe62fdd022c03a9542db4cca43aa6a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>rr::Setting::Setting</definition>
        <argsstring>(const char *settingValue)</argsstring>
        <name>Setting</name>
        <param>
          <type>const char *</type>
          <declname>settingValue</declname>
        </param>
        <briefdescription>
<para>constructor for enabling creation of a <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> from a string literal. </para>
        </briefdescription>
        <detaileddescription>
<para>The literal gets converted into a std::string <programlisting><codeline><highlight class="normal">Setting<sp/>s(&quot;a<sp/>string&quot;);<sp/>//interpreted<sp/>as<sp/>string,<sp/>not<sp/>const<sp/>char*</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="109" column="9" bodyfile="Setting.cpp" bodystart="13" bodyend="14"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a2f608e0145800200b7795eea56a93cd5" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>rr::Setting::Setting</definition>
        <argsstring>(std::int64_t settingValue)</argsstring>
        <name>Setting</name>
        <param>
          <type>std::int64_t</type>
          <declname>settingValue</declname>
        </param>
        <briefdescription>
<para>construct from a long. </para>
        </briefdescription>
        <detaileddescription>
<para>(std::int64_t is a long long, which matters on windows) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="116" column="18" bodyfile="Setting.cpp" bodystart="16" bodyend="17"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a2f3f6beff36ad237ca6493dfaa19741f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>rr::Setting::Setting</definition>
        <argsstring>()=default</argsstring>
        <name>Setting</name>
        <briefdescription>
<para>default constructor. </para>
        </briefdescription>
        <detaileddescription>
<para>Allows instantiating of an empty setting. The empty setting will have a type of std::monostate, which is index 0 in setting_t </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="125" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a479708abc63de00aca3d56b7e28bee04" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40" kindref="member">TypeId</ref></type>
        <definition>Setting::TypeId rr::Setting::type</definition>
        <argsstring>() const</argsstring>
        <name>type</name>
        <briefdescription>
<para>returns the type of std::variant contained within this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>an integer which refers to the index of the type contained in this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. The index is resolved by looking at the TypeId enum (or indeed the ordering of the type parameters to setting_t. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="155" column="16" bodyfile="Setting.cpp" bodystart="22" bodyend="24"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1ab0b42145e5c0dab9a86a5faa790f1d7f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool rr::Setting::isType</definition>
        <argsstring>()</argsstring>
        <name>isType</name>
        <briefdescription>
<para>determines whether the current value of <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> is of type T. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true is <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> is of type T </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="163" column="14" bodyfile="Setting.h" bodystart="163" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a44ebea12f30b1b3e84bf2ebd35c18d06" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* rr::Setting::get_if</definition>
        <argsstring>()</argsstring>
        <name>get_if</name>
        <briefdescription>
<para>get the value of this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> as type T if the value in this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> is of type T. </para>
        </briefdescription>
        <detaileddescription>
<para>wrapper around std::get_if </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="183" column="11" bodyfile="Setting.h" bodystart="183" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a7b66c72a2cf9b9215733f554b6cd466e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class SettingType</type>
          </param>
        </templateparamlist>
        <type>SettingType</type>
        <definition>SettingType rr::Setting::get</definition>
        <argsstring>()</argsstring>
        <name>get</name>
        <briefdescription>
<para>return the value held by this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> as a type SettingType. </para>
        </briefdescription>
        <detaileddescription>
<para>simple wrapper around std::get. <simplesect kind="note"><para>for developers. This is a replacement for <ref refid="classrr_1_1Variant_1a7bb371be936601754f61d5285f834352" kindref="member">rr::Variant::convert</ref> in legacy roadrunner. The name &quot;get&quot; is preferred to &quot;convert&quot; since it follows C++ standard conventions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="197" column="21" bodyfile="Setting.h" bodystart="197" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1ab029a70cdac39e82fba2a7857de00679" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class As</type>
          </param>
        </templateparamlist>
        <type>As</type>
        <definition>As rr::Setting::getAs</definition>
        <argsstring>() const</argsstring>
        <name>getAs</name>
        <briefdescription>
<para>explicitly convert this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> to type As. </para>
        </briefdescription>
        <detaileddescription>
<para>type contained by this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> must be readily convertible to type As and throws std::invalid_argument if not. <programlisting><codeline><highlight class="normal">Setting<sp/>setting(5);</highlight></codeline>
<codeline><highlight class="normal">ASSERT_EQ(setting.get&lt;int&gt;(),<sp/>5);<sp/>//<sp/>fails<sp/>if<sp/>setting<sp/>is<sp/>not<sp/>int</highlight></codeline>
<codeline><highlight class="normal">ASSERT_THROW(setting.get&lt;unsigned<sp/>int&gt;();,<sp/>std::bad_variant_access);<sp/>//<sp/>bad,<sp/>setting<sp/>contains<sp/>an<sp/>int</highlight></codeline>
<codeline><highlight class="normal">ASSERT_EQ(setting.getAs&lt;unsigned<sp/>int&gt;(),<sp/>5);<sp/>//<sp/>Okay,<sp/>we<sp/>can<sp/>convert<sp/>from<sp/>int<sp/>to<sp/>unsigned<sp/>(when<sp/>int<sp/>&gt;<sp/>0)</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="213" column="12" bodyfile="Setting.h" bodystart="213" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1afc84a4c084c67e19d37327aa6ebfa61c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class SettingType</type>
          </param>
        </templateparamlist>
        <type>SettingType</type>
        <definition>SettingType rr::Setting::get</definition>
        <argsstring>() const</argsstring>
        <name>get</name>
        <briefdescription>
<para>return the value held by this setting as type SettingType. </para>
        </briefdescription>
        <detaileddescription>
<para>const version of SettingType::get() <simplesect kind="see"><para>SettingType::get() </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="275" column="21" bodyfile="Setting.h" bodystart="275" bodyend="277"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1aa76e883343a714ee58ee6025ebd0fefa" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>rr::Setting::operator T</definition>
        <argsstring>() const</argsstring>
        <name>operator T</name>
        <briefdescription>
<para>implicit type conversion support for the <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> class. </para>
        </briefdescription>
        <detaileddescription>
<para>this method is responsible for enabling implicit conversion between <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> and its supported types. Moreover, it enables one to implicitly convert (say) a int to a long, in contexts that make sense (as determined by std::is_convertible_v). Some situations are explicitly prohibited from implicit type conversion. These include<itemizedlist>
<listitem><para>converting a negative int or long to unsigned int or long</para>
</listitem><listitem><para>converting a long that has a value &gt; the largest possible value for int to int <simplesect kind="note"><para>for developers: clang-tidy will ask you to make this explicit, but this method <emphasis>must</emphasis> not be explicit since its entire purpose is implicit type conversion. </para>
</simplesect>
<simplesect kind="note"><para>for developers: Any additions to types stored in a setting_t <emphasis>must</emphasis> have appropriate unit tests added for the new types in SettingTests.cpp. </para>
</simplesect>
</para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="297" column="9" bodyfile="Setting.h" bodystart="297" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1aa72b6486d1e76a711eeebaef6c806f70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>rr::Setting::operator std::vector&lt; double &gt;</definition>
        <argsstring>()</argsstring>
        <name>operator std::vector&lt; double &gt;</name>
        <briefdescription>
<para>implicit cast this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> to a std::vector&lt;double&gt;. </para>
        </briefdescription>
        <detaileddescription>
<para>If this operator is used and the type contained by this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> is not a double vector, an std::invalid_argument error is thrown.</para>
<para>the generic operator T() method does not cover the case when we have a vector of doubles, so we must implement this manually. We could write another template for the more general case, but only support for std::vector&lt;double&gt; is needed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="323" column="9" bodyfile="Setting.h" bodystart="323" bodyend="331"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1ac2a86d3d0bd3a722a37f26d6afeef5a2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Func</type>
          </param>
        </templateparamlist>
        <type>decltype(auto)</type>
        <definition>decltype(auto) rr::Setting::visit</definition>
        <argsstring>(Func function) const</argsstring>
        <name>visit</name>
        <param>
          <type>Func</type>
          <declname>function</declname>
        </param>
        <briefdescription>
<para>equality operator for comparing object otherSetting of type T against the <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> contained within this Setting.value_. </para>
        </briefdescription>
        <detaileddescription>
<para>Enables the following types of comparisons <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Setting<sp/>s1(&quot;string&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>s2<sp/>=<sp/>&quot;string&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>s1<sp/>==<sp/>s2;<sp/>//<sp/>true</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Setting<sp/>s3(1234);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>s4<sp/>=<sp/>1234;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>s3<sp/>==<sp/>s4;<sp/>//<sp/>true</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>@details<sp/>Implemented<sp/>using<sp/>SFINAE<sp/>-<sp/>substitute<sp/>failure<sp/>is<sp/>not<sp/>an<sp/>error.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>The<sp/>seconds<sp/>template<sp/>argument<sp/>is<sp/>only<sp/>true<sp/>when<sp/>type<sp/>T<sp/>is<sp/>a<sp/>valid<sp/>variant</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>and<sp/>when<sp/>this<sp/>argument<sp/>evaluates<sp/>to<sp/>false,<sp/>the<sp/>compiler<sp/>will<sp/>not<sp/>generate</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>a<sp/>code<sp/>for<sp/>the<sp/>template<sp/>types.<sp/>Thus,<sp/>this<sp/>template<sp/>is<sp/>only<sp/>defined<sp/>for</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>types<sp/>that<sp/>are<sp/>a<sp/>part<sp/>of<sp/>setting_t.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T,<sp/>class<sp/>=<sp/>typename<sp/>std::enable_if&lt;isValidVariantType&lt;T,<sp/>setting_t&gt;::value&gt;::type&gt;</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>operator==(const<sp/>T<sp/>&amp;otherSetting)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(auto<sp/>settingValue<sp/>=<sp/>get_if&lt;T&gt;())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*settingValue<sp/>==<sp/>otherSetting;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>Inequality<sp/>operator,<sp/>counter<sp/>part<sp/>to<sp/>equality<sp/>operator</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@see<sp/>operator==(const<sp/>T&amp;otherSetting);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>=<sp/>typename<sp/>std::enable_if&lt;isValidVariantType&lt;T,<sp/>setting_t&gt;::value&gt;::type&gt;</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>operator!=(const<sp/>T<sp/>&amp;setting)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>!(*this<sp/>==<sp/>setting);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>Equality<sp/>operator,<sp/>enabling<sp/>the<sp/>comparison</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>of<sp/>this<sp/>Setting<sp/>with<sp/>the<sp/>other<sp/>Setting</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>operator==(const<sp/>Setting<sp/>&amp;setting);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>Equality<sp/>operator,<sp/>enabling<sp/>the<sp/>comparison</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>of<sp/>this<sp/>Setting<sp/>with<sp/>string<sp/>literals</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@details<sp/>since<sp/>our<sp/>Setting<sp/>does<sp/>not<sp/>store</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>const<sp/>char*,<sp/>the<sp/>main<sp/>templated<sp/>`operated==(const<sp/>T&amp;)`</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>is<sp/>not<sp/>used.<sp/>We<sp/>therefore<sp/>define<sp/>this<sp/>separately</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>operator==(const<sp/>char<sp/>*setting);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>Equality<sp/>operator,<sp/>enabling<sp/>the<sp/>comparison</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>of<sp/>this<sp/>Setting<sp/>with<sp/>string<sp/>literals</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@details<sp/>since<sp/>our<sp/>Setting<sp/>does<sp/>not<sp/>store</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>const<sp/>char*,<sp/>the<sp/>main<sp/>templated<sp/>`operated==(const<sp/>T&amp;)`</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>is<sp/>not<sp/>used.<sp/>We<sp/>therefore<sp/>define<sp/>this<sp/>separately.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>operator!=(const<sp/>char<sp/>*setting);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>Inequality<sp/>operator,<sp/>enabling<sp/>the<sp/>comparison</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>of<sp/>this<sp/>Setting<sp/>with<sp/>the<sp/>other<sp/>Setting</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>operator!=(const<sp/>Setting<sp/>&amp;setting);</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>assignment<sp/>operator<sp/>for<sp/>objects<sp/>that<sp/>are<sp/>not</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>a<sp/>setting.<sp/>T<sp/>must<sp/>be<sp/>a<sp/>member<sp/>of<sp/>setting_t<sp/>or<sp/>this</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>template<sp/>will<sp/>fail<sp/>without<sp/>error<sp/>(SFINAE)</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T,<sp/>class<sp/>=<sp/>typename<sp/>std::enable_if&lt;isValidVariantType&lt;T,<sp/>setting_t&gt;::value&gt;::type&gt;</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>&amp;operator=(const<sp/>T<sp/>&amp;setting)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>checkValidType&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>no<sp/>need<sp/>to<sp/>check<sp/>self<sp/>assignment<sp/>with<sp/>variant</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>value_<sp/>=<sp/>setting_t(setting);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>move<sp/>assignment<sp/>operator</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>for<sp/>types<sp/>T<sp/>that<sp/>are<sp/>members<sp/>of<sp/>setting_t.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@see<sp/>setting_t</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>T,<sp/>class<sp/>=<sp/>typename<sp/>std::enable_if&lt;isValidVariantType&lt;T,<sp/>setting_t&gt;::value&gt;::type&gt;</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>&amp;operator=(T<sp/>&amp;&amp;setting)<sp/>noexcept<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>checkValidType&lt;T&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>no<sp/>need<sp/>to<sp/>check<sp/>self<sp/>assignment<sp/>with<sp/>variant</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>value_<sp/>=<sp/>std::move(setting_t(setting));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@brief<sp/>wrapper<sp/>around<sp/>std::visitor<sp/>for</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>&quot;visiting&quot;<sp/>each<sp/>of<sp/>the<sp/>possible<sp/>types<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>the<sp/>setting_t.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@details<sp/>instead<sp/>of<sp/>using<sp/>an<sp/>if-else<sp/>block</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>you<sp/>can<sp/>use<sp/>a<sp/>visitor.<sp/>For<sp/>instance,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@param<sp/>function:<sp/>callable<sp/>type,<sp/>such<sp/>as<sp/>lambda<sp/>expression.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@code</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>Setting<sp/>s(1234);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>std::string<sp/>typeString;</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>s.visit([&amp;](auto<sp/>t)<sp/>-&gt;<sp/>decltype(auto){typeString<sp/>=<sp/>typeid(t).name();});</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>typeString<sp/>&lt;&lt;<sp/>std::endl;<sp/>//<sp/>prints<sp/>out<sp/>&quot;int&quot;<sp/>to<sp/>console</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/></highlight></codeline>
</programlisting> <simplesect kind="see"><para>docs on std::visit </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="444" column="18" bodyfile="Setting.h" bodystart="444" bodyend="446"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a66c1f37c3e43dd1850e4a4dd1e96b305" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::type_info &amp;</type>
        <definition>const std::type_info &amp; rr::Setting::typeInfo</definition>
        <argsstring>() const</argsstring>
        <name>typeInfo</name>
        <briefdescription>
<para>returns the std::type_info for the object type contained within this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>(aka one of the types within setting_t) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="453" column="30" bodyfile="Setting.cpp" bodystart="139" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1adcf3783161d25aa1082673116eb44df0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> &amp;</type>
        <definition>Setting &amp; rr::Setting::operator=</definition>
        <argsstring>(const Setting &amp;setting)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> &amp;</type>
          <declname>setting</declname>
        </param>
        <briefdescription>
<para>move assignment operator for when rhs is a <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para>operator=(const T&amp;setting); </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="461" column="17" bodyfile="Setting.cpp" bodystart="119" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a732b55592cf2f1ce8a12135b2c147420" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> &amp;</type>
        <definition>Setting &amp; rr::Setting::operator=</definition>
        <argsstring>(Setting &amp;&amp;setting) noexcept</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> &amp;&amp;</type>
          <declname>setting</declname>
        </param>
        <briefdescription>
<para>Move assignment operator for <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> with another <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="467" column="17" bodyfile="Setting.cpp" bodystart="126" bodyend="131"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1aff50ac7ee57ce021f05b336d3d4c0137" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>rr::Setting::Setting</definition>
        <argsstring>(const Setting &amp;setting)</argsstring>
        <name>Setting</name>
        <param>
          <type>const <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> &amp;</type>
          <declname>setting</declname>
        </param>
        <briefdescription>
<para>Copy constructor for <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> with another <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="473" column="9" bodyfile="Setting.cpp" bodystart="133" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1aac6b0ac9f9de9746d65dcd5dc2d116c9" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>rr::Setting::Setting</definition>
        <argsstring>(Setting &amp;&amp;setting) noexcept</argsstring>
        <name>Setting</name>
        <param>
          <type><ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> &amp;&amp;</type>
          <declname>setting</declname>
        </param>
        <briefdescription>
<para>Move constructor for <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> with another <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="479" column="9" bodyfile="Setting.cpp" bodystart="136" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a861cc76edbf64525ccf1c1f5c6e7a553" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const setting_t &amp;</type>
        <definition>const setting_t &amp; rr::Setting::getValue</definition>
        <argsstring>() const</argsstring>
        <name>getValue</name>
        <briefdescription>
<para>getter for the std::variant_t underlying this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="485" column="26" bodyfile="Setting.cpp" bodystart="71" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1aca92fd79b60e0dfbf9b3f14893b766b6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string rr::Setting::pythonRepr</definition>
        <argsstring>() const</argsstring>
        <name>pythonRepr</name>
        <briefdescription>
<para>Convert to Python-compatible representation. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="author"><para>JKM </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="491" column="22" bodyfile="Setting.cpp" bodystart="58" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a499f1510451d2871797bfc3d26c18f1d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isString</definition>
        <argsstring>() const</argsstring>
        <name>isString</name>
        <briefdescription>
<para>is this variant a std::string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="496" column="15" bodyfile="Setting.cpp" bodystart="26" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1adc2f542b2952e6280399a1f89736341f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isInteger</definition>
        <argsstring>() const</argsstring>
        <name>isInteger</name>
        <briefdescription>
<para>was an integer stored here. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="501" column="15" bodyfile="Setting.cpp" bodystart="30" bodyend="32"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1ac60624a988dc8231d26ad87850cbb3a3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isNumeric</definition>
        <argsstring>() const</argsstring>
        <name>isNumeric</name>
        <briefdescription>
<para>is this a numeric type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="506" column="15" bodyfile="Setting.cpp" bodystart="34" bodyend="36"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1af69a91585985c14cff53b770d559eddd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isBool</definition>
        <argsstring>() const</argsstring>
        <name>isBool</name>
        <briefdescription>
<para>is this a boolean type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="511" column="15" bodyfile="Setting.cpp" bodystart="38" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a6325294c5a5961ea2425b63898552aba" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isEmpty</definition>
        <argsstring>() const</argsstring>
        <name>isEmpty</name>
        <briefdescription>
<para>true if empty. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="516" column="14" bodyfile="Setting.cpp" bodystart="42" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1ac88fb6abc4e46931b13a7d8501821356" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isSigned</definition>
        <argsstring>() const</argsstring>
        <name>isSigned</name>
        <briefdescription>
<para>true if this is a signed number. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="521" column="14" bodyfile="Setting.cpp" bodystart="46" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a3fcde472a8b1e12715fc87ff59d30563" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isDoubleVector</definition>
        <argsstring>() const</argsstring>
        <name>isDoubleVector</name>
        <briefdescription>
<para>true if this is a std::vector of doubles </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="526" column="14" bodyfile="Setting.cpp" bodystart="50" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a602da5dcede622d5912669b7a66ddb54" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool rr::Setting::isDouble</definition>
        <argsstring>() const</argsstring>
        <name>isDouble</name>
        <briefdescription>
<para>true if this is a double </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="531" column="14" bodyfile="Setting.cpp" bodystart="54" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1a1ee105bd7e3f37b7109004f9fa056e78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string rr::Setting::toString</definition>
        <argsstring>()</argsstring>
        <name>toString</name>
        <briefdescription>
<para>gets a string representation of the type stored in this <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="549" column="21" bodyfile="Setting.cpp" bodystart="161" bodyend="195"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classrr_1_1Setting_1ab97b3a831c1ee98cb591c146cff9d52b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>static bool rr::Setting::isValidType</definition>
        <argsstring>()</argsstring>
        <name>isValidType</name>
        <briefdescription>
<para>test for membership of type T in setting_t, aka supported types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="172" column="21" bodyfile="Setting.h" bodystart="172" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="classrr_1_1Setting_1ad62b4bb5f092aa767644bf7b59a41f66" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classrr_1_1Setting" kindref="compound">Setting</ref></type>
        <definition>Setting rr::Setting::parse</definition>
        <argsstring>(std::string &amp;val)</argsstring>
        <name>parse</name>
        <param>
          <type>std::string &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Parses the std::string which must be in JSON format. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a common way to read a <ref refid="classrr_1_1Variant" kindref="compound">Variant</ref> from a file or create a new one from a std::string: <programlisting><codeline><highlight class="normal">Variant<sp/>v<sp/>=<sp/>Variant::parse(&quot;0.123&quot;);</highlight></codeline>
</programlisting> <simplesect kind="note"><para>this function is a tangent to the main <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref> class. We should instead have a JSON parser, is that&apos;s the function we need. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="543" column="24" bodyfile="Setting.cpp" bodystart="75" bodyend="117"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classrr_1_1Setting_1a96fa28ef5389d3cfddd0f170b62660f6" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void rr::Setting::checkValidType</definition>
        <argsstring>()</argsstring>
        <name>checkValidType</name>
        <briefdescription>
<para>throws std::invalid_argument if type T is not supported by <ref refid="classrr_1_1Setting" kindref="compound">Setting</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para>setting_t </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Setting.h" line="562" column="14" bodyfile="Setting.h" bodystart="562" bodyend="569"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Store a roadrunner option (or setting) as a <ref refid="classrr_1_1Variant" kindref="compound">Variant</ref> type. </para>
    </briefdescription>
    <detaileddescription>
<para>Uses a std::variant to hold one of the following types , std::monostate, std::string, bool, std::int32_t, std::uint32_t, std::int64_t, std::uint64_t, float, double, char, unsigned char, std::vector&lt;double&gt; <simplesect kind="note"><para>for developers: order of the std::variant template specialization is important. Make sure the order always matches the other of the <ref refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40" kindref="member">Setting::TypeId</ref> enum. </para>
</simplesect>
<simplesect kind="note"><para>The function of this class used to be performed by <ref refid="classrr_1_1Variant" kindref="compound">rr::Variant</ref>. Since C++17 we have replaced this with a standard type.</para>
</simplesect>
<programlisting><codeline><highlight class="normal">//<sp/>implicit<sp/>type<sp/>conversions</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting(4);<sp/>//<sp/>is<sp/>an<sp/>int</highlight></codeline>
<codeline><highlight class="normal">int<sp/>s<sp/>=<sp/>setting.get&lt;int&gt;();<sp/>//<sp/>okay</highlight></codeline>
<codeline><highlight class="normal">int<sp/>t<sp/>=<sp/>setting.get&lt;std::string&gt;();<sp/>//<sp/>not<sp/>okay,<sp/>setting<sp/>contains<sp/>an<sp/>int</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>u<sp/>=<sp/>setting.get_if&lt;int&gt;();<sp/>//<sp/>u<sp/>is<sp/>pointer<sp/>to<sp/>int<sp/>if<sp/>setting<sp/>is<sp/>int<sp/>else<sp/>nullptr</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(auto<sp/>v<sp/>=<sp/>setting.get_if&lt;int&gt;()){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>do<sp/>something<sp/>in<sp/>context<sp/>where<sp/>`setting`<sp/>is<sp/>int</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting2(-4);<sp/>//<sp/>contains<sp/>an<sp/>int<sp/>with<sp/>negative<sp/>value</highlight></codeline>
<codeline><highlight class="normal">int<sp/>q<sp/>=<sp/>setting2;<sp/>//<sp/>okay</highlight></codeline>
<codeline><highlight class="normal">long<sp/>r<sp/>=<sp/>setting2;<sp/>//<sp/>okay</highlight></codeline>
<codeline><highlight class="normal">unsigned<sp/>int<sp/>w<sp/>=<sp/>setting2;<sp/>//<sp/>error,<sp/>setting2<sp/>contains<sp/>negative<sp/>value</highlight></codeline>
<codeline><highlight class="normal">unsigned<sp/>long<sp/>x<sp/>=<sp/>setting2;<sp/>//<sp/>error,<sp/>setting2<sp/>contains<sp/>negative<sp/>value</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">long<sp/>biggest_int<sp/>=<sp/>std::numeric_limits&lt;int&gt;::max();</highlight></codeline>
<codeline><highlight class="normal">long<sp/>out_of_range<sp/>=<sp/>biggest_int<sp/>*<sp/>10;</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting(out_of_range);</highlight></codeline>
<codeline><highlight class="normal">int<sp/>x<sp/>=<sp/>setting;<sp/>//<sp/>error,<sp/>int<sp/>isn&apos;t<sp/>big<sp/>enough<sp/>to<sp/>hold<sp/>`out_out_range`</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>equality<sp/>works<sp/>as<sp/>expected</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting3(std::int64_t(12345678912345));</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting4(std::int64_t(12345678912345));</highlight></codeline>
<codeline><highlight class="normal">ASSERT_TRUE(setting3<sp/>==<sp/>setting4);<sp/>//<sp/>pass</highlight></codeline>
<codeline><highlight class="normal">ASSERT_TRUE(setting3<sp/>==<sp/>12345678912345);<sp/>//<sp/>also<sp/>okay</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>reassign<sp/>a<sp/>setting<sp/>to<sp/>different<sp/>type</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting5(123);</highlight></codeline>
<codeline><highlight class="normal">setting5<sp/>=<sp/>&quot;Now<sp/>a<sp/>string&quot;;<sp/>//<sp/>okay</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>expected<sp/>=<sp/>&quot;Now<sp/>a<sp/>string&quot;;</highlight></codeline>
<codeline><highlight class="normal">ASSERT_TRUE(setting5<sp/>==<sp/>expected);<sp/>//<sp/>pass</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>instantiating<sp/>a<sp/>setting<sp/>from<sp/>other<sp/>objects</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>st<sp/>=<sp/>&quot;A<sp/>String&quot;;</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting6(st);<sp/>//okay</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting7<sp/>=<sp/>st<sp/>;<sp/>//<sp/>not<sp/>okay</highlight></codeline>
<codeline><highlight class="normal">Setting<sp/>setting8<sp/>=<sp/>&quot;A<sp/>string&quot;;<sp/>//<sp/>not<sp/>okay</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>check<sp/>if<sp/>Setting<sp/>supports<sp/>a<sp/>type</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>supported<sp/>=<sp/>Setting::isValidType&lt;int&gt;();<sp/>//<sp/>true</highlight></codeline>
<codeline><highlight class="normal">supported<sp/>=<sp/>Setting::isValidType&lt;std::string&gt;();<sp/>//<sp/>true</highlight></codeline>
<codeline><highlight class="normal">supported<sp/>=<sp/>Setting::isValidType&lt;const<sp/>char*&gt;();<sp/>//<sp/>false</highlight></codeline>
</programlisting> </para>
    </detaileddescription>
    <location file="Setting.h" line="78" column="5" bodyfile="Setting.h" bodystart="78" bodyend="570"/>
    <listofallmembers>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a11844ec161871ca0e925169745e701ac" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>BOOL</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40aa335b652c80ae1c67db1b681371dab91" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>CHAR</name></member>
      <member refid="classrr_1_1Setting_1a96fa28ef5389d3cfddd0f170b62660f6" prot="private" virt="non-virtual"><scope>rr::Setting</scope><name>checkValidType</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a7bb8d0caf7028003b5a58440846733a1" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>DOUBLE</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a073a134dc3228be068a0367a45a78fdc" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>DOUBLEVECTOR</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a8bec612d048217db0cea10fea5a23076" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>EMPTY</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a41ac399df0179cb4b1eea21c45f6fca4" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>FLOAT</name></member>
      <member refid="classrr_1_1Setting_1a7b66c72a2cf9b9215733f554b6cd466e" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>get</name></member>
      <member refid="classrr_1_1Setting_1afc84a4c084c67e19d37327aa6ebfa61c" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>get</name></member>
      <member refid="classrr_1_1Setting_1a44ebea12f30b1b3e84bf2ebd35c18d06" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>get_if</name></member>
      <member refid="classrr_1_1Setting_1ab029a70cdac39e82fba2a7857de00679" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>getAs</name></member>
      <member refid="classrr_1_1Setting_1a861cc76edbf64525ccf1c1f5c6e7a553" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>getValue</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a28f0f8b78dff8e83397475b648821e48" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>INT32</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a7a8edb7e6c60b983cd857d10b046c819" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>INT64</name></member>
      <member refid="classrr_1_1Setting_1af69a91585985c14cff53b770d559eddd" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isBool</name></member>
      <member refid="classrr_1_1Setting_1a602da5dcede622d5912669b7a66ddb54" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isDouble</name></member>
      <member refid="classrr_1_1Setting_1a3fcde472a8b1e12715fc87ff59d30563" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isDoubleVector</name></member>
      <member refid="classrr_1_1Setting_1a6325294c5a5961ea2425b63898552aba" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isEmpty</name></member>
      <member refid="classrr_1_1Setting_1adc2f542b2952e6280399a1f89736341f" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isInteger</name></member>
      <member refid="classrr_1_1Setting_1ac60624a988dc8231d26ad87850cbb3a3" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isNumeric</name></member>
      <member refid="classrr_1_1Setting_1ac88fb6abc4e46931b13a7d8501821356" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isSigned</name></member>
      <member refid="classrr_1_1Setting_1a499f1510451d2871797bfc3d26c18f1d" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isString</name></member>
      <member refid="classrr_1_1Setting_1ab0b42145e5c0dab9a86a5faa790f1d7f" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isType</name></member>
      <member refid="classrr_1_1Setting_1ab97b3a831c1ee98cb591c146cff9d52b" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>isValidType</name></member>
      <member refid="classrr_1_1Setting_1aa72b6486d1e76a711eeebaef6c806f70" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>operator std::vector&lt; double &gt;</name></member>
      <member refid="classrr_1_1Setting_1aa76e883343a714ee58ee6025ebd0fefa" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>operator T</name></member>
      <member refid="classrr_1_1Setting_1adcf3783161d25aa1082673116eb44df0" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>operator=</name></member>
      <member refid="classrr_1_1Setting_1a732b55592cf2f1ce8a12135b2c147420" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>operator=</name></member>
      <member refid="classrr_1_1Setting_1ad62b4bb5f092aa767644bf7b59a41f66" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>parse</name></member>
      <member refid="classrr_1_1Setting_1aca92fd79b60e0dfbf9b3f14893b766b6" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>pythonRepr</name></member>
      <member refid="classrr_1_1Setting_1a4ca419f9b706d09cef6d90991e194fee" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>Setting</name></member>
      <member refid="classrr_1_1Setting_1ace675cf68c9885e451535578e3c2eff9" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>Setting</name></member>
      <member refid="classrr_1_1Setting_1a9fe62fdd022c03a9542db4cca43aa6a5" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>Setting</name></member>
      <member refid="classrr_1_1Setting_1a2f608e0145800200b7795eea56a93cd5" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>Setting</name></member>
      <member refid="classrr_1_1Setting_1a2f3f6beff36ad237ca6493dfaa19741f" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>Setting</name></member>
      <member refid="classrr_1_1Setting_1aff50ac7ee57ce021f05b336d3d4c0137" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>Setting</name></member>
      <member refid="classrr_1_1Setting_1aac6b0ac9f9de9746d65dcd5dc2d116c9" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>Setting</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a03855a1cff62b6b572b1e19e6004f85d" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>STRING</name></member>
      <member refid="classrr_1_1Setting_1a1ee105bd7e3f37b7109004f9fa056e78" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>toString</name></member>
      <member refid="classrr_1_1Setting_1a479708abc63de00aca3d56b7e28bee04" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>type</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>TypeId</name></member>
      <member refid="classrr_1_1Setting_1a66c1f37c3e43dd1850e4a4dd1e96b305" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>typeInfo</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a8eb14432429fa7917b3c0e5343ee5711" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>UCHAR</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40a8b0928141e8a776994aaf39a3156c2b6" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>UINT32</name></member>
      <member refid="classrr_1_1Setting_1af49342a0fabdeeafe649246089a72b40af4cf765a2e944d51e75aa7a01075bc63" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>UINT64</name></member>
      <member refid="classrr_1_1Setting_1a9ca4e1518db200636fc293ed727126ea" prot="private" virt="non-virtual"><scope>rr::Setting</scope><name>value_</name></member>
      <member refid="classrr_1_1Setting_1ac2a86d3d0bd3a722a37f26d6afeef5a2" prot="public" virt="non-virtual"><scope>rr::Setting</scope><name>visit</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
