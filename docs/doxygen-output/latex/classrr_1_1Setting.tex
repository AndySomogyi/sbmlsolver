\hypertarget{classrr_1_1Setting}{}\doxysection{rr\+::Setting Class Reference}
\label{classrr_1_1Setting}\index{rr::Setting@{rr::Setting}}


Store a roadrunner option (or setting) as a \mbox{\hyperlink{classrr_1_1Variant}{Variant}} type.  




{\ttfamily \#include $<$Setting.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{classrr_1_1Setting_af49342a0fabdeeafe649246089a72b40}{Type\+Id}} \{ \newline
{\bfseries EMPTY} = 0
, {\bfseries STRING} = 1
, {\bfseries BOOL} = 2
, {\bfseries INT32} = 3
, \newline
{\bfseries UINT32} = 4
, {\bfseries INT64} = 5
, {\bfseries UINT64} = 6
, {\bfseries FLOAT} = 7
, \newline
{\bfseries DOUBLE} = 8
, {\bfseries CHAR} = 9
, {\bfseries UCHAR} = 10
, {\bfseries DOUBLEVECTOR} = 11
 \}
\begin{DoxyCompactList}\small\item\em types that correspond to the index of the position of the type in the variant template. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classrr_1_1Setting_a4ca419f9b706d09cef6d90991e194fee}\label{classrr_1_1Setting_a4ca419f9b706d09cef6d90991e194fee}} 
\mbox{\hyperlink{classrr_1_1Setting_a4ca419f9b706d09cef6d90991e194fee}{Setting}} (setting\+\_\+t value)
\begin{DoxyCompactList}\small\item\em constructor to take any type accepted by setting\+\_\+t and store as a variant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\\mbox{\hyperlink{classrr_1_1Setting_ace675cf68c9885e451535578e3c2eff9}{Setting}} (T setting\+Value)
\begin{DoxyCompactList}\small\item\em constructor for creating a \mbox{\hyperlink{classrr_1_1Setting}{Setting}} from a supperted type T. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrr_1_1Setting_a9fe62fdd022c03a9542db4cca43aa6a5}{Setting}} (const char $\ast$setting\+Value)
\begin{DoxyCompactList}\small\item\em constructor for enabling creation of a \mbox{\hyperlink{classrr_1_1Setting}{Setting}} from a string literal. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrr_1_1Setting_a2f608e0145800200b7795eea56a93cd5}{Setting}} (std\+::int64\+\_\+t setting\+Value)
\begin{DoxyCompactList}\small\item\em construct from a long. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} ()=default
\begin{DoxyCompactList}\small\item\em default constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrr_1_1Setting_af49342a0fabdeeafe649246089a72b40}{Type\+Id}} \mbox{\hyperlink{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}{type}} () const
\begin{DoxyCompactList}\small\item\em returns the type of std\+::variant contained within this \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\bool \mbox{\hyperlink{classrr_1_1Setting_ab0b42145e5c0dab9a86a5faa790f1d7f}{is\+Type}} ()
\begin{DoxyCompactList}\small\item\em determines whether the current value of \mbox{\hyperlink{classrr_1_1Setting}{Setting}} is of type T. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\T $\ast$ \mbox{\hyperlink{classrr_1_1Setting_a44ebea12f30b1b3e84bf2ebd35c18d06}{get\+\_\+if}} ()
\begin{DoxyCompactList}\small\item\em get the value of this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} as type T if the value in this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} is of type T. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Setting\+Type $>$ }\\Setting\+Type \mbox{\hyperlink{classrr_1_1Setting_a7b66c72a2cf9b9215733f554b6cd466e}{get}} ()
\begin{DoxyCompactList}\small\item\em return the value held by this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} as a type Setting\+Type. \end{DoxyCompactList}\item 
{\footnotesize template$<$class As $>$ }\\As \mbox{\hyperlink{classrr_1_1Setting_ab029a70cdac39e82fba2a7857de00679}{get\+As}} () const
\begin{DoxyCompactList}\small\item\em explicitly convert this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} to type As. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Setting\+Type $>$ }\\Setting\+Type \mbox{\hyperlink{classrr_1_1Setting_afc84a4c084c67e19d37327aa6ebfa61c}{get}} () const
\begin{DoxyCompactList}\small\item\em return the value held by this setting as type Setting\+Type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\\mbox{\hyperlink{classrr_1_1Setting_aa76e883343a714ee58ee6025ebd0fefa}{operator T}} () const
\begin{DoxyCompactList}\small\item\em implicit type conversion support for the \mbox{\hyperlink{classrr_1_1Setting}{Setting}} class. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrr_1_1Setting_aa72b6486d1e76a711eeebaef6c806f70}{operator std\+::vector$<$ double $>$}} ()
\begin{DoxyCompactList}\small\item\em implicit cast this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} to a std\+::vector$<$double$>$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Func $>$ }\\decltype(auto) \mbox{\hyperlink{classrr_1_1Setting_ac2a86d3d0bd3a722a37f26d6afeef5a2}{visit}} (Func function) const
\begin{DoxyCompactList}\small\item\em equality operator for comparing object other\+Setting of type T against the \mbox{\hyperlink{classrr_1_1Setting}{Setting}} contained within this Setting.\+value\+\_\+. \end{DoxyCompactList}\item 
const std\+::type\+\_\+info \& \mbox{\hyperlink{classrr_1_1Setting_a66c1f37c3e43dd1850e4a4dd1e96b305}{type\+Info}} () const
\begin{DoxyCompactList}\small\item\em returns the std\+::type\+\_\+info for the object type contained within this \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrr_1_1Setting}{Setting}} \& \mbox{\hyperlink{classrr_1_1Setting_adcf3783161d25aa1082673116eb44df0}{operator=}} (const \mbox{\hyperlink{classrr_1_1Setting}{Setting}} \&setting)
\begin{DoxyCompactList}\small\item\em move assignment operator for when rhs is a \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_a732b55592cf2f1ce8a12135b2c147420}\label{classrr_1_1Setting_a732b55592cf2f1ce8a12135b2c147420}} 
\mbox{\hyperlink{classrr_1_1Setting}{Setting}} \& \mbox{\hyperlink{classrr_1_1Setting_a732b55592cf2f1ce8a12135b2c147420}{operator=}} (\mbox{\hyperlink{classrr_1_1Setting}{Setting}} \&\&setting) noexcept
\begin{DoxyCompactList}\small\item\em Move assignment operator for \mbox{\hyperlink{classrr_1_1Setting}{Setting}} with another \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_aff50ac7ee57ce021f05b336d3d4c0137}\label{classrr_1_1Setting_aff50ac7ee57ce021f05b336d3d4c0137}} 
\mbox{\hyperlink{classrr_1_1Setting_aff50ac7ee57ce021f05b336d3d4c0137}{Setting}} (const \mbox{\hyperlink{classrr_1_1Setting}{Setting}} \&setting)
\begin{DoxyCompactList}\small\item\em Copy constructor for \mbox{\hyperlink{classrr_1_1Setting}{Setting}} with another \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_aac6b0ac9f9de9746d65dcd5dc2d116c9}\label{classrr_1_1Setting_aac6b0ac9f9de9746d65dcd5dc2d116c9}} 
\mbox{\hyperlink{classrr_1_1Setting_aac6b0ac9f9de9746d65dcd5dc2d116c9}{Setting}} (\mbox{\hyperlink{classrr_1_1Setting}{Setting}} \&\&setting) noexcept
\begin{DoxyCompactList}\small\item\em Move constructor for \mbox{\hyperlink{classrr_1_1Setting}{Setting}} with another \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_a861cc76edbf64525ccf1c1f5c6e7a553}\label{classrr_1_1Setting_a861cc76edbf64525ccf1c1f5c6e7a553}} 
const setting\+\_\+t \& \mbox{\hyperlink{classrr_1_1Setting_a861cc76edbf64525ccf1c1f5c6e7a553}{get\+Value}} () const
\begin{DoxyCompactList}\small\item\em getter for the std\+::variant\+\_\+t underlying this \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classrr_1_1Setting_aca92fd79b60e0dfbf9b3f14893b766b6}{python\+Repr}} () const
\begin{DoxyCompactList}\small\item\em Convert to Python-\/compatible representation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_a499f1510451d2871797bfc3d26c18f1d}\label{classrr_1_1Setting_a499f1510451d2871797bfc3d26c18f1d}} 
bool \mbox{\hyperlink{classrr_1_1Setting_a499f1510451d2871797bfc3d26c18f1d}{is\+String}} () const
\begin{DoxyCompactList}\small\item\em is this variant a std\+::string. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_adc2f542b2952e6280399a1f89736341f}\label{classrr_1_1Setting_adc2f542b2952e6280399a1f89736341f}} 
bool \mbox{\hyperlink{classrr_1_1Setting_adc2f542b2952e6280399a1f89736341f}{is\+Integer}} () const
\begin{DoxyCompactList}\small\item\em was an integer stored here. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_ac60624a988dc8231d26ad87850cbb3a3}\label{classrr_1_1Setting_ac60624a988dc8231d26ad87850cbb3a3}} 
bool \mbox{\hyperlink{classrr_1_1Setting_ac60624a988dc8231d26ad87850cbb3a3}{is\+Numeric}} () const
\begin{DoxyCompactList}\small\item\em is this a numeric type. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_af69a91585985c14cff53b770d559eddd}\label{classrr_1_1Setting_af69a91585985c14cff53b770d559eddd}} 
bool \mbox{\hyperlink{classrr_1_1Setting_af69a91585985c14cff53b770d559eddd}{is\+Bool}} () const
\begin{DoxyCompactList}\small\item\em is this a boolean type. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_a6325294c5a5961ea2425b63898552aba}\label{classrr_1_1Setting_a6325294c5a5961ea2425b63898552aba}} 
bool \mbox{\hyperlink{classrr_1_1Setting_a6325294c5a5961ea2425b63898552aba}{is\+Empty}} () const
\begin{DoxyCompactList}\small\item\em true if empty. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_ac88fb6abc4e46931b13a7d8501821356}\label{classrr_1_1Setting_ac88fb6abc4e46931b13a7d8501821356}} 
bool \mbox{\hyperlink{classrr_1_1Setting_ac88fb6abc4e46931b13a7d8501821356}{is\+Signed}} () const
\begin{DoxyCompactList}\small\item\em true if this is a signed number. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_a3fcde472a8b1e12715fc87ff59d30563}\label{classrr_1_1Setting_a3fcde472a8b1e12715fc87ff59d30563}} 
bool \mbox{\hyperlink{classrr_1_1Setting_a3fcde472a8b1e12715fc87ff59d30563}{is\+Double\+Vector}} () const
\begin{DoxyCompactList}\small\item\em true if this is a std\+::vector of doubles \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_a602da5dcede622d5912669b7a66ddb54}\label{classrr_1_1Setting_a602da5dcede622d5912669b7a66ddb54}} 
bool \mbox{\hyperlink{classrr_1_1Setting_a602da5dcede622d5912669b7a66ddb54}{is\+Double}} () const
\begin{DoxyCompactList}\small\item\em true if this is a double \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Setting_a1ee105bd7e3f37b7109004f9fa056e78}\label{classrr_1_1Setting_a1ee105bd7e3f37b7109004f9fa056e78}} 
std\+::string \mbox{\hyperlink{classrr_1_1Setting_a1ee105bd7e3f37b7109004f9fa056e78}{to\+String}} ()
\begin{DoxyCompactList}\small\item\em gets a string representation of the type stored in this \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classrr_1_1Setting_ab97b3a831c1ee98cb591c146cff9d52b}\label{classrr_1_1Setting_ab97b3a831c1ee98cb591c146cff9d52b}} 
{\footnotesize template$<$class T $>$ }\\static bool \mbox{\hyperlink{classrr_1_1Setting_ab97b3a831c1ee98cb591c146cff9d52b}{is\+Valid\+Type}} ()
\begin{DoxyCompactList}\small\item\em test for membership of type T in setting\+\_\+t, aka supported types \end{DoxyCompactList}\item 
static \mbox{\hyperlink{classrr_1_1Setting}{Setting}} \mbox{\hyperlink{classrr_1_1Setting_ad62b4bb5f092aa767644bf7b59a41f66}{parse}} (std\+::string \&val)
\begin{DoxyCompactList}\small\item\em Parses the std\+::string which must be in JSON format. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Store a roadrunner option (or setting) as a \mbox{\hyperlink{classrr_1_1Variant}{Variant}} type. 

Uses a std\+::variant to hold one of the following types , std\+::monostate, std\+::string, bool, std\+::int32\+\_\+t, std\+::uint32\+\_\+t, std\+::int64\+\_\+t, std\+::uint64\+\_\+t, float, double, char, unsigned char, std\+::vector$<$double$>$ \begin{DoxyNote}{Note}
for developers\+: order of the std\+::variant template specialization is important. Make sure the order always matches the other of the \mbox{\hyperlink{classrr_1_1Setting_af49342a0fabdeeafe649246089a72b40}{Setting\+::\+Type\+Id}} enum. 

The function of this class used to be performed by \mbox{\hyperlink{classrr_1_1Variant}{rr\+::\+Variant}}. Since C++17 we have replaced this with a standard type.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// implicit type conversions}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting(4); \textcolor{comment}{// is an int}}
\DoxyCodeLine{\textcolor{keywordtype}{int} s = setting.get<\textcolor{keywordtype}{int}>(); \textcolor{comment}{// okay}}
\DoxyCodeLine{\textcolor{keywordtype}{int} t = setting.get<std::string>(); \textcolor{comment}{// not okay, setting contains an int}}
\DoxyCodeLine{\textcolor{keyword}{auto} u = setting.get\_if<\textcolor{keywordtype}{int}>(); \textcolor{comment}{// u is pointer to int if setting is int else nullptr}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (\textcolor{keyword}{auto} v = setting.get\_if<\textcolor{keywordtype}{int}>())\{}
\DoxyCodeLine{    \textcolor{comment}{// do something in context where `setting` is int}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting2(-\/4); \textcolor{comment}{// contains an int with negative value}}
\DoxyCodeLine{\textcolor{keywordtype}{int} q = setting2; \textcolor{comment}{// okay}}
\DoxyCodeLine{\textcolor{keywordtype}{long} r = setting2; \textcolor{comment}{// okay}}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w = setting2; \textcolor{comment}{// error, setting2 contains negative value}}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} x = setting2; \textcolor{comment}{// error, setting2 contains negative value}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{long} biggest\_int = std::numeric\_limits<int>::max();}
\DoxyCodeLine{\textcolor{keywordtype}{long} out\_of\_range = biggest\_int * 10;}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting(out\_of\_range);}
\DoxyCodeLine{\textcolor{keywordtype}{int} x = setting; \textcolor{comment}{// error, int isn't big enough to hold `out\_out\_range`}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// equality works as expected}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting3(std::int64\_t(12345678912345));}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting4(std::int64\_t(12345678912345));}
\DoxyCodeLine{ASSERT\_TRUE(setting3 == setting4); \textcolor{comment}{// pass}}
\DoxyCodeLine{ASSERT\_TRUE(setting3 == 12345678912345); \textcolor{comment}{// also okay}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// reassign a setting to different type}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting5(123);}
\DoxyCodeLine{setting5 = \textcolor{stringliteral}{"{}Now a string"{}}; \textcolor{comment}{// okay}}
\DoxyCodeLine{std::string expected = \textcolor{stringliteral}{"{}Now a string"{}};}
\DoxyCodeLine{ASSERT\_TRUE(setting5 == expected); \textcolor{comment}{// pass}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// instantiating a setting from other objects}}
\DoxyCodeLine{std::string st = \textcolor{stringliteral}{"{}A String"{}};}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting6(st); \textcolor{comment}{//okay}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting7 = st ; \textcolor{comment}{// not okay}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting8 = \textcolor{stringliteral}{"{}A string"{}}; \textcolor{comment}{// not okay}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// check if Setting supports a type}}
\DoxyCodeLine{\textcolor{keywordtype}{bool} supported = Setting::isValidType<int>(); \textcolor{comment}{// true}}
\DoxyCodeLine{supported = Setting::isValidType<std::string>(); \textcolor{comment}{// true}}
\DoxyCodeLine{supported = Setting::isValidType<const char*>(); \textcolor{comment}{// false}}

\end{DoxyCode}
 

\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{classrr_1_1Setting_af49342a0fabdeeafe649246089a72b40}\label{classrr_1_1Setting_af49342a0fabdeeafe649246089a72b40}} 
\index{rr::Setting@{rr::Setting}!TypeId@{TypeId}}
\index{TypeId@{TypeId}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{TypeId}{TypeId}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{classrr_1_1Setting_af49342a0fabdeeafe649246089a72b40}{rr\+::\+Setting\+::\+Type\+Id}}}



types that correspond to the index of the position of the type in the variant template. 

i.\+e. std\+::string is index 0. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classrr_1_1Setting_ace675cf68c9885e451535578e3c2eff9}\label{classrr_1_1Setting_ace675cf68c9885e451535578e3c2eff9}} 
\index{rr::Setting@{rr::Setting}!Setting@{Setting}}
\index{Setting@{Setting}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{Setting()}{Setting()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class T $>$ \\
rr\+::\+Setting\+::\+Setting (\begin{DoxyParamCaption}\item[{T}]{setting\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructor for creating a \mbox{\hyperlink{classrr_1_1Setting}{Setting}} from a supperted type T. 

\begin{DoxySeeAlso}{See also}
setting\+\_\+t for supported types
\end{DoxySeeAlso}
for developers\+: clang-\/tidy will want you to make this constructor explicit. However, we intentionally keep implicit to allow type casting from type T to \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. \mbox{\Hypertarget{classrr_1_1Setting_a9fe62fdd022c03a9542db4cca43aa6a5}\label{classrr_1_1Setting_a9fe62fdd022c03a9542db4cca43aa6a5}} 
\index{rr::Setting@{rr::Setting}!Setting@{Setting}}
\index{Setting@{Setting}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{Setting()}{Setting()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily rr\+::\+Setting\+::\+Setting (\begin{DoxyParamCaption}\item[{const char $\ast$}]{setting\+Value }\end{DoxyParamCaption})}



constructor for enabling creation of a \mbox{\hyperlink{classrr_1_1Setting}{Setting}} from a string literal. 

The literal gets converted into a std\+::string 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} s(\textcolor{stringliteral}{"{}a string"{}}); \textcolor{comment}{//interpreted as string, not const char*}}

\end{DoxyCode}
 \mbox{\Hypertarget{classrr_1_1Setting_a2f608e0145800200b7795eea56a93cd5}\label{classrr_1_1Setting_a2f608e0145800200b7795eea56a93cd5}} 
\index{rr::Setting@{rr::Setting}!Setting@{Setting}}
\index{Setting@{Setting}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{Setting()}{Setting()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily rr\+::\+Setting\+::\+Setting (\begin{DoxyParamCaption}\item[{std\+::int64\+\_\+t}]{setting\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



construct from a long. 

(std\+::int64\+\_\+t is a long long, which matters on windows) \mbox{\Hypertarget{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}\label{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}} 
\index{rr::Setting@{rr::Setting}!Setting@{Setting}}
\index{Setting@{Setting}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{Setting()}{Setting()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily rr\+::\+Setting\+::\+Setting (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



default constructor. 

Allows instantiating of an empty setting. The empty setting will have a type of std\+::monostate, which is index 0 in setting\+\_\+t 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classrr_1_1Setting_a7b66c72a2cf9b9215733f554b6cd466e}\label{classrr_1_1Setting_a7b66c72a2cf9b9215733f554b6cd466e}} 
\index{rr::Setting@{rr::Setting}!get@{get}}
\index{get@{get}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Setting\+Type $>$ \\
Setting\+Type rr\+::\+Setting\+::get (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



return the value held by this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} as a type Setting\+Type. 

simple wrapper around std\+::get. \begin{DoxyNote}{Note}
for developers. This is a replacement for \mbox{\hyperlink{classrr_1_1Variant_a7bb371be936601754f61d5285f834352}{rr\+::\+Variant\+::convert}} in legacy roadrunner. The name \char`\"{}get\char`\"{} is preferred to \char`\"{}convert\char`\"{} since it follows C++ standard conventions. 
\end{DoxyNote}
\mbox{\Hypertarget{classrr_1_1Setting_afc84a4c084c67e19d37327aa6ebfa61c}\label{classrr_1_1Setting_afc84a4c084c67e19d37327aa6ebfa61c}} 
\index{rr::Setting@{rr::Setting}!get@{get}}
\index{get@{get}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Setting\+Type $>$ \\
Setting\+Type rr\+::\+Setting\+::get (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



return the value held by this setting as type Setting\+Type. 

const version of Setting\+Type\+::get() \begin{DoxySeeAlso}{See also}
Setting\+Type\+::get() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classrr_1_1Setting_a44ebea12f30b1b3e84bf2ebd35c18d06}\label{classrr_1_1Setting_a44ebea12f30b1b3e84bf2ebd35c18d06}} 
\index{rr::Setting@{rr::Setting}!get\_if@{get\_if}}
\index{get\_if@{get\_if}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{get\_if()}{get\_if()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
T$\ast$ rr\+::\+Setting\+::get\+\_\+if (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



get the value of this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} as type T if the value in this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} is of type T. 

wrapper around std\+::get\+\_\+if \mbox{\Hypertarget{classrr_1_1Setting_ab029a70cdac39e82fba2a7857de00679}\label{classrr_1_1Setting_ab029a70cdac39e82fba2a7857de00679}} 
\index{rr::Setting@{rr::Setting}!getAs@{getAs}}
\index{getAs@{getAs}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{getAs()}{getAs()}}
{\footnotesize\ttfamily template$<$class As $>$ \\
As rr\+::\+Setting\+::get\+As (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



explicitly convert this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} to type As. 

type contained by this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} must be readily convertible to type As and throws std\+::invalid\+\_\+argument if not. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} setting(5);}
\DoxyCodeLine{ASSERT\_EQ(setting.get<\textcolor{keywordtype}{int}>(), 5); \textcolor{comment}{// fails if setting is not int}}
\DoxyCodeLine{ASSERT\_THROW(setting.get<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}>();, std::bad\_variant\_access); \textcolor{comment}{// bad, setting contains an int}}
\DoxyCodeLine{ASSERT\_EQ(setting.getAs<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}>(), 5); \textcolor{comment}{// Okay, we can convert from int to unsigned (when int > 0)}}

\end{DoxyCode}
 \mbox{\Hypertarget{classrr_1_1Setting_ab0b42145e5c0dab9a86a5faa790f1d7f}\label{classrr_1_1Setting_ab0b42145e5c0dab9a86a5faa790f1d7f}} 
\index{rr::Setting@{rr::Setting}!isType@{isType}}
\index{isType@{isType}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{isType()}{isType()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
bool rr\+::\+Setting\+::is\+Type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



determines whether the current value of \mbox{\hyperlink{classrr_1_1Setting}{Setting}} is of type T. 

\begin{DoxyReturn}{Returns}
true is \mbox{\hyperlink{classrr_1_1Setting}{Setting}} is of type T 
\end{DoxyReturn}
\mbox{\Hypertarget{classrr_1_1Setting_aa72b6486d1e76a711eeebaef6c806f70}\label{classrr_1_1Setting_aa72b6486d1e76a711eeebaef6c806f70}} 
\index{rr::Setting@{rr::Setting}!operator std::vector$<$ double $>$@{operator std::vector$<$ double $>$}}
\index{operator std::vector$<$ double $>$@{operator std::vector$<$ double $>$}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{operator std::vector$<$ double $>$()}{operator std::vector< double >()}}
{\footnotesize\ttfamily rr\+::\+Setting\+::operator std\+::vector$<$ double $>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



implicit cast this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} to a std\+::vector$<$double$>$. 

If this operator is used and the type contained by this \mbox{\hyperlink{classrr_1_1Setting}{Setting}} is not a double vector, an std\+::invalid\+\_\+argument error is thrown.

the generic operator T() method does not cover the case when we have a vector of doubles, so we must implement this manually. We could write another template for the more general case, but only support for std\+::vector$<$double$>$ is needed. \mbox{\Hypertarget{classrr_1_1Setting_aa76e883343a714ee58ee6025ebd0fefa}\label{classrr_1_1Setting_aa76e883343a714ee58ee6025ebd0fefa}} 
\index{rr::Setting@{rr::Setting}!operator T@{operator T}}
\index{operator T@{operator T}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{operator T()}{operator T()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rr\+::\+Setting\+::operator T (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



implicit type conversion support for the \mbox{\hyperlink{classrr_1_1Setting}{Setting}} class. 

this method is responsible for enabling implicit conversion between \mbox{\hyperlink{classrr_1_1Setting}{Setting}} and its supported types. Moreover, it enables one to implicitly convert (say) a int to a long, in contexts that make sense (as determined by std\+::is\+\_\+convertible\+\_\+v). Some situations are explicitly prohibited from implicit type conversion. These include
\begin{DoxyItemize}
\item converting a negative int or long to unsigned int or long
\item converting a long that has a value $>$ the largest possible value for int to int \begin{DoxyNote}{Note}
for developers\+: clang-\/tidy will ask you to make this explicit, but this method {\itshape must} not be explicit since its entire purpose is implicit type conversion. 

for developers\+: Any additions to types stored in a setting\+\_\+t {\itshape must} have appropriate unit tests added for the new types in Setting\+Tests.\+cpp. 
\end{DoxyNote}

\end{DoxyItemize}\mbox{\Hypertarget{classrr_1_1Setting_adcf3783161d25aa1082673116eb44df0}\label{classrr_1_1Setting_adcf3783161d25aa1082673116eb44df0}} 
\index{rr::Setting@{rr::Setting}!operator=@{operator=}}
\index{operator=@{operator=}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classrr_1_1Setting}{Setting}} \& rr\+::\+Setting\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classrr_1_1Setting}{Setting}} \&}]{setting }\end{DoxyParamCaption})}



move assignment operator for when rhs is a \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. 

\begin{DoxySeeAlso}{See also}
operator=(const T\&setting); 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classrr_1_1Setting_ad62b4bb5f092aa767644bf7b59a41f66}\label{classrr_1_1Setting_ad62b4bb5f092aa767644bf7b59a41f66}} 
\index{rr::Setting@{rr::Setting}!parse@{parse}}
\index{parse@{parse}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classrr_1_1Setting}{Setting}} rr\+::\+Setting\+::parse (\begin{DoxyParamCaption}\item[{std\+::string \&}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Parses the std\+::string which must be in JSON format. 

This is a common way to read a \mbox{\hyperlink{classrr_1_1Variant}{Variant}} from a file or create a new one from a std\+::string\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Variant v = \mbox{\hyperlink{classrr_1_1Variant_abe42f3be24595157e92e255ddf5ef082}{Variant::parse}}(\textcolor{stringliteral}{"{}0.123"{}});}

\end{DoxyCode}
 \begin{DoxyNote}{Note}
this function is a tangent to the main \mbox{\hyperlink{classrr_1_1Setting}{Setting}} class. We should instead have a JSON parser, is that\textquotesingle{}s the function we need. 
\end{DoxyNote}
\mbox{\Hypertarget{classrr_1_1Setting_aca92fd79b60e0dfbf9b3f14893b766b6}\label{classrr_1_1Setting_aca92fd79b60e0dfbf9b3f14893b766b6}} 
\index{rr::Setting@{rr::Setting}!pythonRepr@{pythonRepr}}
\index{pythonRepr@{pythonRepr}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{pythonRepr()}{pythonRepr()}}
{\footnotesize\ttfamily std\+::string rr\+::\+Setting\+::python\+Repr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Convert to Python-\/compatible representation. 

\begin{DoxyAuthor}{Author}
JKM 
\end{DoxyAuthor}
\mbox{\Hypertarget{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}\label{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}} 
\index{rr::Setting@{rr::Setting}!type@{type}}
\index{type@{type}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{type()}{type()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classrr_1_1Setting_af49342a0fabdeeafe649246089a72b40}{Setting\+::\+Type\+Id}} rr\+::\+Setting\+::type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



returns the type of std\+::variant contained within this \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. 

\begin{DoxyReturn}{Returns}
an integer which refers to the index of the type contained in this \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. The index is resolved by looking at the Type\+Id enum (or indeed the ordering of the type parameters to setting\+\_\+t. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrr_1_1Setting_a66c1f37c3e43dd1850e4a4dd1e96b305}\label{classrr_1_1Setting_a66c1f37c3e43dd1850e4a4dd1e96b305}} 
\index{rr::Setting@{rr::Setting}!typeInfo@{typeInfo}}
\index{typeInfo@{typeInfo}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{typeInfo()}{typeInfo()}}
{\footnotesize\ttfamily const std\+::type\+\_\+info \& rr\+::\+Setting\+::type\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



returns the std\+::type\+\_\+info for the object type contained within this \mbox{\hyperlink{classrr_1_1Setting}{Setting}}. 

(aka one of the types within setting\+\_\+t) \mbox{\Hypertarget{classrr_1_1Setting_ac2a86d3d0bd3a722a37f26d6afeef5a2}\label{classrr_1_1Setting_ac2a86d3d0bd3a722a37f26d6afeef5a2}} 
\index{rr::Setting@{rr::Setting}!visit@{visit}}
\index{visit@{visit}!rr::Setting@{rr::Setting}}
\doxysubsubsection{\texorpdfstring{visit()}{visit()}}
{\footnotesize\ttfamily template$<$class Func $>$ \\
decltype(auto) rr\+::\+Setting\+::visit (\begin{DoxyParamCaption}\item[{Func}]{function }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



equality operator for comparing object other\+Setting of type T against the \mbox{\hyperlink{classrr_1_1Setting}{Setting}} contained within this Setting.\+value\+\_\+. 

Enables the following types of comparisons 
\begin{DoxyCode}{0}
\DoxyCodeLine{    \mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} s1(\textcolor{stringliteral}{"{}string"{}});}
\DoxyCodeLine{    std::string s2 = \textcolor{stringliteral}{"{}string"{}};}
\DoxyCodeLine{    s1 == s2; \textcolor{comment}{// true}}
\DoxyCodeLine{    \textcolor{comment}{// or}}
\DoxyCodeLine{    \mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} s3(1234);}
\DoxyCodeLine{    \textcolor{keywordtype}{int} s4 = 1234;}
\DoxyCodeLine{    s3 == s4; \textcolor{comment}{// true}}
\DoxyCodeLine{   @details Implemented \textcolor{keyword}{using} SFINAE -\/ substitute failure is not an error.}
\DoxyCodeLine{   The seconds \textcolor{keyword}{template} argument is only \textcolor{keyword}{true} when \mbox{\hyperlink{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}{type}} T is a valid variant}
\DoxyCodeLine{   and when \textcolor{keyword}{this} argument evaluates to \textcolor{keyword}{false}, the compiler will not generate}
\DoxyCodeLine{   a code \textcolor{keywordflow}{for} the \textcolor{keyword}{template} types. Thus, \textcolor{keyword}{this} \textcolor{keyword}{template} is only defined \textcolor{keywordflow}{for}}
\DoxyCodeLine{   types that are a part of setting\_t.}
\DoxyCodeLine{  /}
\DoxyCodeLine{template<typename T, class = typename std::enable\_if<isValidVariantType<T, setting\_t>::value>\mbox{\hyperlink{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}{::type}}>}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} T \&otherSetting) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} settingValue = get\_if<T>()) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} *settingValue == otherSetting;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T,}
\DoxyCodeLine{        \textcolor{keyword}{class }= \textcolor{keyword}{typename} std::enable\_if<isValidVariantType<T, setting\_t>::value>\mbox{\hyperlink{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}{::type}}>}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} T \&setting) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} !(*\textcolor{keyword}{this} == setting);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} \&setting);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *setting);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *setting);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} \mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} \&setting);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{template<typename T, class = typename std::enable\_if<isValidVariantType<T, setting\_t>::value>\mbox{\hyperlink{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}{::type}}>}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} \&\mbox{\hyperlink{classrr_1_1Setting_adcf3783161d25aa1082673116eb44df0}{operator=}}(\textcolor{keyword}{const} T \&setting) \{}
\DoxyCodeLine{    checkValidType<T>();}
\DoxyCodeLine{    \textcolor{comment}{// no need to check self assignment with variant}}
\DoxyCodeLine{    value\_ = setting\_t(setting);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{template<typename T, class = typename std::enable\_if<isValidVariantType<T, setting\_t>::value>\mbox{\hyperlink{classrr_1_1Setting_a479708abc63de00aca3d56b7e28bee04}{::type}}>}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Setting_a2f3f6beff36ad237ca6493dfaa19741f}{Setting}} \&\mbox{\hyperlink{classrr_1_1Setting_adcf3783161d25aa1082673116eb44df0}{operator=}}(T \&\&setting) noexcept \{}
\DoxyCodeLine{    checkValidType<T>();}
\DoxyCodeLine{    \textcolor{comment}{// no need to check self assignment with variant}}
\DoxyCodeLine{    value\_ = std::move(setting\_t(setting));}
\DoxyCodeLine{    \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}

\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
docs on std\+::visit 
\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Setting.\+h\item 
Setting.\+cpp\end{DoxyCompactItemize}
