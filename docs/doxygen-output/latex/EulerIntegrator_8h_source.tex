\hypertarget{EulerIntegrator_8h_source}{}\doxysection{Euler\+Integrator.\+h}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ * EulerIntegrator.h}}
\DoxyCodeLine{3 \textcolor{comment}{ *}}
\DoxyCodeLine{4 \textcolor{comment}{ *  Created on: Dec 17, 2014}}
\DoxyCodeLine{5 \textcolor{comment}{ *      Author: andy}}
\DoxyCodeLine{6 \textcolor{comment}{ */}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef EULERINTEGRATOR\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define EULERINTEGRATOR\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{Integrator_8h}{Integrator.h}}"{}}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{rrExecutableModel_8h}{rrExecutableModel.h}}"{}}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}rrRoadRunnerOptions.h"{}}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{keyword}{namespace }rr \{}
\DoxyCodeLine{21     \textcolor{keyword}{using} std::string;}
\DoxyCodeLine{22     \textcolor{keyword}{using} std::invalid\_argument;}
\DoxyCodeLine{23     \textcolor{keyword}{using} std::stringstream;}
\DoxyCodeLine{24 }
\DoxyCodeLine{55     \textcolor{keyword}{class }\mbox{\hyperlink{classrr_1_1EulerIntegrator}{EulerIntegrator}} : \textcolor{keyword}{public} \mbox{\hyperlink{classrr_1_1Integrator}{Integrator}} \{}
\DoxyCodeLine{56     \textcolor{keyword}{public}:}
\DoxyCodeLine{57 }
\DoxyCodeLine{58         \textcolor{keyword}{using} Integrator::Integrator;}
\DoxyCodeLine{59 }
\DoxyCodeLine{75         \mbox{\hyperlink{classrr_1_1EulerIntegrator_afc90e9a20043ba1a05db9adba8d53cfe}{EulerIntegrator}}(\mbox{\hyperlink{classrr_1_1ExecutableModel}{ExecutableModel}} *m)}
\DoxyCodeLine{76                 : \mbox{\hyperlink{classrr_1_1Integrator}{Integrator}}(m),}
\DoxyCodeLine{77                   eventStatus(std::vector<unsigned char>(m-\/>getNumEvents(), false)),}
\DoxyCodeLine{78                   previousEventStatus(std::vector<unsigned char>(m-\/>getNumEvents(), false)) \{}
\DoxyCodeLine{79             \mbox{\hyperlink{classrr_1_1EulerIntegrator_a345df1be0ad82f14a56273b89a26828a}{EulerIntegrator::resetSettings}}();}
\DoxyCodeLine{80 }
\DoxyCodeLine{81             \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}} = m;}
\DoxyCodeLine{82             exampleParameter1 = 3.14;}
\DoxyCodeLine{83             exampleParameter2 = \textcolor{stringliteral}{"{}hello"{}};}
\DoxyCodeLine{84             rrLog(Logger::LOG\_WARNING) << \textcolor{stringliteral}{"{}Euler integrator is inaccurate"{}};}
\DoxyCodeLine{85             \textcolor{comment}{//std::cerr << "{}Number of event triggers: "{} << m-\/>getEventTriggers(0, 0, 0) << std::endl;}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87             \textcolor{keywordflow}{if} (\mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}) \{}
\DoxyCodeLine{88                 \textcolor{comment}{// calling the getStateVector with a NULL argument returns}}
\DoxyCodeLine{89                 \textcolor{comment}{// the size of teh state std::vector.}}
\DoxyCodeLine{90                 stateVectorSize = \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}-\/>\mbox{\hyperlink{classrr_1_1ExecutableModel_a75b6f37ac538d2d2a0709fe4080b0570}{getStateVector}}(NULL);}
\DoxyCodeLine{91                 rateBuffer = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[stateVectorSize];}
\DoxyCodeLine{92                 stateBufferBegin = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[stateVectorSize];}
\DoxyCodeLine{93                 stateBufferEnd = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[stateVectorSize];}
\DoxyCodeLine{94             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{95                 rateBuffer = NULL;}
\DoxyCodeLine{96                 stateBufferBegin = NULL;}
\DoxyCodeLine{97                 stateBufferEnd = NULL;}
\DoxyCodeLine{98             \}}
\DoxyCodeLine{99         \}}
\DoxyCodeLine{100 }
\DoxyCodeLine{104         \mbox{\hyperlink{classrr_1_1EulerIntegrator_ae67944a6230da902b4a4e0e5aa59a82d}{\string~EulerIntegrator}}()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{105             \textcolor{keywordflow}{if} (\mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}) \{}
\DoxyCodeLine{106                 \textcolor{keyword}{delete}[] rateBuffer;}
\DoxyCodeLine{107                 \textcolor{keyword}{delete}[] stateBufferBegin;}
\DoxyCodeLine{108                 \textcolor{keyword}{delete}[] stateBufferEnd;}
\DoxyCodeLine{109                 rateBuffer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{110                 stateBufferBegin = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{111                 stateBufferEnd = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{112             \}}
\DoxyCodeLine{113         \};}
\DoxyCodeLine{114 }
\DoxyCodeLine{124         \textcolor{keyword}{virtual} \textcolor{keywordtype}{double} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a5b94124e1efbca3f0fd151f736912276}{integrate}}(\textcolor{keywordtype}{double} t0, \textcolor{keywordtype}{double} h)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{125             \textcolor{keywordtype}{int} internal\_steps = \mbox{\hyperlink{classrr_1_1Solver_a87339915a211b22ecd63078bb1cb7ca9}{getValue}}(\textcolor{stringliteral}{"{}subdivision\_steps"{}});}
\DoxyCodeLine{126             \textcolor{keywordflow}{if} (\mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}} == (\mbox{\hyperlink{classrr_1_1ExecutableModel}{rr::ExecutableModel}} *) NULL) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{127 }
\DoxyCodeLine{128             \textcolor{keywordtype}{double} finalTimeEnd;}
\DoxyCodeLine{129 }
\DoxyCodeLine{130             h /= internal\_steps;}
\DoxyCodeLine{131             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} subdiv = 0; subdiv < internal\_steps; ++subdiv) \{}
\DoxyCodeLine{132                 \textcolor{comment}{// evaluate and copy the rate of change of the state std::vector}}
\DoxyCodeLine{133                 \textcolor{comment}{// rate into the local buffer. If the 2nd argument is NULL,}}
\DoxyCodeLine{134                 \textcolor{comment}{// the current mModel state is used to evaluate the}}
\DoxyCodeLine{135                 \textcolor{comment}{// state std::vector rate.}}
\DoxyCodeLine{136                 \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}-\/>\mbox{\hyperlink{classrr_1_1ExecutableModel_a0495c2ece9edad29d61849b2443d4274}{getStateVectorRate}}(t0, NULL, rateBuffer);}
\DoxyCodeLine{137 }
\DoxyCodeLine{138                 \textcolor{comment}{// copy the current state std::vector into a local buffer}}
\DoxyCodeLine{139                 \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}-\/>\mbox{\hyperlink{classrr_1_1ExecutableModel_a75b6f37ac538d2d2a0709fe4080b0570}{getStateVector}}(stateBufferBegin);}
\DoxyCodeLine{140 }
\DoxyCodeLine{141                 \textcolor{comment}{// perform the Euler integration step, i.e.}}
\DoxyCodeLine{142                 \textcolor{comment}{// y\_\{n+1\} = y\_\{n\} + h * y'\_\{n\}}}
\DoxyCodeLine{143                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < stateVectorSize; ++i) \{}
\DoxyCodeLine{144                     stateBufferEnd[i] = stateBufferBegin[i] + h * rateBuffer[i];}
\DoxyCodeLine{145                 \}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147                 \textcolor{comment}{// set the mModel state to the newly calculated state}}
\DoxyCodeLine{148                 \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}-\/>\mbox{\hyperlink{classrr_1_1ExecutableModel_a57a67063c957714b916d4a3d4277c3b9}{setStateVector}}(stateBufferEnd);}
\DoxyCodeLine{149 }
\DoxyCodeLine{150                 \textcolor{comment}{// update the mModel time to the new time}}
\DoxyCodeLine{151                 \textcolor{keywordtype}{double} timeEnd = t0 + h;}
\DoxyCodeLine{152                 \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}-\/>setTime(timeEnd);}
\DoxyCodeLine{153 }
\DoxyCodeLine{154                 \textcolor{comment}{// if we have a client, notify them that we have taken}}
\DoxyCodeLine{155                 \textcolor{comment}{// a time step}}
\DoxyCodeLine{156                 \textcolor{keywordflow}{if} (listener) \{}
\DoxyCodeLine{157                     listener-\/>onTimeStep(\textcolor{keyword}{this}, \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}, timeEnd);}
\DoxyCodeLine{158                 \}}
\DoxyCodeLine{159 }
\DoxyCodeLine{160                 \textcolor{comment}{// events}}
\DoxyCodeLine{161                 \textcolor{keywordtype}{bool} triggered = \textcolor{keyword}{false};}
\DoxyCodeLine{162 }
\DoxyCodeLine{163                 \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}-\/>\mbox{\hyperlink{classrr_1_1ExecutableModel_a6402d7445658e1828be487e1a63bbc89}{getEventTriggers}}(eventStatus.size(), NULL, eventStatus.size() ? \&eventStatus[0] : NULL);}
\DoxyCodeLine{164                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k\_ = 0; k\_ < eventStatus.size(); ++k\_) \{}
\DoxyCodeLine{165                     \textcolor{keywordflow}{if} (eventStatus.at(k\_)) \{}
\DoxyCodeLine{166                         triggered = \textcolor{keyword}{true};}
\DoxyCodeLine{167                         \textcolor{comment}{//std::cerr << "{}Triggered"{} << std::endl;}}
\DoxyCodeLine{168                     \}}
\DoxyCodeLine{169                 \}}
\DoxyCodeLine{170 }
\DoxyCodeLine{171                 \textcolor{keywordflow}{if} (triggered) \{}
\DoxyCodeLine{172                     \textcolor{comment}{// applyEvents takes the list of events which were previously triggered}}
\DoxyCodeLine{173                     \textcolor{comment}{//std::cerr << "{}An event was triggered at "{} << t0 << std::endl;}}
\DoxyCodeLine{174                     applyEvents(timeEnd, previousEventStatus);}
\DoxyCodeLine{175                 \}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177                 \textcolor{keywordflow}{if} (!eventStatus.empty()) \{}
\DoxyCodeLine{178                     previousEventStatus = eventStatus;}
\DoxyCodeLine{179                 \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181                 finalTimeEnd = timeEnd;}
\DoxyCodeLine{182             \}}
\DoxyCodeLine{183 }
\DoxyCodeLine{184             \textcolor{keywordflow}{return} finalTimeEnd;}
\DoxyCodeLine{185         \}}
\DoxyCodeLine{186 }
\DoxyCodeLine{187         \textcolor{keywordtype}{void} applyEvents(\textcolor{keywordtype}{double} timeEnd, std::vector<unsigned char> \&previousEventStatus) \{}
\DoxyCodeLine{188             \textcolor{comment}{//std::cerr << "{}Size of previous events: "{} << previousEventStatus.size() << std::endl;}}
\DoxyCodeLine{189             \textcolor{comment}{// If we pass in the events including the ones just triggered, they won't be applied, so use previousEventStatus}}
\DoxyCodeLine{190             \mbox{\hyperlink{classrr_1_1Solver_ab60e7640a8c959558a144d9d7ee45515}{mModel}}-\/>\mbox{\hyperlink{classrr_1_1ExecutableModel_ae30181bdbfd3e4fedc2dedcf988ecb95}{applyEvents}}(timeEnd, previousEventStatus.size() == 0 ? NULL : \&previousEventStatus[0],}
\DoxyCodeLine{191                                 stateBufferEnd, NULL);}
\DoxyCodeLine{192             \textcolor{comment}{// AHu: jk I think that mModel-\/>applyEvents does update the mode's state std::vector}}
\DoxyCodeLine{193             \textcolor{comment}{// The previous statement loaded the result into the final stateBufferEnd, so now update the mModel's state std::vector}}
\DoxyCodeLine{194             \textcolor{comment}{//mModel-\/>setStateVector(stateBufferEnd);}}
\DoxyCodeLine{195         \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{200         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a82a562273e6d73bebcb8e25de45a20a4}{restart}}(\textcolor{keywordtype}{double} t0)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{201 }
\DoxyCodeLine{206         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a5e291108e3a53b921a90450ee2efbe48}{setListener}}(IntegratorListenerPtr p)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{207             listener = p;}
\DoxyCodeLine{208         \}}
\DoxyCodeLine{209 }
\DoxyCodeLine{213         \textcolor{keyword}{virtual} IntegratorListenerPtr \mbox{\hyperlink{classrr_1_1EulerIntegrator_a446b4802e6e5a7db2f2f60cbac430d4a}{getListener}}()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{214             \textcolor{keywordflow}{return} listener;}
\DoxyCodeLine{215         \}}
\DoxyCodeLine{216 }
\DoxyCodeLine{220         \textcolor{keyword}{virtual} std::string \mbox{\hyperlink{classrr_1_1EulerIntegrator_a65fed1a29701ddcfb6d0d3f023550bc8}{toString}}()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{221             std::stringstream ss;}
\DoxyCodeLine{222             ss << \textcolor{stringliteral}{"{}< roadrunner.EulerIntegrator() "{}} << std::endl;}
\DoxyCodeLine{223             ss << \textcolor{stringliteral}{"{}\{ 'this' : "{}} << (\textcolor{keywordtype}{void} *) \textcolor{keyword}{this} << std::endl;}
\DoxyCodeLine{224             ss << \textcolor{stringliteral}{"{}'exampleParameter1' : "{}} << exampleParameter1 << std::endl;}
\DoxyCodeLine{225             ss << \textcolor{stringliteral}{"{}'exampleParameter2' : "{}} << exampleParameter2 << std::endl;}
\DoxyCodeLine{226             ss << \textcolor{stringliteral}{"{}\}>"{}};}
\DoxyCodeLine{227             \textcolor{keywordflow}{return} ss.str();}
\DoxyCodeLine{228         \}}
\DoxyCodeLine{229 }
\DoxyCodeLine{233         \textcolor{keyword}{virtual} std::string \mbox{\hyperlink{classrr_1_1EulerIntegrator_abc775885d87bf9afa1b5616fe28d1de3}{toRepr}}()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{234             std::stringstream ss;}
\DoxyCodeLine{235             ss << \textcolor{stringliteral}{"{}< roadrunner.EulerIntegrator() \{ 'this' : "{}}}
\DoxyCodeLine{236                << (\textcolor{keywordtype}{void} *) \textcolor{keyword}{this} << \textcolor{stringliteral}{"{} \}>"{}};}
\DoxyCodeLine{237             \textcolor{keywordflow}{return} ss.str();}
\DoxyCodeLine{238         \}}
\DoxyCodeLine{239 }
\DoxyCodeLine{243         std::string \mbox{\hyperlink{classrr_1_1EulerIntegrator_a00bf9001b752eb56da29bb1d0ff4ea68}{getName}}()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{244             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}euler"{}};}
\DoxyCodeLine{245         \}}
\DoxyCodeLine{246 }
\DoxyCodeLine{252         std::string \mbox{\hyperlink{classrr_1_1EulerIntegrator_a5c3fe76e2ab79a6bf9dfa5b1f382308a}{getDescription}}()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{253             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}The Euler method is one of the simplest approaches to "{}}}
\DoxyCodeLine{254                    \textcolor{stringliteral}{"{}solving a first order ODE. Given the rate of change of "{}}}
\DoxyCodeLine{255                    \textcolor{stringliteral}{"{}function f at time t, it computes the new value of f as "{}}}
\DoxyCodeLine{256                    \textcolor{stringliteral}{"{}f(t+h) = f(t) + h*f'(t), where h is the time step. "{}}}
\DoxyCodeLine{257                    \textcolor{stringliteral}{"{}Euler's method is rarely used in practice due to poor "{}}}
\DoxyCodeLine{258                    \textcolor{stringliteral}{"{}numerical robustness."{}};}
\DoxyCodeLine{259         \}}
\DoxyCodeLine{260 }
\DoxyCodeLine{266         std::string \mbox{\hyperlink{classrr_1_1EulerIntegrator_a915c7662fbab3e2c39a67826f70495fa}{getHint}}()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{267             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}A simple Euler integrator"{}};}
\DoxyCodeLine{268         \}}
\DoxyCodeLine{269 }
\DoxyCodeLine{270         \mbox{\hyperlink{classrr_1_1Solver}{Solver}} *\mbox{\hyperlink{classrr_1_1EulerIntegrator_a1271f2648559c9f491d38ce60d92654f}{construct}}(\mbox{\hyperlink{classrr_1_1ExecutableModel}{ExecutableModel}} *executableModel)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{271             \textcolor{keywordflow}{return} \textcolor{keyword}{new} \mbox{\hyperlink{classrr_1_1EulerIntegrator_afc90e9a20043ba1a05db9adba8d53cfe}{EulerIntegrator}}(executableModel);}
\DoxyCodeLine{272         \}}
\DoxyCodeLine{273 }
\DoxyCodeLine{278         IntegrationMethod \mbox{\hyperlink{classrr_1_1EulerIntegrator_a8c70add8b8867dadd74af16da2209cf6}{getIntegrationMethod}}()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{279             \textcolor{keywordflow}{return} Integrator::Deterministic;}
\DoxyCodeLine{280         \}}
\DoxyCodeLine{281 }
\DoxyCodeLine{288         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a023226258950d8437b7a27c077b693b3}{setItem}}(\textcolor{keyword}{const} std::string \&key, \textcolor{keyword}{const} \mbox{\hyperlink{classrr_1_1Setting}{rr::Setting}} \&value) \{}
\DoxyCodeLine{289             \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{"{}exampleParameter1"{}}) \{}
\DoxyCodeLine{290                 exampleParameter1 = value.\mbox{\hyperlink{classrr_1_1Setting_a7b66c72a2cf9b9215733f554b6cd466e}{get}}<\textcolor{keywordtype}{double}>();}
\DoxyCodeLine{291                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{292             \}}
\DoxyCodeLine{293 }
\DoxyCodeLine{294             \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{"{}exampleParameter2"{}}) \{}
\DoxyCodeLine{295                 \textcolor{comment}{// Ahu: Why is this cast here, and is this a static or dynamic cast?}}
\DoxyCodeLine{296                 exampleParameter2 = value.\mbox{\hyperlink{classrr_1_1Setting_a7b66c72a2cf9b9215733f554b6cd466e}{get}}<std::string>();}
\DoxyCodeLine{297                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{298             \}}
\DoxyCodeLine{299 }
\DoxyCodeLine{300             \textcolor{comment}{// they did not give a valid key, so throw an exception.}}
\DoxyCodeLine{301             \textcolor{keywordflow}{throw} std::invalid\_argument(\textcolor{stringliteral}{"{}Error, attempt to set invalid key: "{}} + key);}
\DoxyCodeLine{302         \}}
\DoxyCodeLine{303 }
\DoxyCodeLine{310         \textcolor{keyword}{virtual} \mbox{\hyperlink{classrr_1_1Setting}{Setting}} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a243b2296bfee9540f967a73968cc66f6}{getItem}}(\textcolor{keyword}{const} std::string \&key)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{311             \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{"{}exampleParameter1"{}}) \{}
\DoxyCodeLine{312                 \textcolor{keywordflow}{return} \mbox{\hyperlink{classrr_1_1Setting}{Setting}}(exampleParameter1);}
\DoxyCodeLine{313             \}}
\DoxyCodeLine{314 }
\DoxyCodeLine{315             \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{"{}exampleParameter2"{}}) \{}
\DoxyCodeLine{316                 \textcolor{keywordflow}{return} \mbox{\hyperlink{classrr_1_1Setting}{Setting}}(exampleParameter2);}
\DoxyCodeLine{317             \}}
\DoxyCodeLine{318 }
\DoxyCodeLine{319             \textcolor{comment}{// they did not give a valid key, so throw an exception.}}
\DoxyCodeLine{320             \textcolor{keywordflow}{throw} std::invalid\_argument(\textcolor{stringliteral}{"{}Error, attempt to read invalid key: "{}} + key);}
\DoxyCodeLine{321         \}}
\DoxyCodeLine{322 }
\DoxyCodeLine{326         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a38c66c42d843b391ac79ac6f352cbf6c}{hasKey}}(\textcolor{keyword}{const} std::string \&key)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{327             \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{"{}exampleParameter1"{}} || key == \textcolor{stringliteral}{"{}exampleParameter2"{}}) \{}
\DoxyCodeLine{328                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{329             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{330                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{331             \}}
\DoxyCodeLine{332         \}}
\DoxyCodeLine{333 }
\DoxyCodeLine{338         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a370a0145394d1a9ed17a798565651369}{deleteItem}}(\textcolor{keyword}{const} std::string \&key) \{}
\DoxyCodeLine{339             \textcolor{keywordflow}{throw} std::invalid\_argument(}
\DoxyCodeLine{340                     \textcolor{stringliteral}{"{}Error, the EulerIntegrator does not support deleting keys"{}});}
\DoxyCodeLine{341         \}}
\DoxyCodeLine{342 }
\DoxyCodeLine{346         \textcolor{keyword}{virtual} std::vector<std::string> \mbox{\hyperlink{classrr_1_1EulerIntegrator_adbd7505a537ad01b03802435f24776c4}{getKeys}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{347             std::vector<std::string> keys;}
\DoxyCodeLine{348             keys.push\_back(\textcolor{stringliteral}{"{}exampleParameter1"{}});}
\DoxyCodeLine{349             keys.push\_back(\textcolor{stringliteral}{"{}exampleParameter2"{}});}
\DoxyCodeLine{350             \textcolor{keywordflow}{return} keys;}
\DoxyCodeLine{351         \}}
\DoxyCodeLine{352 }
\DoxyCodeLine{353         \textcolor{keywordtype}{void} \mbox{\hyperlink{classrr_1_1EulerIntegrator_a345df1be0ad82f14a56273b89a26828a}{resetSettings}}()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{354             \mbox{\hyperlink{classrr_1_1Solver_a71c8b404a40447f879b2253e7dcc3b85}{Solver::resetSettings}}();}
\DoxyCodeLine{355 }
\DoxyCodeLine{356             \textcolor{comment}{// Set default integrator settings.}}
\DoxyCodeLine{357             addSetting(\textcolor{stringliteral}{"{}subdivision\_steps"{}}, \mbox{\hyperlink{classrr_1_1Setting}{Setting}}(1),}
\DoxyCodeLine{358                        \textcolor{stringliteral}{"{}Subdivision Steps"{}},}
\DoxyCodeLine{359                        \textcolor{stringliteral}{"{}The number of subdivisions of the Euler step size (int)."{}},}
\DoxyCodeLine{360                        \textcolor{stringliteral}{"{}(int) For each point, up to this many extra steps will be taken as smaller steps within each step, although their values are not saved"{}});}
\DoxyCodeLine{361         \}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363     \textcolor{keyword}{private}:}
\DoxyCodeLine{367         \textcolor{keywordtype}{double} exampleParameter1;}
\DoxyCodeLine{368 }
\DoxyCodeLine{372         std::string exampleParameter2;}
\DoxyCodeLine{373 }
\DoxyCodeLine{378         \textcolor{keywordtype}{double} *rateBuffer, *stateBufferBegin, *stateBufferEnd;}
\DoxyCodeLine{379 }
\DoxyCodeLine{383         \textcolor{keywordtype}{int} stateVectorSize;}
\DoxyCodeLine{384 }
\DoxyCodeLine{385         std::vector<unsigned char> eventStatus;}
\DoxyCodeLine{386         std::vector<unsigned char> previousEventStatus;}
\DoxyCodeLine{387 }
\DoxyCodeLine{397         IntegratorListenerPtr listener;}
\DoxyCodeLine{398     \};}
\DoxyCodeLine{399 }
\DoxyCodeLine{400 }
\DoxyCodeLine{401     \textcolor{comment}{// ** Registration *********************************************************}}
\DoxyCodeLine{402 }
\DoxyCodeLine{403 }
\DoxyCodeLine{404 \} \textcolor{comment}{/* namespace rr */}}
\DoxyCodeLine{405 }
\DoxyCodeLine{406 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* EULERINTEGRATOR\_H\_ */}\textcolor{preprocessor}{}}

\end{DoxyCode}
