\hypertarget{classrrllvm_1_1LoadSymbolResolver}{}\doxysection{rrllvm\+::Load\+Symbol\+Resolver Class Reference}
\label{classrrllvm_1_1LoadSymbolResolver}\index{rrllvm::LoadSymbolResolver@{rrllvm::LoadSymbolResolver}}
Inheritance diagram for rrllvm\+::Load\+Symbol\+Resolver\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.707317cm]{classrrllvm_1_1LoadSymbolResolver}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual llvm\+::\+Value $\ast$ \mbox{\hyperlink{classrrllvm_1_1LoadSymbolResolver_a832a8d0b229eb12271e58db3e20ebe98}{load\+Symbol\+Value}} (const std\+::string \&symbol, const llvm\+::\+Array\+Ref$<$ llvm\+::\+Value $\ast$ $>$ \&args=llvm\+::\+Array\+Ref$<$ llvm\+::\+Value $\ast$ $>$())=0
\begin{DoxyCompactList}\small\item\em generate an LLVM load instruction. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrrllvm_1_1LoadSymbolResolver_ae76af01bea67ddc67ca14112ef117867}\label{classrrllvm_1_1LoadSymbolResolver_ae76af01bea67ddc67ca14112ef117867}} 
virtual void {\bfseries recursive\+Symbol\+Push} (const std\+::string \&symbol)=0
\item 
\mbox{\Hypertarget{classrrllvm_1_1LoadSymbolResolver_a0c192e55ced93b4f06d5cf9bc2579d4d}\label{classrrllvm_1_1LoadSymbolResolver_a0c192e55ced93b4f06d5cf9bc2579d4d}} 
virtual void {\bfseries recursive\+Symbol\+Pop} ()=0
\item 
virtual size\+\_\+t \mbox{\hyperlink{classrrllvm_1_1LoadSymbolResolver_ab388d2fa6565e68437798bc1d566b29b}{push\+Cache\+Block}} ()
\begin{DoxyCompactList}\small\item\em nested conditionals (or functions?) can push a local cache block, where symbols would be chached. \end{DoxyCompactList}\item 
virtual size\+\_\+t \mbox{\hyperlink{classrrllvm_1_1LoadSymbolResolver_a64c0e7ee5311a610d252dc603e20a94f}{pop\+Cache\+Block}} ()
\begin{DoxyCompactList}\small\item\em Pop a scoped cache block, this clears these values, and any subsequent reads re-\/evaluate the requested symbol. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classrrllvm_1_1LoadSymbolResolver_a832a8d0b229eb12271e58db3e20ebe98}\label{classrrllvm_1_1LoadSymbolResolver_a832a8d0b229eb12271e58db3e20ebe98}} 
\index{rrllvm::LoadSymbolResolver@{rrllvm::LoadSymbolResolver}!loadSymbolValue@{loadSymbolValue}}
\index{loadSymbolValue@{loadSymbolValue}!rrllvm::LoadSymbolResolver@{rrllvm::LoadSymbolResolver}}
\doxysubsubsection{\texorpdfstring{loadSymbolValue()}{loadSymbolValue()}}
{\footnotesize\ttfamily virtual llvm\+::\+Value $\ast$ rrllvm\+::\+Load\+Symbol\+Resolver\+::load\+Symbol\+Value (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{symbol,  }\item[{const llvm\+::\+Array\+Ref$<$ llvm\+::\+Value $\ast$ $>$ \&}]{args = {\ttfamily llvm\+:\+:ArrayRef$<$~llvm\+:\+:Value~$\ast$~$>$()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



generate an LLVM load instruction. 


\begin{DoxyParams}{Parameters}
{\em symbol} & the symbol name to resolve \\
\hline
{\em args} & function argument list \\
\hline
\end{DoxyParams}


Implemented in \mbox{\hyperlink{classrrllvm_1_1FunctionResolver_a3cb392b698b4a6bcfca2bb56312d3809}{rrllvm\+::\+Function\+Resolver}}, \mbox{\hyperlink{classrrllvm_1_1KineticLawParameterResolver_ac04cd2cdb1aebcbb28dc7c59325d604d}{rrllvm\+::\+Kinetic\+Law\+Parameter\+Resolver}}, \mbox{\hyperlink{classrrllvm_1_1ModelInitialValueSymbolResolver_a290a08a89dbed631cd62729c9ee72871}{rrllvm\+::\+Model\+Initial\+Value\+Symbol\+Resolver}}, \mbox{\hyperlink{classrrllvm_1_1SBMLInitialValueSymbolResolver_ab7c1e8fae4c828db8ddf0147d2c105b4}{rrllvm\+::\+SBMLInitial\+Value\+Symbol\+Resolver}}, and \mbox{\hyperlink{classrrllvm_1_1ModelDataLoadSymbolResolver_a8f7aa9bf76a44c3cb2f7c91b788d17b5}{rrllvm\+::\+Model\+Data\+Load\+Symbol\+Resolver}}.

\mbox{\Hypertarget{classrrllvm_1_1LoadSymbolResolver_a64c0e7ee5311a610d252dc603e20a94f}\label{classrrllvm_1_1LoadSymbolResolver_a64c0e7ee5311a610d252dc603e20a94f}} 
\index{rrllvm::LoadSymbolResolver@{rrllvm::LoadSymbolResolver}!popCacheBlock@{popCacheBlock}}
\index{popCacheBlock@{popCacheBlock}!rrllvm::LoadSymbolResolver@{rrllvm::LoadSymbolResolver}}
\doxysubsubsection{\texorpdfstring{popCacheBlock()}{popCacheBlock()}}
{\footnotesize\ttfamily virtual size\+\_\+t rrllvm\+::\+Load\+Symbol\+Resolver\+::pop\+Cache\+Block (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Pop a scoped cache block, this clears these values, and any subsequent reads re-\/evaluate the requested symbol. 

Will throw an exception if an empty stack pop is attempted. 

Reimplemented in \mbox{\hyperlink{classrrllvm_1_1LoadSymbolResolverBase_af789e2e8265aa79b6452f521df9f234e}{rrllvm\+::\+Load\+Symbol\+Resolver\+Base}}.

\mbox{\Hypertarget{classrrllvm_1_1LoadSymbolResolver_ab388d2fa6565e68437798bc1d566b29b}\label{classrrllvm_1_1LoadSymbolResolver_ab388d2fa6565e68437798bc1d566b29b}} 
\index{rrllvm::LoadSymbolResolver@{rrllvm::LoadSymbolResolver}!pushCacheBlock@{pushCacheBlock}}
\index{pushCacheBlock@{pushCacheBlock}!rrllvm::LoadSymbolResolver@{rrllvm::LoadSymbolResolver}}
\doxysubsubsection{\texorpdfstring{pushCacheBlock()}{pushCacheBlock()}}
{\footnotesize\ttfamily virtual size\+\_\+t rrllvm\+::\+Load\+Symbol\+Resolver\+::push\+Cache\+Block (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



nested conditionals (or functions?) can push a local cache block, where symbols would be chached. 

These need to be popped as these symbols are not valid outside of the local conditional or scope block. 

Reimplemented in \mbox{\hyperlink{classrrllvm_1_1LoadSymbolResolverBase_a7e60c19319e7c69ce40893709590c5b6}{rrllvm\+::\+Load\+Symbol\+Resolver\+Base}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
llvm/Code\+Gen.\+h\end{DoxyCompactItemize}
