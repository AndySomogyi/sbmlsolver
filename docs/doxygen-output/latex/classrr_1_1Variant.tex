\hypertarget{classrr_1_1Variant}{}\doxysection{rr\+::Variant Class Reference}
\label{classrr_1_1Variant}\index{rr::Variant@{rr::Variant}}


A basic type to hold a variety of data types.  




{\ttfamily \#include $<$\+\_\+\+Variant.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a64c7b2189f8d391527919e46a72402a8}\label{classrr_1_1Variant_a64c7b2189f8d391527919e46a72402a8}} 
enum \mbox{\hyperlink{classrr_1_1Variant_a64c7b2189f8d391527919e46a72402a8}{Type\+Id}} \{ \newline
{\bfseries STRING}
, {\bfseries BOOL}
, {\bfseries INT32}
, {\bfseries UINT32}
, \newline
{\bfseries INT64}
, {\bfseries UINT64}
, {\bfseries FLOAT}
, {\bfseries DOUBLE}
, \newline
{\bfseries CHAR}
, {\bfseries UCHAR}
, {\bfseries EMPTY}
, {\bfseries DOUBLEVECTOR}
 \}
\begin{DoxyCompactList}\small\item\em list of currently supported types that a \mbox{\hyperlink{classrr_1_1Variant}{Variant}} can hold. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a551b6ad03e790d2fca61f95c62b283b7}\label{classrr_1_1Variant_a551b6ad03e790d2fca61f95c62b283b7}} 
\mbox{\hyperlink{classrr_1_1Variant_a64c7b2189f8d391527919e46a72402a8}{Type\+Id}} {\bfseries type} () const
\begin{DoxyCompactList}\small\item\em the current type that this \mbox{\hyperlink{classrr_1_1Variant}{Variant}} is. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}\label{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}} 
{\bfseries Variant} ()
\begin{DoxyCompactList}\small\item\em creates an emtpy variant \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\\mbox{\hyperlink{classrr_1_1Variant_a81b0ca7e57d1985f2e05ef7f0805b1cf}{Variant}} (const T \&val)
\begin{DoxyCompactList}\small\item\em create a new variant from an existing supported data type. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_adeeea17e7e9aa35fd079c3eee2794b4b}\label{classrr_1_1Variant_adeeea17e7e9aa35fd079c3eee2794b4b}} 
{\bfseries Variant} (const char $\ast$str)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a950ad51abe6f9e7ed4bbe865bac93e99}\label{classrr_1_1Variant_a950ad51abe6f9e7ed4bbe865bac93e99}} 
{\bfseries Variant} (const \mbox{\hyperlink{classrr_1_1Variant}{Variant}} \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_a4f276868e91394b494daab09d60f48fb}\label{classrr_1_1Variant_a4f276868e91394b494daab09d60f48fb}} 
{\footnotesize template$<$typename T $>$ }\\\mbox{\hyperlink{classrr_1_1Variant}{Variant}} \& {\bfseries operator=} (const T \&value)
\begin{DoxyCompactList}\small\item\em Assignment operator for assigning POD to Var same as the constructor, this assigns a value to an existing \mbox{\hyperlink{classrr_1_1Variant}{Variant}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classrr_1_1Variant}{Variant}} \& \mbox{\hyperlink{classrr_1_1Variant_ac04cac2d0b4d939f789658bebbb05f21}{operator=}} (const \mbox{\hyperlink{classrr_1_1Variant}{Variant}} \&other)
\begin{DoxyCompactList}\small\item\em Assignment operator. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_a5bfdfef2698dc62678ed6e5b9f807c2a}\label{classrr_1_1Variant_a5bfdfef2698dc62678ed6e5b9f807c2a}} 
virtual {\bfseries $\sim$\+Variant} ()
\begin{DoxyCompactList}\small\item\em clean up any data owned by this object. \end{DoxyCompactList}\item 
const std\+::type\+\_\+info \& \mbox{\hyperlink{classrr_1_1Variant_ab221d80ddd0d06174c61d90e25ebb0d2}{type\+Info}} () const
\begin{DoxyCompactList}\small\item\em get the type id of the stored data type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{classrr_1_1Variant_a7bb371be936601754f61d5285f834352}{convert}} () const
\begin{DoxyCompactList}\small\item\em Convert this variant to a supported data type. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_a1e671df21f20cf4cea3cd97b91d74bad}\label{classrr_1_1Variant_a1e671df21f20cf4cea3cd97b91d74bad}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (std\+::string)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a80fb1e965dafc1d64a72baaf4dfb74a7}\label{classrr_1_1Variant_a80fb1e965dafc1d64a72baaf4dfb74a7}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (long)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_affffce16e5c854be89c5ad19565b662e}\label{classrr_1_1Variant_affffce16e5c854be89c5ad19565b662e}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (bool)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a0c5b814015afebf10133a5040a4ba5dd}\label{classrr_1_1Variant_a0c5b814015afebf10133a5040a4ba5dd}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (float)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a4b997ca2b06a76b4ce2eee7b71a32f02}\label{classrr_1_1Variant_a4b997ca2b06a76b4ce2eee7b71a32f02}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (double)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a7a91de1a107d4c7e2e9fd36955051758}\label{classrr_1_1Variant_a7a91de1a107d4c7e2e9fd36955051758}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (unsigned long)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_ad3c33516ac06d47ad80ce1838a41503d}\label{classrr_1_1Variant_ad3c33516ac06d47ad80ce1838a41503d}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (int)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_aeaecee8f6ff49545b3feb060f4a2fc6b}\label{classrr_1_1Variant_aeaecee8f6ff49545b3feb060f4a2fc6b}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (unsigned int)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a4455d0058d6627a8291c5b7ede89cf1b}\label{classrr_1_1Variant_a4455d0058d6627a8291c5b7ede89cf1b}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (char)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_aaec35f10a7667638c62206c83f090352}\label{classrr_1_1Variant_aaec35f10a7667638c62206c83f090352}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (unsigned char)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_a6cee1990f0e04b644c0cac5af847a67c}\label{classrr_1_1Variant_a6cee1990f0e04b644c0cac5af847a67c}} 
{\bfseries VARIANT\+\_\+\+IMPLICIT\+\_\+\+CONVERT} (std\+::vector$<$ double $>$)
\item 
\mbox{\Hypertarget{classrr_1_1Variant_ab1e6879f232971ab8fa285cf50139f8a}\label{classrr_1_1Variant_ab1e6879f232971ab8fa285cf50139f8a}} 
std\+::string {\bfseries to\+String} () const
\begin{DoxyCompactList}\small\item\em Converts the \mbox{\hyperlink{classrr_1_1Variant}{Variant}} to a std\+::string in JSON format. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classrr_1_1Variant_aae71df98365e03148ca33a3d3f354115}{python\+Repr}} () const
\begin{DoxyCompactList}\small\item\em Convert to Python-\/compatible representation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_a287a173e395dafe75f1631c69f00551a}\label{classrr_1_1Variant_a287a173e395dafe75f1631c69f00551a}} 
bool {\bfseries is\+String} () const
\begin{DoxyCompactList}\small\item\em is this variant a std\+::string. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_ac6e06d899cd97644275c585e22673163}\label{classrr_1_1Variant_ac6e06d899cd97644275c585e22673163}} 
bool {\bfseries is\+Integer} () const
\begin{DoxyCompactList}\small\item\em was an integer stored here. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_ae92df0ebd531b0d0103202676beabfe3}\label{classrr_1_1Variant_ae92df0ebd531b0d0103202676beabfe3}} 
bool {\bfseries is\+Numeric} () const
\begin{DoxyCompactList}\small\item\em is this a numeric type. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_abbaafbb2c10aa25b6879f4a2cd5f85ca}\label{classrr_1_1Variant_abbaafbb2c10aa25b6879f4a2cd5f85ca}} 
bool {\bfseries is\+Bool} () const
\begin{DoxyCompactList}\small\item\em is this a boolean type. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_ad98e0f4d0491e78d4ab7c13d74e2b976}\label{classrr_1_1Variant_ad98e0f4d0491e78d4ab7c13d74e2b976}} 
bool {\bfseries is\+Empty} () const
\begin{DoxyCompactList}\small\item\em true if empty. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_a6b61a4ca6b375886c7cb145ffd910b20}\label{classrr_1_1Variant_a6b61a4ca6b375886c7cb145ffd910b20}} 
bool {\bfseries is\+Signed} () const
\begin{DoxyCompactList}\small\item\em true if this is a signed number. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrr_1_1Variant_ab45d42c136c47493a285d6fc38ba9057}\label{classrr_1_1Variant_ab45d42c136c47493a285d6fc38ba9057}} 
bool {\bfseries is\+Double\+Vector} () const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classrr_1_1Variant}{Variant}} \mbox{\hyperlink{classrr_1_1Variant_abe42f3be24595157e92e255ddf5ef082}{parse}} (const std\+::string \&val)
\begin{DoxyCompactList}\small\item\em Parses the std\+::string which must be in JSON format. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A basic type to hold a variety of data types. 

Unfourtunatly C++ does not have a standard variant type so we have to create one here.

This is a fairly low performance class and is intended soley for infrequent operations such as \mbox{\hyperlink{classrr_1_1Variant}{Variant}} configuration parameters.

If Python support is enabled, this class can convert to and from a Python object.

Usage\+: This class can convert to and from any primitive data type, and some collections types. More type conversions will be added as needed.

To store a value, just assign it, the assignment operator automatically takes care of everything for you\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// store an int:}}
\DoxyCodeLine{\textcolor{keywordtype}{int} i = 23;}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}{Variant}} v = i;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// store a double:}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}{Variant}} v = (double)0.123;}

\end{DoxyCode}


Extraction\+: To retrieve the stored data, uses the convert function, this is templated so it can convert and extract to any type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}{Variant}} v = getSomeVariant();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// to convert to integer:}}
\DoxyCodeLine{\textcolor{keywordtype}{int} i = v.convert<\textcolor{keywordtype}{int}>();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// to convert to std::string:}}
\DoxyCodeLine{std::string s = v.convert<std::string>();}

\end{DoxyCode}


Rationale\+: C++ does not have a built in variant type. Other variant types exist such as boost\+::any and Poco dynamic var. However including the one of these as part of our public wrappers would forever tie us to that particular library, and would impose yet another dependency.

Only very basic variant type support is needed and this class exposes the absolute minimum possible wrappers to support such features, and provides just two methods of getting and storing native C++ types in it.

This is {\itshape currently} implemented by Poco but the implementation is fully opaque and may change in the future. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classrr_1_1Variant_a81b0ca7e57d1985f2e05ef7f0805b1cf}\label{classrr_1_1Variant_a81b0ca7e57d1985f2e05ef7f0805b1cf}} 
\index{rr::Variant@{rr::Variant}!Variant@{Variant}}
\index{Variant@{Variant}!rr::Variant@{rr::Variant}}
\doxysubsubsection{\texorpdfstring{Variant()}{Variant()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rr\+::\+Variant\+::\+Variant (\begin{DoxyParamCaption}\item[{const T \&}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



create a new variant from an existing supported data type. 

This templated constructor can assign any primitive type\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}{Variant}} v = (int)1;}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}{Variant}} v = std::string(\textcolor{stringliteral}{"{}a std::string"{}});}

\end{DoxyCode}
 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classrr_1_1Variant_a7bb371be936601754f61d5285f834352}\label{classrr_1_1Variant_a7bb371be936601754f61d5285f834352}} 
\index{rr::Variant@{rr::Variant}!convert@{convert}}
\index{convert@{convert}!rr::Variant@{rr::Variant}}
\doxysubsubsection{\texorpdfstring{convert()}{convert()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T rr\+::\+Variant\+::convert (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Convert this variant to a supported data type. 

This method will try to perform type coercion, i.\+e. if this variant contains a std\+::string, and it is asked to convert to a int, the std\+::string will be parsed as an int. Similary, doubles will be rounded to int, so forth.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// convert to int:}}
\DoxyCodeLine{\textcolor{keywordtype}{int} i = v.convert<\textcolor{keywordtype}{int}>();}

\end{DoxyCode}
 \mbox{\Hypertarget{classrr_1_1Variant_ac04cac2d0b4d939f789658bebbb05f21}\label{classrr_1_1Variant_ac04cac2d0b4d939f789658bebbb05f21}} 
\index{rr::Variant@{rr::Variant}!operator=@{operator=}}
\index{operator=@{operator=}!rr::Variant@{rr::Variant}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classrr_1_1Variant}{Variant}} \& rr\+::\+Variant\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classrr_1_1Variant}{Variant}} \&}]{other }\end{DoxyParamCaption})}



Assignment operator. 

Assign one variant to another. \mbox{\Hypertarget{classrr_1_1Variant_abe42f3be24595157e92e255ddf5ef082}\label{classrr_1_1Variant_abe42f3be24595157e92e255ddf5ef082}} 
\index{rr::Variant@{rr::Variant}!parse@{parse}}
\index{parse@{parse}!rr::Variant@{rr::Variant}}
\doxysubsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classrr_1_1Variant}{Variant}} rr\+::\+Variant\+::parse (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Parses the std\+::string which must be in JSON format. 

This is a common way to read a \mbox{\hyperlink{classrr_1_1Variant}{Variant}} from a file or create a new one from a std\+::string\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}{Variant}} v = \mbox{\hyperlink{classrr_1_1Variant_abe42f3be24595157e92e255ddf5ef082}{Variant::parse}}(\textcolor{stringliteral}{"{}0.123"{}});}

\end{DoxyCode}
 \mbox{\Hypertarget{classrr_1_1Variant_aae71df98365e03148ca33a3d3f354115}\label{classrr_1_1Variant_aae71df98365e03148ca33a3d3f354115}} 
\index{rr::Variant@{rr::Variant}!pythonRepr@{pythonRepr}}
\index{pythonRepr@{pythonRepr}!rr::Variant@{rr::Variant}}
\doxysubsubsection{\texorpdfstring{pythonRepr()}{pythonRepr()}}
{\footnotesize\ttfamily std\+::string rr\+::\+Variant\+::python\+Repr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Convert to Python-\/compatible representation. 

\begin{DoxyAuthor}{Author}
JKM 
\end{DoxyAuthor}
\mbox{\Hypertarget{classrr_1_1Variant_ab221d80ddd0d06174c61d90e25ebb0d2}\label{classrr_1_1Variant_ab221d80ddd0d06174c61d90e25ebb0d2}} 
\index{rr::Variant@{rr::Variant}!typeInfo@{typeInfo}}
\index{typeInfo@{typeInfo}!rr::Variant@{rr::Variant}}
\doxysubsubsection{\texorpdfstring{typeInfo()}{typeInfo()}}
{\footnotesize\ttfamily const std\+::type\+\_\+info \& rr\+::\+Variant\+::type\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



get the type id of the stored data type. 

This will let you check what kind of data is strored in this variant.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// to check if this is an integer:}}
\DoxyCodeLine{\mbox{\hyperlink{classrr_1_1Variant_a48f0736e18b6463303047b46cccca550}{Variant}} v = ...}
\DoxyCodeLine{if (v.type() == \textcolor{keyword}{typeid}(\textcolor{keywordtype}{int}))}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}its an int"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// to check if its a std::string:}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (v.type() == \textcolor{keyword}{typeid}(std::string))}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}ints a std::string"{}};}

\end{DoxyCode}
 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\+\_\+\+Variant.\+h\item 
\+\_\+\+Variant.\+cpp\end{DoxyCompactItemize}
