# Starter pipeline 
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml
name: $(Date:yyyyMMdd)$(Rev:.r)

# specific branch build
trigger:
  branches:
    include:
    - develop
    - release

variables:
  SOURCE_DIR: '$(System.DefaultWorkingDirectory)' # eg /home/vsts/work/1/s
  BUILD_DIR: '$(SOURCE_DIR)/build'
  INSTALL_DIR: '$(SOURCE_DIR)/roadrunner-$(Agent.OS)'
  LLVM_INSTALL_PREFIX: '$(SOURCE_DIR)/llvm' # e.g./home/vsts/work/1
  DEPS_INSTALL_PREFIX: '$(SOURCE_DIR)/libroadrunner-deps' # e.g./home/vsts/work/1
  SWIG_SOURCE_DIR: '$(SOURCE_DIR)/swig'
  SWIG_INSTALL_PREFIX: '$(SWIG_SOURCE_DIR)/install-azure'
  SWIG_EXECUTABLE: '$(SWIG_INSTALL_PREFIX)/bin/swig'

stages:
########################################################################
# MacOS Build
#
  - stage: MacBuildRoadrunnerCpp
    dependsOn: []
    jobs:
      - job: MacBuildRoadrunnerCpp
        timeoutInMinutes: "0"
        displayName: MacBuildRoadrunnerCpp
        continueOnError: "false"
        pool:
          vmImage: 'macOS-11'
        strategy:
          matrix:
            64-bit Mac Release:
              BuildType: Release
              LLVM_DOWNLOAD_LINK: 'https://github.com/sys-bio/llvm-13.x/releases/download/llvmorg-13.0.0/llvm-13.x-macosx_11_7_x86_64.zip'
            64-bit Mac Debug:
              BuildType: Debug
              LLVM_DOWNLOAD_LINK: 'https://github.com/sys-bio/llvm-13.x/releases/download/llvmorg-13.0.0/llvm-13.x-macosx_11_7_x86_64.zip'
        variables:
          LLVM_CACHE: 'false'
          PythonName: 'py39'
          LLVM_CONFIG_EXECUTABLE :  '$(LLVM_INSTALL_PREFIX)/bin/llvm-config'
          MinicondaRoot : '/usr/local/miniconda'
          PythonRoot: '$(MinicondaRoot)/envs/$(PythonName)'
          PythonLibDir: '$(PythonRoot)/lib'
          PythonExecutable: '$(PythonRoot)/bin/python'
          CondaExecutable: '$(MinicondaRoot)/condabin/conda'
          PipExecutable: '$(PythonRoot)/bin/pip'
        steps:
          - checkout: self
            submodules: recursive
          - script: |
              echo "SOURCE_DIR $(SOURCE_DIR)"
              echo "BUILD_DIR $(BUILD_DIR)"
              echo "INSTALL_DIR $(INSTALL_DIR)"
              echo "LLVM_INSTALL_PREFIX $(LLVM_INSTALL_PREFIX)"
              echo "DEPS_INSTALL_PREFIX $(DEPS_INSTALL_PREFIX)"
              echo "Build.DefinitionName $(Build.DefinitionName)"
              echo "System.DefinitionId	 $(System.DefinitionId)"
              echo "Agent.OS $(Agent.OS)"

              echo "System.AccessToken  $(System.AccessToken)"
              echo "System.CollectionId $(System.CollectionId)"
              echo "System.CollectionUri  $(System.CollectionUri)"
              echo "System.DefaultWorkingDirectory  $(System.DefaultWorkingDirectory)"
              echo "System.DefinitionId $(System.DefinitionId)"
              echo "System.HostType $(System.HostType)"
              echo "System.JobAttempt $(System.JobAttempt)"
              echo "System.JobDisplayName $(System.JobDisplayName)"
              echo "System.JobId  $(System.JobId)"
              echo "System.JobName  $(System.JobName)"
              echo "System.PhaseAttempt $(System.PhaseAttempt)"
              echo "System.PhaseDisplayName $(System.PhaseDisplayName)"
              echo "System.PhaseName  $(System.PhaseName)"
              echo "System.StageAttempt $(System.StageAttempt)"
              echo "System.StageDisplayName $(System.StageDisplayName)"
              echo "System.StageName  $(System.StageName)"
              echo "System.PullRequest.IsFork $(System.PullRequest.IsFork)"
              echo "System.PullRequest.PullRequestId $(System.PullRequest.PullRequestId)"
              echo "System.PullRequest.PullRequestNumber $(System.PullRequest.PullRequestNumber)"
              echo "System.PullRequest.SourceBranch $(System.PullRequest.SourceBranch)"
              echo "System.PullRequest.SourceRepositoryURI $(System.PullRequest.SourceRepositoryURI)"
              echo "System.PullRequest.TargetBranch $(System.PullRequest.TargetBranch)"
              echo "System.TeamFoundationCollectionUri $(System.TeamFoundationCollectionUri)"
              echo "System.TeamProject $(System.TeamProject)"
              echo "System.TeamProjectId $(System.TeamProjectId)"
              echo "TF_BUILD $(TF_BUILD)"
            displayName: Print Variables
          - script: |
              mkdir $(DEPS_INSTALL_PREFIX)
            displayName: Make Directories

          - bash: echo "##vso[task.prependpath]$CONDA/bin"
            displayName: Add conda to PATH

          # On Hosted macOS, the agent user doesn't have ownership of Miniconda's installation directory/
          # We need to take ownership if we want to update conda or install packages globally
          - bash: sudo chown -R $USER $CONDA
            displayName: Take ownership of conda installation
          - script: |
              echo "cd to source dir: $(SOURCE_DIR)"
              cd $(SOURCE_DIR)
              echo "ls"
              ls
              echo "which conda"
              which conda
              echo "cd miniconda root: $(MinicondaRoot)"
              cd $(MinicondaRoot)
              echo "ls"
              ls
              $(CondaExecutable) create --quiet --yes --name $(PythonName) python=$(PythonVersion) -c conda-forge
            displayName: InstallCondaEnv

          - script: |
              $(PipExecutable) install requests
              $(PythonExecutable) ./.azurepipelines/getLLVM.py $(LLVM_DOWNLOAD_LINK) $(LLVM_INSTALL_PREFIX)
              echo "give execute permissions to llvm-config using chmod 777 *"
              cd $(LLVM_INSTALL_PREFIX)/bin
              chmod 777 llvm-config
            displayName: "Get LLVM"
#            condition: ne(variables.LLVM_CACHE, 'true')


          - task: DownloadPipelineArtifact@2
            # In this task we go and grab the build artefacts from
            # the libroadrunner-dependencies package
            inputs:
              source: 'specific'
              project: 'libroadrunner-deps'
              # pipeline is found in the url when looking at azure in browser.
              # for example, it looks like this:
              # - https://dev.azure.com/TheRoadrunnerProject/libroadrunner-deps/_build?definitionId=9
              pipeline: 9
              runVersion: 'latest'
              artifact: libroadrunner-deps-$(Agent.OS)-$(BuildType)
              path: $(DEPS_INSTALL_PREFIX)
            displayName: Download libroadrunner-deps install artifacts
          - script: |
              echo "$(DEPS_INSTALL_PREFIX)"
              echo "cd to $(DEPS_INSTALL_PREFIX)"
              cd $(DEPS_INSTALL_PREFIX)
              echo "ls: "
              ls
              echo "moving contents of $(DEPS_INSTALL_PREFIX)/install to  $(DEPS_INSTALL_PREFIX)"
              mv $(DEPS_INSTALL_PREFIX)/install-azure/$(BuildType)/** .
              rm -r $(DEPS_INSTALL_PREFIX)/install-azure
              ls
            displayName: Move Dependencies
          - script: |
              echo "Configuring roadrunner"
              echo "mkdir build directory: $(BUILD_DIR)"
              mkdir $(BUILD_DIR)
              echo "CD to build dir: $(BUILD_DIR)"
              cd $(BUILD_DIR)
              cmake -DLLVM_INSTALL_PREFIX=$(LLVM_INSTALL_PREFIX) -DRR_DEPENDENCIES_INSTALL_PREFIX=$(DEPS_INSTALL_PREFIX) -DBUILD_TESTS=ON -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIR) -DBUILD_RR_PLUGINS=ON -DBUILD_RR_CAPI=ON -DCMAKE_BUILD_TYPE=$(BuildType) -DCMAKE_OSX_ARCHITECTURES="x86_64" ..
            displayName: Run CMake Configure Command
          - script: |
              echo "less -N $(BUILD_DIR)/source/CMakeFiles/roadrunner.dir/build.make"
              less -N "$(BUILD_DIR)/source/CMakeFiles/roadrunner.dir/build.make"
              echo "Building roadrunner"
              echo "cd to build dir"
              cd $(BUILD_DIR)
              cmake --build . --target install --config $(BuildType) -j 12
            displayName: Run CMake Build Command
          - script: |
              echo "cd to build dir $(BUILD_DIR)"
              cd $(BUILD_DIR)
              if [ "$(BuildType)" == "Release" ]; then
                ctest --verbose --extra-verbose --progress
              fi
            displayName: RunCTest
          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/**'
              targetFolder: $(Build.ArtifactStagingDirectory)
            displayName: Copy to Staging Area
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: roadrunner-MacOS11-$(BuildType)
            displayName: Publish

  - stage: MacBuildRoadrunnerPython
    dependsOn: []
    jobs:
      - job: MacBuildRoadrunnerPython
        timeoutInMinutes: "0"
        displayName: MacBuildRoadrunnerPython
        continueOnError: "false"
        pool:
          vmImage: 'macOS-11'
        strategy:
          matrix:
            py38:
              PythonVersion: 3.8
              PythonName: py38
            py39:
              PythonVersion: 3.9
              PythonName: py39
            py310:
              PythonVersion: 3.10
              PythonName: py310
            py311:
              PythonVersion: 3.11
              PythonName: py311
        variables:
          MinicondaRoot : '/usr/local/miniconda'
          PythonRoot: '$(MinicondaRoot)/envs/$(PythonName)'
          PythonLibDir: '$(PythonRoot)/lib'
          PythonExecutable: '$(PythonRoot)/bin/python'
          CondaExecutable: '$(MinicondaRoot)/condabin/conda'
          PipExecutable: '$(PythonRoot)/bin/pip'
          SWIG_CACHE: 'false'
          MINICONDA_CACHE: 'false'
          LLVM_CACHE: 'false'
          LLVM_DOWNLOAD_LINK: 'https://github.com/sys-bio/llvm-13.x/releases/download/llvmorg-13.0.0/llvm-13.x-macosx_11_7_x86_64.zip'
        steps:
          - checkout: self
            submodules: recursive
          - bash: echo "##vso[task.prependpath]$CONDA/bin"
            displayName: Add conda to PATH

          # On Hosted macOS, the agent user doesn't have ownership of Miniconda's installation directory/
          # We need to take ownership if we want to update conda or install packages globally
          - bash: sudo chown -R $USER $CONDA
            displayName: Take ownership of conda installation
          - script: |
              echo "cd to source dir: $(SOURCE_DIR)"
              cd $(SOURCE_DIR)
              echo "ls"
              ls
              echo "which conda"
              which conda
              echo "cd miniconda root: $(MinicondaRoot)"
              cd $(MinicondaRoot)
              echo "ls"
              ls
              $(CondaExecutable) create --quiet --yes --name $(PythonName) python=$(PythonVersion) -c conda-forge
              echo "running: $(PipExecutable) install -r $(SOURCE_DIR)/test-requirements.txt"
              $(PipExecutable) install -r $(SOURCE_DIR)/test-requirements.txt
            displayName: InstallCondaEnv
          - script: |
              which conda
              which python
              echo "PythonVersion $(PythonVersion)"
              echo "PythonName $(PythonName)"
              echo "MinicondaRoot $(MinicondaRoot)"
              echo "PythonRoot $(PythonRoot)"
              echo "PythonLibDir $(PythonLibDir)"
              echo "CondaExecutable $(CondaExecutable)"
            displayName: PrintPythonVariables
          - script: |
              mkdir $(DEPS_INSTALL_PREFIX)
            displayName: Make Directories
          - script: |
              $(PipExecutable) install requests
              $(PythonExecutable) ./.azurepipelines/getLLVM.py $(LLVM_DOWNLOAD_LINK) $(LLVM_INSTALL_PREFIX)
              echo "give execute permissions to llvm-config using chmod 777 *"
              cd $(LLVM_INSTALL_PREFIX)/bin
              chmod 777 llvm-config
            displayName: "Get LLVM"
#            condition: ne(variables.LLVM_CACHE, 'true')


          - task: DownloadPipelineArtifact@2
            inputs:
              source: 'specific'
              project: 'libroadrunner-deps'
              pipeline: 9
              runVersion: 'latest'
              artifact: libroadrunner-deps-$(Agent.OS)-Release
              path: $(DEPS_INSTALL_PREFIX)
            displayName: Download libroadrunner-deps install artifacts
          - script: |
              echo "$(DEPS_INSTALL_PREFIX)"
              echo "cd to $(DEPS_INSTALL_PREFIX)"
              cd $(DEPS_INSTALL_PREFIX)
              echo "ls: "
              ls
              echo "moving contents of $(DEPS_INSTALL_PREFIX)/install to  $(DEPS_INSTALL_PREFIX)"
              mv $(DEPS_INSTALL_PREFIX)/install-azure/Release/** .
              rm -r $(DEPS_INSTALL_PREFIX)/install-azure
              ls
            displayName: Move Dependencies
#          - task: Cache@2
#            inputs:
#              key: "Swig | $(Agent.OS)"
#              path: $(SWIG_INSTALL_PREFIX)
#              cacheHitVar: SWIG_CACHE
#            displayName: Cache Swig-4.0.2
          - script: |
              echo "installing pcre"
              brew install pcre pcre2
              mkdir -p $(SWIG_SOURCE_DIR)
              echo "cd to swig source dir: $(SWIG_SOURCE_DIR)"
              cd $(SWIG_SOURCE_DIR)
              echo "ls"
              ls -lh
              wget -q https://sourceforge.net/projects/swig/files/swig/swig-4.0.2/swig-4.0.2.tar.gz $(SWIG_SOURCE_DIR)
              tar -xf swig-4.0.2.tar.gz
              ls -lh
              echo "Copying swig content from swig-4.0.2 to SWIG_SOURCE_DIR"
              mv swig-4.0.2/** $(SWIG_SOURCE_DIR)
              echo "ls"
              ls -lh
              echo "ls in swig source dir $(SWIG_SOURCE_DIR)"
              ls -lh
              ./configure --prefix=$(SWIG_INSTALL_PREFIX)
              make -j 12
              make install
              echo "ls in swig source dir $(SWIG_SOURCE_DIR)"
              ls
              echo "cd to swig install dir: $(SWIG_INSTALL_PREFIX)"
              cd $(SWIG_INSTALL_PREFIX)
              echo "ls from SWIG_INSTALL_PREFIX: $(SWIG_INSTALL_PREFIX)"
              ls
              if [ ! -f "$(SWIG_EXECUTABLE)" ]; then
                echo "did not locate swig executable, exiting"
                exit
              fi
            displayName: Install Swig
            condition: ne(variables.SWIG_CACHE, 'true')
          - script: |
              mkdir -p $(SOURCE_DIR)
              mkdir -p $(BUILD_DIR)
              mkdir -p $(INSTALL_DIR)
            displayName: Make directories
          - script: |
              echo "cd to source dir: $(SOURCE_DIR)"
              cd $(SOURCE_DIR)
              echo "ls"
              ls
              echo "Variable PythonRoot set to $(PythonRoot)"
              echo "Checking to see whether I can CD to PythonRoot"
              cd $(PythonRoot)
              echo "cd to build dir $(BUILD_DIR)"
              cd $(BUILD_DIR)
              ls
              export LD_LIBRARY_PATH=$(PythonLibDir)
              cmake -DLLVM_INSTALL_PREFIX=$(LLVM_INSTALL_PREFIX) -DRR_DEPENDENCIES_INSTALL_PREFIX=$(DEPS_INSTALL_PREFIX) -DBUILD_TESTS=ON -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIR) -DBUILD_RR_PLUGINS=ON -DBUILD_RR_CAPI=ON -DCMAKE_BUILD_TYPE=Release -DBUILD_PYTHON=ON -DPython_ROOT_DIR=$(PythonRoot) -DSWIG_EXECUTABLE=$(SWIG_EXECUTABLE) -DCMAKE_OSX_ARCHITECTURES="x86_64" ..
              cmake --build . --target install --config Release -j 12
            displayName: BuildRoadrunnerWithPython
          - script: |
              echo "LD_LIBRARY_PATH $LD_LIBRARY_PATH"
              export LD_LIBRARY_PATH=$(PythonLibDir)
              echo "cd to isntall dir: $(INSTALL_DIR)"
              cd $(INSTALL_DIR)
              echo "ls in install dir"
              ls
              #$(PythonExecutable) site-packages/roadrunner/testing/__main__.py
              echo "Switching to build dir: $(BUILD_DIR)"
              cd $(BUILD_DIR)
              echo "ctest --output-on-failure --verbose --extra-verbose --tests-regex python_tests*"
              ctest --output-on-failure --verbose --extra-verbose --tests-regex python_tests*
            displayName: RunPythonTests
          - script: |
              # todo workout whether the top few lines are needed now I'm using $(PythonExecutable)
              #eval "$(conda shell.bash hook)"
              #source activate $(PythonName)
              #echo "which python: $(which python)"
              #echo "which conda: $(which conda)"
              #python_exe="$(which python)"
              echo "cd to isntall dir: $(INSTALL_DIR)"
              cd $(INSTALL_DIR)
              echo "ls in install dir"
              ls
              echo "$(PythonExecutable) setup.py bdist_wheel"
              $(PythonExecutable) setup.py bdist_wheel
              echo "$(PythonExecutable) setup_rrplugins.py bdist_wheel"
              $(PythonExecutable) setup_rrplugins.py bdist_wheel
            displayName: Generate pip wheel

          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/**'
              targetFolder: $(Build.ArtifactStagingDirectory)/roadrunner-MacOS11-$(PythonName)
            displayName: Copy Install Tree to Staging Area
          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/dist/**'
              targetFolder: $(Build.ArtifactStagingDirectory)/pip-wheels
            displayName: Copy Pip Wheels to Staging Area
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: roadrunner-MacOS11-$(PythonName)
            displayName: Publish Pip Wheels Artifacts

########################################################################
# Windows Build
#
  - stage: WindowsBuildRoadrunnerCpp
    dependsOn: []
    jobs:
      - job: WindowsBuildRoadrunnerCpp
        timeoutInMinutes: "0"
        displayName: WindowsBuildRoadrunnerCpp
        continueOnError: "false"
        pool:
          vmImage: 'windows-2019'
        strategy:
          matrix:
            64-bit Windows Release:
              BuildType: Release
              BuildTests: ON
              LLVM_DOWNLOAD_LINK: 'https://github.com/sys-bio/llvm-13.x/releases/download/llvmorg-13.0.0/llvm-13.x-msvc2022-x64-rel.zip'
            64-bit Windows Debug:
              BuildType: Debug
              BuildTests: OFF
              LLVM_DOWNLOAD_LINK: 'https://github.com/sys-bio/llvm-13.x/releases/download/llvmorg-13.0.0/llvm-13.x-msvc2022-x64-dbg.zip'
        variables:
          LLVM_CACHE: 'false'
          MinicondaRoot : 'C:\Miniconda'
          PythonName: 'py39'
          PythonVersion: '3.9'
          PythonRoot: '$(MinicondaRoot)\envs\$(PythonName)'
          PythonLibDir: '$(PythonRoot)\Lib'
          PythonScriptsDir: '$(PythonRoot)\Scripts'
          PythonExecutable: '$(PythonRoot)\python.exe'
          PipExecutable: '$(PythonScriptsDir)\pip.exe'

        steps:
          - checkout: self
            submodules: recursive
          - powershell: |
              echo "SOURCE_DIR $(SOURCE_DIR)"
              echo "BUILD_DIR $(BUILD_DIR)"
              echo "INSTALL_DIR $(INSTALL_DIR)"
              echo "LLVM_INSTALL_PREFIX $(LLVM_INSTALL_PREFIX)"
              echo "DEPS_INSTALL_PREFIX $(DEPS_INSTALL_PREFIX)"
              echo "Build.DefinitionName $(Build.DefinitionName)"
              echo "System.DefinitionId	 $(System.DefinitionId)"
              echo "Agent.OS $(Agent.OS)"

              echo "System.AccessToken  $(System.AccessToken)"
              echo "System.CollectionId $(System.CollectionId)"
              echo "System.CollectionUri  $(System.CollectionUri)"
              echo "System.DefaultWorkingDirectory  $(System.DefaultWorkingDirectory)"
              echo "System.DefinitionId $(System.DefinitionId)"
              echo "System.HostType $(System.HostType)"
              echo "System.JobAttempt $(System.JobAttempt)"
              echo "System.JobDisplayName $(System.JobDisplayName)"
              echo "System.JobId  $(System.JobId)"
              echo "System.JobName  $(System.JobName)"
              echo "System.PhaseAttempt $(System.PhaseAttempt)"
              echo "System.PhaseDisplayName $(System.PhaseDisplayName)"
              echo "System.PhaseName  $(System.PhaseName)"
              echo "System.StageAttempt $(System.StageAttempt)"
              echo "System.StageDisplayName $(System.StageDisplayName)"
              echo "System.StageName  $(System.StageName)"
              echo "System.TeamProject $(System.TeamProject)"
              echo "System.TeamProjectId $(System.TeamProjectId)"
              echo "TF_BUILD $(TF_BUILD)"
            displayName: Print Variables
          - powershell: |
              mkdir $(LLVM_INSTALL_PREFIX)
              mkdir $(DEPS_INSTALL_PREFIX)
            displayName: Make Directories

          - powershell: Write-Host "##vso[task.prependpath]$env:CONDA\Scripts"
            displayName: Add conda to PATH
          - powershell: |
              where.exe conda
              where.exe python
              echo "PythonVersion $(PythonVersion)"
              echo "PythonName $(PythonName)"
              echo "MinicondaRoot $(MinicondaRoot)"
              echo "PythonRoot $(PythonRoot)"
              echo "PythonLibDir $(PythonLibDir)"
            displayName: PrintPythonVariables

#          - task: Cache@2
#            inputs:
#              key: "llvm | $(Agent.OS)"
#              path: $(LLVM_INSTALL_PREFIX)
#              cacheHitVar: LLVM_CACHE

          - script: |
              echo "Creating new conda environment"
              conda create --quiet --yes --name $(PythonName) python=$(PythonVersion)
              echo "pip upgrade:"
              $(PipExecutable) install --upgrade pip
              echo "pip help:"
              $(PipExecutable) install --help
              echo "$(PipExecutable) install requests"
              $(PipExecutable) install requests
              echo "$(PipExecutable) install numpy"
              $(PipExecutable) install numpy
            displayName: "Setup conda and get NumPy"

          - script: |
              echo "$(PythonExecutable) .\.azurepipelines\getLLVM.py $(LLVM_DOWNLOAD_LINK) $(LLVM_INSTALL_PREFIX)"
              $(PythonExecutable) .\.azurepipelines\getLLVM.py $(LLVM_DOWNLOAD_LINK) $(LLVM_INSTALL_PREFIX)
            displayName: "Get LLVM"
            condition: ne(variables.LLVM_CACHE, 'true')

          - task: DownloadPipelineArtifact@2
            inputs:
              source: 'specific'
              project: 'libroadrunner-deps'
              pipeline: 9
              runVersion: 'latest'
              artifact: libroadrunner-deps-$(Agent.OS)-$(BuildType)
              path: $(DEPS_INSTALL_PREFIX)
            displayName: Download libroadrunner-deps install artifacts
          - powershell: |
              echo "$(DEPS_INSTALL_PREFIX)"
              echo "cd to $(DEPS_INSTALL_PREFIX)"
              cd $(DEPS_INSTALL_PREFIX)
              echo "ls: "
              ls
              echo "moving contents of $(DEPS_INSTALL_PREFIX)/install to  $(DEPS_INSTALL_PREFIX)"
              mv $(DEPS_INSTALL_PREFIX)/install-azure/$(BuildType)/** .
              rm -R $(DEPS_INSTALL_PREFIX)/install-azure
              ls
            displayName: Move Dependencies
          - powershell: |
              echo "Configuring roadrunner"
              echo "mkdir build directory: $(BUILD_DIR)"
              mkdir $(BUILD_DIR)
              echo "CD to build dir: $(BUILD_DIR)"
              cd $(BUILD_DIR)
              cmake -DLLVM_INSTALL_PREFIX=$(LLVM_INSTALL_PREFIX) -DRR_DEPENDENCIES_INSTALL_PREFIX=$(DEPS_INSTALL_PREFIX) -DBUILD_TESTS=$(BuildTests) -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIR) -DBUILD_RR_PLUGINS=ON -DBUILD_RR_CAPI=ON -DCMAKE_BUILD_TYPE=$(BuildType) ..
            displayName: Run CMake Configure Command
          - powershell: |
              echo "Building roadrunner"
              echo "cd to build dir"
              cd $(BUILD_DIR)
              cmake --build . --target install --config $(BuildType) -j 12
            displayName: Run CMake Build Command
          - powershell: |
              echo "cd to build dir $(BUILD_DIR)"
              cd $(BUILD_DIR)
              if ('$(BuildType)' -eq "Release"){
                ctest --verbose --extra-verbose --progress
              }
            displayName: RunCTest
          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/**'
              targetFolder: $(Build.ArtifactStagingDirectory)
            displayName: Copy to Staging Area
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: roadrunner-$(Agent.OS)-$(BuildType)
            displayName: Publish

  - stage: WindowsBuildRoadrunnerPython
    dependsOn: []
    jobs:
      - job: WindowsBuildRoadrunnerPython
        timeoutInMinutes: "0"
        displayName: WindowsBuildRoadrunnerPython
        continueOnError: "false"
        pool:
          vmImage: 'windows-2019'
        strategy:
          matrix:
            py38:
              PythonVersion: 3.8
              PythonName: py38
            py39:
              PythonVersion: 3.9
              PythonName: py39
            py310:
              PythonVersion: 3.10
              PythonName: py310
            py311:
              PythonVersion: 3.11
              PythonName: py311
        variables:
          MinicondaRoot : 'C:\Miniconda'
          PythonRoot: '$(MinicondaRoot)\envs\$(PythonName)'
          PythonLibDir: '$(PythonRoot)\Lib'
          PythonScriptsDir: '$(PythonRoot)\Scripts'
          PythonExecutable: '$(PythonRoot)\python.exe'
          PipExecutable: '$(PythonScriptsDir)\pip.exe'

          # override the variable for swigwin since swig exe is in different place
          # on windows build compared to mac and linux
          SWIG_EXECUTABLE: '$(SWIG_INSTALL_PREFIX)/swig.exe'
          SWIG_CACHE: 'false'
          LLVM_CACHE: 'false'
          LLVM_DOWNLOAD_LINK: 'https://github.com/sys-bio/llvm-13.x/releases/download/llvmorg-13.0.0/llvm-13.x-win32-rel.zip'
        steps:
          - checkout: self
            submodules: recursive
          - powershell: Write-Host "##vso[task.prependpath]$env:CONDA\Scripts"
            displayName: Add conda to PATH
          - powershell: |
              where.exe conda
              where.exe python
              # conda update conda -y -c conda-forge
              conda install numpy
              conda install python=3.11 -c conda-forge
              conda --version
              echo "PythonVersion $(PythonVersion)"
              echo "PythonName $(PythonName)"
              echo "MinicondaRoot $(MinicondaRoot)"
              echo "PythonRoot $(PythonRoot)"
              echo "PythonLibDir $(PythonLibDir)"
            displayName: "Update conda and print vars"
          - powershell: |
              mkdir -p $(LLVM_INSTALL_PREFIX)
              mkdir -p $(SWIG_INSTALL_PREFIX)
              mkdir -p $(DEPS_INSTALL_PREFIX)
              mkdir -p $(INSTALL_DIR)
              mkdir -p $(BUILD_DIR)
            displayName: Make Directories
          - task: Cache@2
            inputs:
              key: "llvm | $(Agent.OS)"
              path: $(LLVM_INSTALL_PREFIX)
              cacheHitVar: LLVM_CACHE
          - script: |
              echo "Creating new conda environment"
              conda create --quiet --yes --name $(PythonName) python=$(PythonVersion) -c conda-forge
              echo "pip help:"
              $(PipExecutable) install --help

              echo "pip install requests:"
              $(PipExecutable) install requests
              $(PipExecutable) install numpy
            displayName: "Setup conda"

          - script: |
              $(PythonExecutable) ./.azurepipelines/getLLVM.py $(LLVM_DOWNLOAD_LINK) $(LLVM_INSTALL_PREFIX)
            displayName: "Get LLVM"
            condition: ne(variables.LLVM_CACHE, 'true')

          - task: DownloadPipelineArtifact@2
            inputs:
              source: 'specific'
              project: 'libroadrunner-deps'
              pipeline: 9
              runVersion: 'latest'
              artifact: libroadrunner-deps-$(Agent.OS)-Release
              path: $(DEPS_INSTALL_PREFIX)
            displayName: Download libroadrunner-deps install artifacts
          - powershell: |
              echo "$(DEPS_INSTALL_PREFIX)"
              echo "cd to $(DEPS_INSTALL_PREFIX)"
              cd $(DEPS_INSTALL_PREFIX)
              echo "ls: "
              ls
              echo "moving contents of $(DEPS_INSTALL_PREFIX)/install to  $(DEPS_INSTALL_PREFIX)"
              mv $(DEPS_INSTALL_PREFIX)/install-azure/Release/** .
              rm -r $(DEPS_INSTALL_PREFIX)/install-azure
              ls
            displayName: Move Dependencies
          - task: Cache@2
            inputs:
              key: "Swig | $(Agent.OS)"
              path: $(SWIG_INSTALL_PREFIX)
              cacheHitVar: SWIG_CACHE
            displayName: Cache Swig-4.0.2
          - powershell: |
              echo "make swig source dir if not exists"
              [System.IO.Directory]::CreateDirectory('$(SWIG_SOURCE_DIR)')
              echo "cd to swig source dir: $(SWIG_SOURCE_DIR)"
              cd $(SWIG_SOURCE_DIR)
              echo "ls"
              ls
              echo "Invoke-WebRequest"
              # note: default user agent does not follow sourceforge redirect.
              Invoke-WebRequest -Uri https://downloads.sourceforge.net/project/swig/swigwin/swigwin-4.0.2/swigwin-4.0.2.zip -OutFile swigwin-4.0.2.zip  -UserAgent [Microsoft.PowerShell.Commands.PSUserAgent]::FireFox
              echo "ls"
              ls
              echo "Expand-Archive"
              Expand-Archive swigwin-4.0.2.zip -Destination $(SWIG_INSTALL_PREFIX)
              echo "ls"
              ls
              echo "CD to swig install prefix $(SWIG_INSTALL_PREFIX)"
              cd $(SWIG_INSTALL_PREFIX)
              echo "ls"
              ls
              echo "cd swigwwin-4.0.2"
              cd swigwin-4.0.2
              echo " moving contents of swigwin-4.0.2 to .."
              mv * ..
              cd ..
              rm -R swigwin-4.0.2
              echo "ls"
              ls
              # Note: swig is already built when we download on windows.
            displayName: Install Swig
            # this condition ensures this task only gets executed when swig cache does not exist
            # Note, this may cause a problem if we ever update swig. In this case change the value of the cache key
            condition: ne(variables.SWIG_CACHE, 'true')
          - powershell: |
              echo "where.exe conda"
              where.exe conda
              echo "where.exe python"
              where.exe python
              echo "Variable PythonRoot set to $(PythonRoot)"
              echo "cd to source dir: $(SOURCE_DIR)"
              cd $(SOURCE_DIR)
              echo "ls"
              ls
              echo "Creating new conda environment"
              conda create --quiet --yes --name $(PythonName) python=$(PythonVersion) -c conda-forge
              echo "pip help:"
              $(PipExecutable) install --help
              echo "$(PipExecutable) install -q -r $(SOURCE_DIR)/test-requirements.txt and requirements.txt"
              $(PipExecutable) install -q -r $(SOURCE_DIR)/test-requirements.txt
              $(PipExecutable) install -q -r $(SOURCE_DIR)/requirements.txt
              $ENV:PATH="$ENV:PATH;$(PythonScriptsDir)"
              echo "cd to build dir $(BUILD_DIR)"
              cd $(BUILD_DIR)
              ls
              echo "cmake -DLLVM_INSTALL_PREFIX=$(LLVM_INSTALL_PREFIX) -DRR_DEPENDENCIES_INSTALL_PREFIX=$(DEPS_INSTALL_PREFIX) -DBUILD_TESTS=ON -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIR) -DBUILD_RR_PLUGINS=ON -DBUILD_RR_CAPI=ON -DCMAKE_BUILD_TYPE=Release -DBUILD_PYTHON=ON -DPython_ROOT_DIR=$(PythonRoot) -DSWIG_EXECUTABLE=$(SWIG_EXECUTABLE) .."
              cmake -DLLVM_INSTALL_PREFIX=$(LLVM_INSTALL_PREFIX) -DRR_DEPENDENCIES_INSTALL_PREFIX=$(DEPS_INSTALL_PREFIX) -DBUILD_TESTS=ON -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIR) -DBUILD_RR_PLUGINS=ON -DBUILD_RR_CAPI=ON -DCMAKE_BUILD_TYPE=Release -DBUILD_PYTHON=ON -DPython_ROOT_DIR=$(PythonRoot) -DSWIG_EXECUTABLE=$(SWIG_EXECUTABLE) ..
              echo "cmake --build . --target install --config Release -j 12"
              cmake --build . --target install --config Release -j 12
            displayName: BuildRoadrunnerWithPython
          - powershell: |
              echo "cd to isntall dir: $(INSTALL_DIR)"
              cd $(INSTALL_DIR)
              echo "python exe $(PythonExecutable)"
              echo "ls in install dir"
              ls
              #$(PythonExecutable) site-packages/roadrunner/testing/__main__.py

              echo "Switching to build dir: $(BUILD_DIR)"
              cd $(BUILD_DIR)
              echo "ctest --output-on-failure --verbose --extra-verbose --tests-regex python_tests*"
              ctest -C Release --output-on-failure --verbose --extra-verbose --tests-regex python_tests*
            displayName: RunPythonTests
          - powershell: |
              echo "cd to isntall dir: $(INSTALL_DIR)"
              cd $(INSTALL_DIR)
              echo "ls in install dir"
              ls
              $(PythonExecutable) setup.py bdist_wheel
              $(PythonExecutable) setup_rrplugins.py bdist_wheel
            displayName: Generate pip wheel

          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/**'
              targetFolder: $(Build.ArtifactStagingDirectory)/roadrunner-Windows2019-$(PythonName)
            displayName: Copy Install Tree to Staging Area
          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/dist/**'
              targetFolder: $(Build.ArtifactStagingDirectory)/pip-wheels
            displayName: Copy Pip Wheels to Staging Area
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: roadrunner-Windows2019-$(PythonName)
            displayName: Publish Pip Wheels Artifacts

########################################################################
# Ubuntu Build
#
  - stage: UbuntuBuildRoadrunnerCpp
    dependsOn: [ ]
    jobs:
      - job: UbuntuBuildRoadrunnerCpp
        timeoutInMinutes: "0"
        displayName: UbuntuBuildRoadrunnerCpp
        continueOnError: "false"
        pool:
          vmImage: 'Ubuntu-20.04'
        strategy:
          matrix:
            64-bit Linux Release:
              BuildType: Release
              BuildDocs: ON
            64-bit Linux Debug:
              BuildType: Debug
              BuildDocs: OFF
        variables:
          MinicondaRoot : '/usr/share/miniconda'
          PythonRoot: '$(MinicondaRoot)/'
          PythonLibDir: '$(PythonRoot)/lib'
          PythonExecutable: '$(PythonRoot)/bin/python'
          PipExecutable: '$(PythonRoot)/bin/pip'
          SphinxExecutable: '$(PythonRoot)/bin/sphinx-build'
          PythonName: 'py311'
          PythonVersion: '3.11'
          LLVM_DOWNLOAD_LINK: 'https://github.com/sys-bio/llvm-13.x/releases/download/llvmorg-13.0.0/llvm13-ubuntu-gcc10-rel.tar.gz'
        steps:
          - checkout: self
            submodules: recursive
          # we cannot upload prebuilt binaries onto github for linux debug version because of github file size limits.
          # therefore we do this build with Release llvm for both debug and release.
          - script: |
              echo "SOURCE_DIR $(SOURCE_DIR)"
              echo "BUILD_DIR $(BUILD_DIR)"
              echo "BuildType $(BuildType)"
              echo "BuildDocs $(BuildDocs)"
              echo "INSTALL_DIR $(INSTALL_DIR)"
              echo "LLVM_INSTALL_PREFIX $(LLVM_INSTALL_PREFIX)"
              echo "DEPS_INSTALL_PREFIX $(DEPS_INSTALL_PREFIX)"
              echo "Build.DefinitionName $(Build.DefinitionName)"
              echo "System.DefinitionId	 $(System.DefinitionId)"
              echo "Agent.OS $(Agent.OS)"

              echo "System.AccessToken  $(System.AccessToken)"
              echo "System.CollectionId $(System.CollectionId)"
              echo "System.CollectionUri  $(System.CollectionUri)"
              echo "System.DefaultWorkingDirectory  $(System.DefaultWorkingDirectory)"
              echo "System.DefinitionId $(System.DefinitionId)"
              echo "System.HostType $(System.HostType)"
              echo "System.JobAttempt $(System.JobAttempt)"
              echo "System.JobDisplayName $(System.JobDisplayName)"
              echo "System.JobId  $(System.JobId)"
              echo "System.JobName  $(System.JobName)"
              echo "System.PhaseAttempt $(System.PhaseAttempt)"
              echo "System.PhaseDisplayName $(System.PhaseDisplayName)"
              echo "System.PhaseName  $(System.PhaseName)"
              echo "System.StageAttempt $(System.StageAttempt)"
              echo "System.StageDisplayName $(System.StageDisplayName)"
              echo "System.StageName  $(System.StageName)"
              echo "System.PullRequest.IsFork $(System.PullRequest.IsFork)"
              echo "System.PullRequest.PullRequestId $(System.PullRequest.PullRequestId)"
              echo "System.PullRequest.PullRequestNumber $(System.PullRequest.PullRequestNumber)"
              echo "System.PullRequest.SourceBranch $(System.PullRequest.SourceBranch)"
              echo "System.PullRequest.SourceRepositoryURI $(System.PullRequest.SourceRepositoryURI)"
              echo "System.PullRequest.TargetBranch $(System.PullRequest.TargetBranch)"
              echo "System.TeamFoundationCollectionUri $(System.TeamFoundationCollectionUri)"
              echo "System.TeamProject $(System.TeamProject)"
              echo "System.TeamProjectId $(System.TeamProjectId)"
              echo "TF_BUILD $(TF_BUILD)"
            displayName: Print Variables
          - script: |
              mkdir $(LLVM_INSTALL_PREFIX)
              mkdir $(DEPS_INSTALL_PREFIX)
            displayName: Make Directories

          - task: Cache@2
            inputs:
              key: "llvm | $(Agent.OS)"
              path: $(LLVM_INSTALL_PREFIX)
              cacheHitVar: LLVM_CACHE
            displayName: Cache llvm
          - script: |
              echo "gcc $(gcc --version)"
              echo "g++ $(g++ --version)"
              sudo add-apt-repository ppa:ubuntu-toolchain-r/test
              sudo apt-get update
              sudo apt-get install -y gcc-10 g++-10 doxygen dvipng texlive texlive-font-utils texlive-latex-extra graphviz
              sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 1
            displayName: Install g++10 and doxygen
          - script: |
              eval "$(conda shell.bash hook)"
              # conda create -y --name $(PythonName) python=$(PythonVersion)
              $(PipExecutable) install requests
            displayName: "Install Python via conda"
          - script: |
              echo "pip install dependencies"
              $(PipExecutable) install -r $(SOURCE_DIR)/docs/requirements.txt
            displayName: "Install doc requirements"
          - script: |
              $(PythonExecutable) ./.azurepipelines/getLLVM.py $(LLVM_DOWNLOAD_LINK) $(LLVM_INSTALL_PREFIX)
              echo "give execute permissions to llvm-config using chmod 777"
              chmod 777 $(LLVM_INSTALL_PREFIX)/bin/llvm-config
            displayName: "Get LLVM"
            condition: ne(variables.LLVM_CACHE, 'true')
          - task: DownloadPipelineArtifact@2
            inputs:
              source: 'specific'
              project: 'libroadrunner-deps'
              pipeline: 9
              runVersion: 'latest'
              artifact: libroadrunner-deps-$(Agent.OS)-$(BuildType)
              path: $(DEPS_INSTALL_PREFIX)
            displayName: Download libroadrunner-deps install artifacts
          - script: |
              echo "$(DEPS_INSTALL_PREFIX)"
              echo "cd to $(DEPS_INSTALL_PREFIX)"
              cd $(DEPS_INSTALL_PREFIX)
              echo "ls: "
              ls
              echo "moving contents of $(DEPS_INSTALL_PREFIX)/install to  $(DEPS_INSTALL_PREFIX)"
              mv $(DEPS_INSTALL_PREFIX)/install-azure/$(BuildType)/** .
              rm -r $(DEPS_INSTALL_PREFIX)/install-azure
              ls
            displayName: Move Dependencies
          - script: |
              export CC=/usr/bin/gcc-10
              export CXX=/usr/bin/g++-10
              export C=/usr/bin/gcc-10
              echo "Configuring roadrunner"
              echo "mkdir build directory: $(BUILD_DIR)"
              mkdir $(BUILD_DIR)
              echo "CD to build dir: $(BUILD_DIR)"
              cd $(BUILD_DIR)
              echo "cmake -DLLVM_INSTALL_PREFIX=$(LLVM_INSTALL_PREFIX) -DRR_DEPENDENCIES_INSTALL_PREFIX=$(DEPS_INSTALL_PREFIX) -DBUILD_TESTS=ON -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIR) -DBUILD_RR_PLUGINS=ON -DBUILD_RR_CAPI=ON -DBUILD_DOCS=$(BuildDocs) -DCMAKE_BUILD_TYPE=$(BuildType) -DSPHINX_EXECUTABLE=$(SphinxExecutable) .."
              cmake -DLLVM_INSTALL_PREFIX=$(LLVM_INSTALL_PREFIX) -DRR_DEPENDENCIES_INSTALL_PREFIX=$(DEPS_INSTALL_PREFIX) -DBUILD_TESTS=ON -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIR) -DBUILD_RR_PLUGINS=ON -DBUILD_RR_CAPI=ON -DBUILD_DOCS=$(BuildDocs) -DCMAKE_BUILD_TYPE=$(BuildType) -DSPHINX_EXECUTABLE=$(SphinxExecutable) ..
            displayName: Run CMake Configure Command
          - script: |
              echo "cd to docs dir"
              cd $(SOURCE_DIR)/docs/
              rm -r -f docs-build doxygen-output
            displayName: Remove roadrunner docs before re-building
            condition: eq(variables.BuildType, 'Release')
          - script: |
              echo "cd to build dir"
              cd $(BUILD_DIR)
              make roadrunner-docs-doxygen
              make roadrunner-docs-sphinx
            displayName: Build roadrunner docs
            condition: eq(variables.BuildType, 'Release')
          - script: |
              export CC=/usr/bin/gcc-10
              export CXX=/usr/bin/g++-10
              export C=/usr/bin/gcc-10
              echo "Building roadrunner"
              echo "cd to build dir"
              cd $(BUILD_DIR)
              cmake --build . --target install --config $(BuildType) -j 12
            displayName: Run CMake Build Command
          - script: |
              export CC=/usr/bin/gcc-10
              export CXX=/usr/bin/g++-10
              export C=/usr/bin/gcc-10
              echo "cd to build dir $(BUILD_DIR)"
              cd $(BUILD_DIR)
              if [ "$(BuildType)" == "Release" ]; then
                ctest --verbose --extra-verbose --progress
              fi
            displayName: RunCTest
          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/**'
              targetFolder: $(Build.ArtifactStagingDirectory)
            displayName: Copy to Staging Area
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: roadrunner-$(Agent.OS)-$(BuildType)
            displayName: Publish install
          - script: |
              rm -r $(Build.ArtifactStagingDirectory)/*
            displayName: Clear staging area
            condition: eq(variables.BuildType, 'Release')
          - script: |
              echo "move docs to installation"
              mkdir $(INSTALL_DIR)/docs
              mv $(SOURCE_DIR)/docs/docs-build '$(INSTALL_DIR)/docs/docs-build'
              mv $(SOURCE_DIR)/docs/doxygen-output '$(INSTALL_DIR)/docs/doxygen-output'
              ls '$(INSTALL_DIR)/docs'
            displayName: Make Docs
            condition: eq(variables.BuildType, 'Release')
          - task: CopyFiles@2
            inputs:
              contents: '$(INSTALL_DIR)/docs/**'
              targetFolder: $(Build.ArtifactStagingDirectory)
            displayName: Copy docs to Staging Area
            condition: eq(variables.BuildType, 'Release')
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: roadrunner-docs
            displayName: Publish docs
            condition: eq(variables.BuildType, 'Release')

#########################################################################
# Many Linux Build
#
  - stage: ManyLinux
    displayName: ManyLinux2014
    dependsOn: []
    jobs:
      - job:
        strategy:
          matrix:
            py38:
              PythonVersion: 3.8
              PythonName: py38
            py39:
              PythonVersion: 3.9
              PythonName: py39
            py310:
              PythonVersion: 3.10
              PythonName: py310
            py311:
              PythonVersion: 3.11
              PythonName: py311
        pool:
          vmImage: 'ubuntu-20.04'
        container: sysbiouw/roadrunner-manylinux2014:latest
        variables:
          CCACHE_DIR: '$(Pipeline.Workspace)/ccache'
          BUILD_DIRECTORY: '$(System.DefaultWorkingDirectory)/build'
          SOURCE_DIRECTORY: '$(System.DefaultWorkingDirectory)'
          INSTALL_DIRECTORY: '$(System.DefaultWorkingDirectory)/install-azure'
          MinicondaRoot: '/Miniconda3'
          PythonRoot: '$(MinicondaRoot)/envs/$(PythonName)'
          CondaExecutable: '$(MinicondaRoot)/bin/conda'
          PythonExecutable: '$(PythonRoot)/bin/python'
          PythonLibDir: '$(PythonRoot)/lib'
          PythonIncludeDir: '$(PythonRoot)/include'
          PipExecutable: '$(PythonRoot)/bin/pip'
          SwigExecutable: '/swig-4.0.2/install-swig-4.0.2/bin/swig'

        steps:
          - checkout: self
            submodules: recursive

          - script: |

              echo "SOURCE_DIRECTORY   $(SOURCE_DIRECTORY)"
              if [ ! -d "$(SOURCE_DIRECTORY)" ]; then
                echo "Can't find SOURCE_DIRECTORY at $(SOURCE_DIRECTORY)"
                exit 1
              fi

              echo "MinicondaRoot      $(MinicondaRoot)"
              if [ ! -d "$(MinicondaRoot)" ]; then
                echo "Can't find MinicondaRoot at $(MinicondaRoot)"
                exit 1
              fi

              echo "PythonRoot         $(PythonRoot)"
              if [ ! -d "$(PythonRoot)" ]; then
                echo "Can't find PythonRoot at $(PythonRoot)"
                exit 1
              fi

              echo "CondaExecutable    $(CondaExecutable)"
              if [ ! -f "$(CondaExecutable)" ]; then
                echo "Can't find CondaExecutable at $(CondaExecutable)"
                exit 1
              fi

              echo "PythonExecutable   $(PythonExecutable)"
              if [ ! -f "$(PythonExecutable)" ]; then
                echo "Can't find PythonExecutable at $(PythonExecutable)"
                exit 1
              fi

              echo "PythonLibDir       $(PythonLibDir)"
              if [ ! -d "$(PythonLibDir)" ]; then
                echo "Can't find PythonLibDir at $(PythonLibDir)"
                exit 1
              fi

              echo "PythonIncludeDir   $(PythonIncludeDir)"
              if [ ! -d "$(PythonIncludeDir)" ]; then
                echo "Can't find PythonIncludeDir at $(PythonIncludeDir)"
                exit 1
              fi

              echo "PipExecutable      $(PipExecutable)"
              if [ ! -f "$(PipExecutable)" ]; then
                echo "Can't find PipExecutable at $(PipExecutable)"
                exit 1
              fi

              echo "SwigExecutable     $(SwigExecutable)"
              if [ ! -f "$(SwigExecutable)" ]; then
                echo "Can't find SwigExecutable at $(SwigExecutable)"
                exit 1
              fi

            displayName: Print Azure Variables

          - script: |
              echo "$(CondaExecutable) shell.bash hook"
              eval "$($(CondaExecutable) shell.bash hook)"
              $(CondaExecutable) init

              echo ". ~/.bashrc"
              . ~/.bashrc
              $(CondaExecutable) activate $(PythonName)

              echo "mkdir $(BUILD_DIRECTORY)"
              mkdir $(BUILD_DIRECTORY)

              echo "cd $(BUILD_DIRECTORY)"
              cd $(BUILD_DIRECTORY)

              $(PipExecutable) install -r $(SOURCE_DIR)/requirements.txt
              $(PipExecutable) install -r $(SOURCE_DIR)/test-requirements.txt

              echo "cmake command: cmake -DLLVM_INSTALL_PREFIX=/install-llvm-13.x -DRR_DEPENDENCIES_INSTALL_PREFIX=/install-libroadrunner-deps -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIRECTORY) -DBUILD_PYTHON=ON -DBUILD_RR_PLUGINS=ON -DBUILD_TESTS=ON -DPython_ROOT_DIR=$(PythonRoot) -DSWIG_EXECUTABLE=$(SwigExecutable) -DCMAKE_BUILD_TYPE=Release .."
              cmake -DLLVM_INSTALL_PREFIX=/install-llvm-13.x -DRR_DEPENDENCIES_INSTALL_PREFIX=/install-libroadrunner-deps -DCMAKE_INSTALL_PREFIX=$(INSTALL_DIRECTORY) -DBUILD_PYTHON=ON -DBUILD_RR_PLUGINS=ON -DBUILD_TESTS=ON -DPython_ROOT_DIR=$(PythonRoot) -DSWIG_EXECUTABLE=$(SwigExecutable) -DCMAKE_BUILD_TYPE=Release ..
              cmake --build . --target install --config Release -j 12

            displayName: Build With Python
          - script: |
              echo ". ~/.bashrc"
              . ~/.bashrc
              $(CondaExecutable) activate $(PythonName)

              echo "cd'ing to build dir $(BUILD_DIR)"
              cd $(BUILD_DIR)
              ctest --extra-verbose --output-on-failure --exclude-regex python_tests_RunStochasticTestSuite .
            displayName: Run Tests
          - script: |
              echo ". ~/.bashrc"
              . ~/.bashrc
              $(CondaExecutable) activate $(PythonName)

              echo "cd'ing to build dir $(BUILD_DIR)"
              cd $(BUILD_DIR)
              ctest --extra-verbose --output-on-failure --tests-regex python_tests_RunStochasticTestSuite .
            displayName: Run Stochastic test suite

          - script: |
              echo "cd to $(INSTALL_DIRECTORY)"
              cd $(INSTALL_DIRECTORY)

              echo "ls"
              ls

              $(PipExecutable) install numpy pytest
              echo "$(PythonExecutable) ./setup.py bdist_wheel"
              $(PythonExecutable) ./setup.py bdist_wheel
              $(PythonExecutable) ./setup_rrplugins.py bdist_wheel

              # cd dist
              # wheel=$(realpath $(ls))
              # echo "wheel is: $wheel"
              # $(PipExecutable) install $wheel
            displayName: Build Pip Wheel
          - task: CopyFiles@2
            inputs:
              sourceFolder: '$(INSTALL_DIRECTORY)'
              contents: '**'
              targetFolder: '$(Build.ArtifactStagingDirectory)/roadrunner-manylinux2014-$(PythonName)'
            displayName: Copy install to artifact staging area
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)/roadrunner-manylinux2014-$(PythonName)'
              artifactName: roadrunner-ManyLinux2014-$(PythonName)
              Parallel: true
              ParallelCount: 8

