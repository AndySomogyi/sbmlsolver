# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""The RoadRunner SBML Simulation Engine, (c) 2009-2014 Andy Somogyi and Herbert Sauro"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_roadrunner')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_roadrunner')
    _roadrunner = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_roadrunner', [dirname(__file__)])
        except ImportError:
            import _roadrunner
            return _roadrunner
        try:
            _mod = imp.load_module('_roadrunner', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _roadrunner = swig_import_helper()
    del swig_import_helper
else:
    import _roadrunner
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _roadrunner.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _roadrunner.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _roadrunner.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _roadrunner.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _roadrunner.SwigPyIterator_equal(self, x)

    def copy(self):
        return _roadrunner.SwigPyIterator_copy(self)

    def next(self):
        return _roadrunner.SwigPyIterator_next(self)

    def __next__(self):
        return _roadrunner.SwigPyIterator___next__(self)

    def previous(self):
        return _roadrunner.SwigPyIterator_previous(self)

    def advance(self, n):
        return _roadrunner.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _roadrunner.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _roadrunner.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _roadrunner.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _roadrunner.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _roadrunner.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _roadrunner.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _roadrunner.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _roadrunner.SHARED_PTR_DISOWN
class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _roadrunner.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _roadrunner.IntVector___nonzero__(self)

    def __bool__(self):
        return _roadrunner.IntVector___bool__(self)

    def __len__(self):
        return _roadrunner.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _roadrunner.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _roadrunner.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _roadrunner.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _roadrunner.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _roadrunner.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _roadrunner.IntVector___setitem__(self, *args)

    def pop(self):
        return _roadrunner.IntVector_pop(self)

    def append(self, x):
        return _roadrunner.IntVector_append(self, x)

    def empty(self):
        return _roadrunner.IntVector_empty(self)

    def size(self):
        return _roadrunner.IntVector_size(self)

    def swap(self, v):
        return _roadrunner.IntVector_swap(self, v)

    def begin(self):
        return _roadrunner.IntVector_begin(self)

    def end(self):
        return _roadrunner.IntVector_end(self)

    def rbegin(self):
        return _roadrunner.IntVector_rbegin(self)

    def rend(self):
        return _roadrunner.IntVector_rend(self)

    def clear(self):
        return _roadrunner.IntVector_clear(self)

    def get_allocator(self):
        return _roadrunner.IntVector_get_allocator(self)

    def pop_back(self):
        return _roadrunner.IntVector_pop_back(self)

    def erase(self, *args):
        return _roadrunner.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _roadrunner.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _roadrunner.IntVector_push_back(self, x)

    def front(self):
        return _roadrunner.IntVector_front(self)

    def back(self):
        return _roadrunner.IntVector_back(self)

    def assign(self, n, x):
        return _roadrunner.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _roadrunner.IntVector_resize(self, *args)

    def insert(self, *args):
        return _roadrunner.IntVector_insert(self, *args)

    def reserve(self, n):
        return _roadrunner.IntVector_reserve(self, n)

    def capacity(self):
        return _roadrunner.IntVector_capacity(self)
    __swig_destroy__ = _roadrunner.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _roadrunner.IntVector_swigregister
IntVector_swigregister(IntVector)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _roadrunner.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _roadrunner.StringVector___nonzero__(self)

    def __bool__(self):
        return _roadrunner.StringVector___bool__(self)

    def __len__(self):
        return _roadrunner.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _roadrunner.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _roadrunner.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _roadrunner.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _roadrunner.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _roadrunner.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _roadrunner.StringVector___setitem__(self, *args)

    def pop(self):
        return _roadrunner.StringVector_pop(self)

    def append(self, x):
        return _roadrunner.StringVector_append(self, x)

    def empty(self):
        return _roadrunner.StringVector_empty(self)

    def size(self):
        return _roadrunner.StringVector_size(self)

    def swap(self, v):
        return _roadrunner.StringVector_swap(self, v)

    def begin(self):
        return _roadrunner.StringVector_begin(self)

    def end(self):
        return _roadrunner.StringVector_end(self)

    def rbegin(self):
        return _roadrunner.StringVector_rbegin(self)

    def rend(self):
        return _roadrunner.StringVector_rend(self)

    def clear(self):
        return _roadrunner.StringVector_clear(self)

    def get_allocator(self):
        return _roadrunner.StringVector_get_allocator(self)

    def pop_back(self):
        return _roadrunner.StringVector_pop_back(self)

    def erase(self, *args):
        return _roadrunner.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _roadrunner.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _roadrunner.StringVector_push_back(self, x)

    def front(self):
        return _roadrunner.StringVector_front(self)

    def back(self):
        return _roadrunner.StringVector_back(self)

    def assign(self, n, x):
        return _roadrunner.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _roadrunner.StringVector_resize(self, *args)

    def insert(self, *args):
        return _roadrunner.StringVector_insert(self, *args)

    def reserve(self, n):
        return _roadrunner.StringVector_reserve(self, n)

    def capacity(self):
        return _roadrunner.StringVector_capacity(self)
    __swig_destroy__ = _roadrunner.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _roadrunner.StringVector_swigregister
StringVector_swigregister(StringVector)

class StringList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _roadrunner.StringList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _roadrunner.StringList___nonzero__(self)

    def __bool__(self):
        return _roadrunner.StringList___bool__(self)

    def __len__(self):
        return _roadrunner.StringList___len__(self)

    def __getslice__(self, i, j):
        return _roadrunner.StringList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _roadrunner.StringList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _roadrunner.StringList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _roadrunner.StringList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _roadrunner.StringList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _roadrunner.StringList___setitem__(self, *args)

    def pop(self):
        return _roadrunner.StringList_pop(self)

    def append(self, x):
        return _roadrunner.StringList_append(self, x)

    def empty(self):
        return _roadrunner.StringList_empty(self)

    def size(self):
        return _roadrunner.StringList_size(self)

    def swap(self, v):
        return _roadrunner.StringList_swap(self, v)

    def begin(self):
        return _roadrunner.StringList_begin(self)

    def end(self):
        return _roadrunner.StringList_end(self)

    def rbegin(self):
        return _roadrunner.StringList_rbegin(self)

    def rend(self):
        return _roadrunner.StringList_rend(self)

    def clear(self):
        return _roadrunner.StringList_clear(self)

    def get_allocator(self):
        return _roadrunner.StringList_get_allocator(self)

    def pop_back(self):
        return _roadrunner.StringList_pop_back(self)

    def erase(self, *args):
        return _roadrunner.StringList_erase(self, *args)

    def __init__(self, *args):
        this = _roadrunner.new_StringList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _roadrunner.StringList_push_back(self, x)

    def front(self):
        return _roadrunner.StringList_front(self)

    def back(self):
        return _roadrunner.StringList_back(self)

    def assign(self, n, x):
        return _roadrunner.StringList_assign(self, n, x)

    def resize(self, *args):
        return _roadrunner.StringList_resize(self, *args)

    def insert(self, *args):
        return _roadrunner.StringList_insert(self, *args)

    def pop_front(self):
        return _roadrunner.StringList_pop_front(self)

    def push_front(self, x):
        return _roadrunner.StringList_push_front(self, x)

    def reverse(self):
        return _roadrunner.StringList_reverse(self)
    __swig_destroy__ = _roadrunner.delete_StringList
    __del__ = lambda self: None
StringList_swigregister = _roadrunner.StringList_swigregister
StringList_swigregister(StringList)

class DictionaryVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictionaryVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DictionaryVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _roadrunner.DictionaryVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _roadrunner.DictionaryVector___nonzero__(self)

    def __bool__(self):
        return _roadrunner.DictionaryVector___bool__(self)

    def __len__(self):
        return _roadrunner.DictionaryVector___len__(self)

    def __getslice__(self, i, j):
        return _roadrunner.DictionaryVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _roadrunner.DictionaryVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _roadrunner.DictionaryVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _roadrunner.DictionaryVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _roadrunner.DictionaryVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _roadrunner.DictionaryVector___setitem__(self, *args)

    def pop(self):
        return _roadrunner.DictionaryVector_pop(self)

    def append(self, x):
        return _roadrunner.DictionaryVector_append(self, x)

    def empty(self):
        return _roadrunner.DictionaryVector_empty(self)

    def size(self):
        return _roadrunner.DictionaryVector_size(self)

    def swap(self, v):
        return _roadrunner.DictionaryVector_swap(self, v)

    def begin(self):
        return _roadrunner.DictionaryVector_begin(self)

    def end(self):
        return _roadrunner.DictionaryVector_end(self)

    def rbegin(self):
        return _roadrunner.DictionaryVector_rbegin(self)

    def rend(self):
        return _roadrunner.DictionaryVector_rend(self)

    def clear(self):
        return _roadrunner.DictionaryVector_clear(self)

    def get_allocator(self):
        return _roadrunner.DictionaryVector_get_allocator(self)

    def pop_back(self):
        return _roadrunner.DictionaryVector_pop_back(self)

    def erase(self, *args):
        return _roadrunner.DictionaryVector_erase(self, *args)

    def __init__(self, *args):
        this = _roadrunner.new_DictionaryVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _roadrunner.DictionaryVector_push_back(self, x)

    def front(self):
        return _roadrunner.DictionaryVector_front(self)

    def back(self):
        return _roadrunner.DictionaryVector_back(self)

    def assign(self, n, x):
        return _roadrunner.DictionaryVector_assign(self, n, x)

    def resize(self, *args):
        return _roadrunner.DictionaryVector_resize(self, *args)

    def insert(self, *args):
        return _roadrunner.DictionaryVector_insert(self, *args)

    def reserve(self, n):
        return _roadrunner.DictionaryVector_reserve(self, n)

    def capacity(self):
        return _roadrunner.DictionaryVector_capacity(self)
    __swig_destroy__ = _roadrunner.delete_DictionaryVector
    __del__ = lambda self: None
DictionaryVector_swigregister = _roadrunner.DictionaryVector_swigregister
DictionaryVector_swigregister(DictionaryVector)


def sigtrap():
    return _roadrunner.sigtrap()
sigtrap = _roadrunner.sigtrap
class Dictionary(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionary, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def keys(self):
        return _roadrunner.Dictionary_keys(self)

    def values(self):
        return _roadrunner.Dictionary_values(self)

    def items(self):
        return _roadrunner.Dictionary_items(self)

    def __getitem__(self, key):
        return _roadrunner.Dictionary___getitem__(self, key)

    def __setitem__(self, key, value):
        return _roadrunner.Dictionary___setitem__(self, key, value)

    def __delitem__(self, key):
        return _roadrunner.Dictionary___delitem__(self, key)

    def __contains__(self, key):
        return _roadrunner.Dictionary___contains__(self, key)

    def helloPython(self):
        return _roadrunner.Dictionary_helloPython(self)
Dictionary_swigregister = _roadrunner.Dictionary_swigregister
Dictionary_swigregister(Dictionary)

class BasicDictionary(Dictionary):
    __swig_setmethods__ = {}
    for _s in [Dictionary]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BasicDictionary, name, value)
    __swig_getmethods__ = {}
    for _s in [Dictionary]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BasicDictionary, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _roadrunner.new_BasicDictionary()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_BasicDictionary
    __del__ = lambda self: None
BasicDictionary_swigregister = _roadrunner.BasicDictionary_swigregister
BasicDictionary_swigregister(BasicDictionary)

class LoadSBMLOptions(BasicDictionary):
    __swig_setmethods__ = {}
    for _s in [BasicDictionary]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LoadSBMLOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [BasicDictionary]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LoadSBMLOptions, name)
    __repr__ = _swig_repr
    CONSERVED_MOIETIES = _roadrunner.LoadSBMLOptions_CONSERVED_MOIETIES
    RECOMPILE = _roadrunner.LoadSBMLOptions_RECOMPILE
    READ_ONLY = _roadrunner.LoadSBMLOptions_READ_ONLY
    MUTABLE_INITIAL_CONDITIONS = _roadrunner.LoadSBMLOptions_MUTABLE_INITIAL_CONDITIONS
    OPTIMIZE_GVN = _roadrunner.LoadSBMLOptions_OPTIMIZE_GVN
    OPTIMIZE_CFG_SIMPLIFICATION = _roadrunner.LoadSBMLOptions_OPTIMIZE_CFG_SIMPLIFICATION
    OPTIMIZE_INSTRUCTION_COMBINING = _roadrunner.LoadSBMLOptions_OPTIMIZE_INSTRUCTION_COMBINING
    OPTIMIZE_DEAD_INST_ELIMINATION = _roadrunner.LoadSBMLOptions_OPTIMIZE_DEAD_INST_ELIMINATION
    OPTIMIZE_DEAD_CODE_ELIMINATION = _roadrunner.LoadSBMLOptions_OPTIMIZE_DEAD_CODE_ELIMINATION
    OPTIMIZE_INSTRUCTION_SIMPLIFIER = _roadrunner.LoadSBMLOptions_OPTIMIZE_INSTRUCTION_SIMPLIFIER
    OPTIMIZE = _roadrunner.LoadSBMLOptions_OPTIMIZE
    USE_MCJIT = _roadrunner.LoadSBMLOptions_USE_MCJIT
    LLVM_SYMBOL_CACHE = _roadrunner.LoadSBMLOptions_LLVM_SYMBOL_CACHE
    NO_DEFAULT_SELECTIONS = _roadrunner.LoadSBMLOptions_NO_DEFAULT_SELECTIONS

    def __init__(self, *args):
        this = _roadrunner.new_LoadSBMLOptions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["version"] = _roadrunner.LoadSBMLOptions_version_set
    __swig_getmethods__["version"] = _roadrunner.LoadSBMLOptions_version_get
    if _newclass:
        version = _swig_property(_roadrunner.LoadSBMLOptions_version_get, _roadrunner.LoadSBMLOptions_version_set)
    __swig_setmethods__["size"] = _roadrunner.LoadSBMLOptions_size_set
    __swig_getmethods__["size"] = _roadrunner.LoadSBMLOptions_size_get
    if _newclass:
        size = _swig_property(_roadrunner.LoadSBMLOptions_size_get, _roadrunner.LoadSBMLOptions_size_set)
    __swig_setmethods__["modelGeneratorOpt"] = _roadrunner.LoadSBMLOptions_modelGeneratorOpt_set
    __swig_getmethods__["modelGeneratorOpt"] = _roadrunner.LoadSBMLOptions_modelGeneratorOpt_get
    if _newclass:
        modelGeneratorOpt = _swig_property(_roadrunner.LoadSBMLOptions_modelGeneratorOpt_get, _roadrunner.LoadSBMLOptions_modelGeneratorOpt_set)
    __swig_setmethods__["loadFlags"] = _roadrunner.LoadSBMLOptions_loadFlags_set
    __swig_getmethods__["loadFlags"] = _roadrunner.LoadSBMLOptions_loadFlags_get
    if _newclass:
        loadFlags = _swig_property(_roadrunner.LoadSBMLOptions_loadFlags_get, _roadrunner.LoadSBMLOptions_loadFlags_set)

    def getConservedMoietyConversion(self):
        return _roadrunner.LoadSBMLOptions_getConservedMoietyConversion(self)

    def setConservedMoietyConversion(self, val):
        return _roadrunner.LoadSBMLOptions_setConservedMoietyConversion(self, val)
    __swig_destroy__ = _roadrunner.delete_LoadSBMLOptions
    __del__ = lambda self: None
    __swig_setmethods__["conservedMoieties"] = _roadrunner.LoadSBMLOptions_conservedMoieties_set
    __swig_getmethods__["conservedMoieties"] = _roadrunner.LoadSBMLOptions_conservedMoieties_get
    if _newclass:
        conservedMoieties = _swig_property(_roadrunner.LoadSBMLOptions_conservedMoieties_get, _roadrunner.LoadSBMLOptions_conservedMoieties_set)
    __swig_setmethods__["mutableInitialConditions"] = _roadrunner.LoadSBMLOptions_mutableInitialConditions_set
    __swig_getmethods__["mutableInitialConditions"] = _roadrunner.LoadSBMLOptions_mutableInitialConditions_get
    if _newclass:
        mutableInitialConditions = _swig_property(_roadrunner.LoadSBMLOptions_mutableInitialConditions_get, _roadrunner.LoadSBMLOptions_mutableInitialConditions_set)
    __swig_setmethods__["noDefaultSelections"] = _roadrunner.LoadSBMLOptions_noDefaultSelections_set
    __swig_getmethods__["noDefaultSelections"] = _roadrunner.LoadSBMLOptions_noDefaultSelections_get
    if _newclass:
        noDefaultSelections = _swig_property(_roadrunner.LoadSBMLOptions_noDefaultSelections_get, _roadrunner.LoadSBMLOptions_noDefaultSelections_set)
    __swig_setmethods__["readOnly"] = _roadrunner.LoadSBMLOptions_readOnly_set
    __swig_getmethods__["readOnly"] = _roadrunner.LoadSBMLOptions_readOnly_get
    if _newclass:
        readOnly = _swig_property(_roadrunner.LoadSBMLOptions_readOnly_get, _roadrunner.LoadSBMLOptions_readOnly_set)
    __swig_setmethods__["recompile"] = _roadrunner.LoadSBMLOptions_recompile_set
    __swig_getmethods__["recompile"] = _roadrunner.LoadSBMLOptions_recompile_get
    if _newclass:
        recompile = _swig_property(_roadrunner.LoadSBMLOptions_recompile_get, _roadrunner.LoadSBMLOptions_recompile_set)
LoadSBMLOptions_swigregister = _roadrunner.LoadSBMLOptions_swigregister
LoadSBMLOptions_swigregister(LoadSBMLOptions)

class SimulateOptions(BasicDictionary):
    __swig_setmethods__ = {}
    for _s in [BasicDictionary]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimulateOptions, name, value)
    __swig_getmethods__ = {}
    for _s in [BasicDictionary]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimulateOptions, name)
    __swig_setmethods__["reset_model"] = _roadrunner.SimulateOptions_reset_model_set
    __swig_getmethods__["reset_model"] = _roadrunner.SimulateOptions_reset_model_get
    if _newclass:
        reset_model = _swig_property(_roadrunner.SimulateOptions_reset_model_get, _roadrunner.SimulateOptions_reset_model_set)
    __swig_setmethods__["structured_result"] = _roadrunner.SimulateOptions_structured_result_set
    __swig_getmethods__["structured_result"] = _roadrunner.SimulateOptions_structured_result_get
    if _newclass:
        structured_result = _swig_property(_roadrunner.SimulateOptions_structured_result_get, _roadrunner.SimulateOptions_structured_result_set)
    __swig_setmethods__["copy_result"] = _roadrunner.SimulateOptions_copy_result_set
    __swig_getmethods__["copy_result"] = _roadrunner.SimulateOptions_copy_result_get
    if _newclass:
        copy_result = _swig_property(_roadrunner.SimulateOptions_copy_result_get, _roadrunner.SimulateOptions_copy_result_set)

    def __init__(self):
        this = _roadrunner.new_SimulateOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["steps"] = _roadrunner.SimulateOptions_steps_set
    __swig_getmethods__["steps"] = _roadrunner.SimulateOptions_steps_get
    if _newclass:
        steps = _swig_property(_roadrunner.SimulateOptions_steps_get, _roadrunner.SimulateOptions_steps_set)
    __swig_setmethods__["start"] = _roadrunner.SimulateOptions_start_set
    __swig_getmethods__["start"] = _roadrunner.SimulateOptions_start_get
    if _newclass:
        start = _swig_property(_roadrunner.SimulateOptions_start_get, _roadrunner.SimulateOptions_start_set)
    __swig_setmethods__["duration"] = _roadrunner.SimulateOptions_duration_set
    __swig_getmethods__["duration"] = _roadrunner.SimulateOptions_duration_get
    if _newclass:
        duration = _swig_property(_roadrunner.SimulateOptions_duration_get, _roadrunner.SimulateOptions_duration_set)
    __swig_setmethods__["variables"] = _roadrunner.SimulateOptions_variables_set
    __swig_getmethods__["variables"] = _roadrunner.SimulateOptions_variables_get
    if _newclass:
        variables = _swig_property(_roadrunner.SimulateOptions_variables_get, _roadrunner.SimulateOptions_variables_set)
    __swig_setmethods__["amounts"] = _roadrunner.SimulateOptions_amounts_set
    __swig_getmethods__["amounts"] = _roadrunner.SimulateOptions_amounts_get
    if _newclass:
        amounts = _swig_property(_roadrunner.SimulateOptions_amounts_get, _roadrunner.SimulateOptions_amounts_set)
    __swig_setmethods__["concentrations"] = _roadrunner.SimulateOptions_concentrations_set
    __swig_getmethods__["concentrations"] = _roadrunner.SimulateOptions_concentrations_get
    if _newclass:
        concentrations = _swig_property(_roadrunner.SimulateOptions_concentrations_get, _roadrunner.SimulateOptions_concentrations_set)

    def toString(self):
        return _roadrunner.SimulateOptions_toString(self)

    def toRepr(self):
        return _roadrunner.SimulateOptions_toRepr(self)

    def loadSBMLSettings(self, filename):
        return _roadrunner.SimulateOptions_loadSBMLSettings(self, filename)
    __swig_setmethods__["end"] = _roadrunner.SimulateOptions_end_set
    __swig_getmethods__["end"] = _roadrunner.SimulateOptions_end_get
    if _newclass:
        end = _swig_property(_roadrunner.SimulateOptions_end_get, _roadrunner.SimulateOptions_end_set)
    __swig_setmethods__["structuredResult"] = _roadrunner.SimulateOptions_structuredResult_set
    __swig_getmethods__["structuredResult"] = _roadrunner.SimulateOptions_structuredResult_get
    if _newclass:
        structuredResult = _swig_property(_roadrunner.SimulateOptions_structuredResult_get, _roadrunner.SimulateOptions_structuredResult_set)
    __swig_setmethods__["copyResult"] = _roadrunner.SimulateOptions_copyResult_set
    __swig_getmethods__["copyResult"] = _roadrunner.SimulateOptions_copyResult_get
    if _newclass:
        copyResult = _swig_property(_roadrunner.SimulateOptions_copyResult_get, _roadrunner.SimulateOptions_copyResult_set)

    def __repr__(self):
        return _roadrunner.SimulateOptions___repr__(self)

    def __str__(self):
        return _roadrunner.SimulateOptions___str__(self)

    def copy(self):
        return _roadrunner.SimulateOptions_copy(self)

    def getListener(self):
        return self._getListener()

    def setListener(self, listener):
        if listener is None:
            self._clearListener()
        else:
            self._setListener(listener)

    __swig_destroy__ = _roadrunner.delete_SimulateOptions
    __del__ = lambda self: None
SimulateOptions_swigregister = _roadrunner.SimulateOptions_swigregister
SimulateOptions_swigregister(SimulateOptions)

class RoadRunnerOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoadRunnerOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoadRunnerOptions, name)
    __repr__ = _swig_repr
    DISABLE_PYTHON_DYNAMIC_PROPERTIES = _roadrunner.RoadRunnerOptions_DISABLE_PYTHON_DYNAMIC_PROPERTIES
    __swig_setmethods__["flags"] = _roadrunner.RoadRunnerOptions_flags_set
    __swig_getmethods__["flags"] = _roadrunner.RoadRunnerOptions_flags_get
    if _newclass:
        flags = _swig_property(_roadrunner.RoadRunnerOptions_flags_get, _roadrunner.RoadRunnerOptions_flags_set)
    __swig_setmethods__["jacobianStepSize"] = _roadrunner.RoadRunnerOptions_jacobianStepSize_set
    __swig_getmethods__["jacobianStepSize"] = _roadrunner.RoadRunnerOptions_jacobianStepSize_get
    if _newclass:
        jacobianStepSize = _swig_property(_roadrunner.RoadRunnerOptions_jacobianStepSize_get, _roadrunner.RoadRunnerOptions_jacobianStepSize_set)

    def __init__(self):
        this = _roadrunner.new_RoadRunnerOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["disablePythonDynamicProperties"] = _roadrunner.RoadRunnerOptions_disablePythonDynamicProperties_set
    __swig_getmethods__["disablePythonDynamicProperties"] = _roadrunner.RoadRunnerOptions_disablePythonDynamicProperties_get
    if _newclass:
        disablePythonDynamicProperties = _swig_property(_roadrunner.RoadRunnerOptions_disablePythonDynamicProperties_get, _roadrunner.RoadRunnerOptions_disablePythonDynamicProperties_set)
    __swig_destroy__ = _roadrunner.delete_RoadRunnerOptions
    __del__ = lambda self: None
RoadRunnerOptions_swigregister = _roadrunner.RoadRunnerOptions_swigregister
RoadRunnerOptions_swigregister(RoadRunnerOptions)

class Logger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Logger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Logger, name)
    __repr__ = _swig_repr
    LOG_CURRENT = _roadrunner.Logger_LOG_CURRENT
    LOG_FATAL = _roadrunner.Logger_LOG_FATAL
    LOG_CRITICAL = _roadrunner.Logger_LOG_CRITICAL
    LOG_ERROR = _roadrunner.Logger_LOG_ERROR
    LOG_WARNING = _roadrunner.Logger_LOG_WARNING
    LOG_NOTICE = _roadrunner.Logger_LOG_NOTICE
    LOG_INFORMATION = _roadrunner.Logger_LOG_INFORMATION
    LOG_DEBUG = _roadrunner.Logger_LOG_DEBUG
    LOG_TRACE = _roadrunner.Logger_LOG_TRACE

    def setLevel(*args):
        """

        Logger.setLevel([level])

        sets the logging level to one a value from Logger::Level

        :param int level: the level to set, defaults to LOG_CURRENT if none is specified.

        """
        return _roadrunner.Logger_setLevel(*args)

    setLevel = staticmethod(setLevel)

    def getLevel():
        """

        Logger.getLevel()

        get the current logging level.

        """
        return _roadrunner.Logger_getLevel()

    getLevel = staticmethod(getLevel)

    def disableLogging():
        """

        Logger.disableLogging()

        Suppresses all logging output

        """
        return _roadrunner.Logger_disableLogging()

    disableLogging = staticmethod(disableLogging)

    def disableConsoleLogging():
        """

        Logger.disableConsoleLogging()

        stops logging to the console, but file logging may continue.

        """
        return _roadrunner.Logger_disableConsoleLogging()

    disableConsoleLogging = staticmethod(disableConsoleLogging)

    def enableConsoleLogging(*args):
        """

        Logger.enableConsoleLogging(level)

        turns on console logging (stderr) at the given level.

        :param level: A logging level, one of the above listed LOG_* levels.

        """
        return _roadrunner.Logger_enableConsoleLogging(*args)

    enableConsoleLogging = staticmethod(enableConsoleLogging)

    def enableFileLogging(*args):
        """

        Logger.enableFileLogging(fileName, [level])

        turns on file logging to the given file as the given level.

        :param str fileName: the path of a file to log to.
        :param level: (optional) the logging level, defaults to LOG_CURRENT.

        """
        return _roadrunner.Logger_enableFileLogging(*args)

    enableFileLogging = staticmethod(enableFileLogging)

    def disableFileLogging():
        """

        Logger.disableFileLogging()

        turns off file logging, but has no effect on console logging.

        """
        return _roadrunner.Logger_disableFileLogging()

    disableFileLogging = staticmethod(disableFileLogging)

    def getCurrentLevelAsString():
        """

        Logger.getCurrentLevelAsString()

        get the textural form of the current logging level.

        """
        return _roadrunner.Logger_getCurrentLevelAsString()

    getCurrentLevelAsString = staticmethod(getCurrentLevelAsString)

    def getFileName():
        """

        Logger.getFileName()

        get the name of the currently used log file.

        """
        return _roadrunner.Logger_getFileName()

    getFileName = staticmethod(getFileName)

    def setFormattingPattern(format):
        """

        Logger.setFormattingPattern(format)

        Internally, RoadRunner uses the Poco logging framework, so we
        can custom format logging output based on a formatting pattern
        string.

        The format pattern is used as a template to format the message and
        is copied character by character except for the following special characters,
        which are replaced by the corresponding value.

        An example pattern of "%Y-%m-%d %H:%M:%S %p: %t" set via::

          roadrunner.Logger.setFormattingPattern("%Y-%m-%d %H:%M:%S %p: %t")

        would produce the following output:

        .. image:: logging2.png

        |

        RoadRunner supports the following format specifiers. These were copied from the Poco documentation:

        * %s - message source
        * %t - message text
        * %l - message priority level (1 .. 7)
        * %p - message priority (Fatal, Critical, Error, Warning, Notice, Information, Debug, Trace)
        * %q - abbreviated message priority (F, C, E, W, N, I, D, T)
        * %P - message process identifier
        * %T - message thread name
        * %I - message thread identifier (numeric)
        * %N - node or host name
        * %U - message source file path (empty string if not set)
        * %u - message source line number (0 if not set)
        * %w - message date/time abbreviated weekday (Mon, Tue, ...)
        * %W - message date/time full weekday (Monday, Tuesday, ...)
        * %b - message date/time abbreviated month (Jan, Feb, ...)
        * %B - message date/time full month (January, February, ...)
        * %d - message date/time zero-padded day of month (01 .. 31)
        * %e - message date/time day of month (1 .. 31)
        * %f - message date/time space-padded day of month ( 1 .. 31)
        * %m - message date/time zero-padded month (01 .. 12)
        * %n - message date/time month (1 .. 12)
        * %o - message date/time space-padded month ( 1 .. 12)
        * %y - message date/time year without century (70)
        * %Y - message date/time year with century (1970)
        * %H - message date/time hour (00 .. 23)
        * %h - message date/time hour (00 .. 12)
        * %a - message date/time am/pm
        * %A - message date/time AM/PM
        * %M - message date/time minute (00 .. 59)
        * %S - message date/time second (00 .. 59)
        * %i - message date/time millisecond (000 .. 999)
        * %c - message date/time centisecond (0 .. 9)
        * %F - message date/time fractional seconds/microseconds (000000 - 999999)
        * %z - time zone differential in ISO 8601 format (Z or +NN.NN)
        * %Z - time zone differential in RFC format (GMT or +NNNN)
        * %E - epoch time (UTC, seconds since midnight, January 1, 1970)
        * %[name] - the value of the message parameter with the given name
        * %% - percent sign

        :param str format: the logging format string. Must be formatted using the above specifiers.

        """
        return _roadrunner.Logger_setFormattingPattern(format)

    setFormattingPattern = staticmethod(setFormattingPattern)

    def getFormattingPattern():
        """

        Logger.getFormattingPattern()

        get the currently set formatting pattern.

        """
        return _roadrunner.Logger_getFormattingPattern()

    getFormattingPattern = staticmethod(getFormattingPattern)

    def levelToString(level):
        """

        Logger.levelToString(level)

        gets the textual form of a logging level Enum for a given value.

        :param int level: One of the above listed logging levels.

        """
        return _roadrunner.Logger_levelToString(level)

    levelToString = staticmethod(levelToString)

    def stringToLevel(str):
        """

        Logger.stringToLevel(s)

        parses a string and returns a Logger::Level

        :param str s: the string to parse.

        """
        return _roadrunner.Logger_stringToLevel(str)

    stringToLevel = staticmethod(stringToLevel)

    def getColoredOutput():
        """

        Logger.getColoredOutput()

        check if we have colored logging enabled.

        """
        return _roadrunner.Logger_getColoredOutput()

    getColoredOutput = staticmethod(getColoredOutput)

    def setColoredOutput(arg1):
        """

        Logger.setColoredOutput(b)

        enable / disable colored output

        :param boolean b: turn colored logging on or off

        """
        return _roadrunner.Logger_setColoredOutput(arg1)

    setColoredOutput = staticmethod(setColoredOutput)

    def setProperty(name, value):
        """

        Logger.setProperty(name, value)

        Set the color of the output logging messages.

        In the future, we may add additional properties here.

        The following properties are supported:

        * enableColors:      Enable or disable colors.
        * traceColor:        Specify color for trace messages.
        * debugColor:        Specify color for debug messages.
        * informationColor:  Specify color for information messages.
        * noticeColor:       Specify color for notice messages.
        * warningColor:      Specify color for warning messages.
        * errorColor:        Specify color for error messages.
        * criticalColor:     Specify color for critical messages.
        * fatalColor:        Specify color for fatal messages.


        The following color values are supported:

        * default
        * black
        * red
        * green
        * brown
        * blue
        * magenta
        * cyan
        * gray
        * darkgray
        * lightRed
        * lightGreen
        * yellow
        * lightBlue
        * lightMagenta
        * lightCyan
        * white

        :param str name: the name of the value to set.
        :param str value: the value to set.

        """
        return _roadrunner.Logger_setProperty(name, value)

    setProperty = staticmethod(setProperty)

    def log(level, msg):
        """

        Logger.log(level, msg)

        logs a message to the log.

        :param int level: the level to log at.
        :param str msg: the message to log.

        """
        return _roadrunner.Logger_log(level, msg)

    log = staticmethod(log)
    if _newclass:
        enablePythonLogging = staticmethod(_roadrunner.Logger_enablePythonLogging)
    else:
        enablePythonLogging = _roadrunner.Logger_enablePythonLogging
    if _newclass:
        disablePythonLogging = staticmethod(_roadrunner.Logger_disablePythonLogging)
    else:
        disablePythonLogging = _roadrunner.Logger_disablePythonLogging

    def __init__(self):
        this = _roadrunner.new_Logger()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_Logger
    __del__ = lambda self: None
Logger_swigregister = _roadrunner.Logger_swigregister
Logger_swigregister(Logger)

def Logger_setLevel(*args):
    """

    Logger.setLevel([level])

    sets the logging level to one a value from Logger::Level

    :param int level: the level to set, defaults to LOG_CURRENT if none is specified.

    """
    return _roadrunner.Logger_setLevel(*args)

def Logger_getLevel():
    """

    Logger.getLevel()

    get the current logging level.

    """
    return _roadrunner.Logger_getLevel()

def Logger_disableLogging():
    """

    Logger.disableLogging()

    Suppresses all logging output

    """
    return _roadrunner.Logger_disableLogging()

def Logger_disableConsoleLogging():
    """

    Logger.disableConsoleLogging()

    stops logging to the console, but file logging may continue.

    """
    return _roadrunner.Logger_disableConsoleLogging()

def Logger_enableConsoleLogging(*args):
    """

    Logger.enableConsoleLogging(level)

    turns on console logging (stderr) at the given level.

    :param level: A logging level, one of the above listed LOG_* levels.

    """
    return _roadrunner.Logger_enableConsoleLogging(*args)

def Logger_enableFileLogging(*args):
    """

    Logger.enableFileLogging(fileName, [level])

    turns on file logging to the given file as the given level.

    :param str fileName: the path of a file to log to.
    :param level: (optional) the logging level, defaults to LOG_CURRENT.

    """
    return _roadrunner.Logger_enableFileLogging(*args)

def Logger_disableFileLogging():
    """

    Logger.disableFileLogging()

    turns off file logging, but has no effect on console logging.

    """
    return _roadrunner.Logger_disableFileLogging()

def Logger_getCurrentLevelAsString():
    """

    Logger.getCurrentLevelAsString()

    get the textural form of the current logging level.

    """
    return _roadrunner.Logger_getCurrentLevelAsString()

def Logger_getFileName():
    """

    Logger.getFileName()

    get the name of the currently used log file.

    """
    return _roadrunner.Logger_getFileName()

def Logger_setFormattingPattern(format):
    """

    Logger.setFormattingPattern(format)

    Internally, RoadRunner uses the Poco logging framework, so we
    can custom format logging output based on a formatting pattern
    string.

    The format pattern is used as a template to format the message and
    is copied character by character except for the following special characters,
    which are replaced by the corresponding value.

    An example pattern of "%Y-%m-%d %H:%M:%S %p: %t" set via::

      roadrunner.Logger.setFormattingPattern("%Y-%m-%d %H:%M:%S %p: %t")

    would produce the following output:

    .. image:: logging2.png

    |

    RoadRunner supports the following format specifiers. These were copied from the Poco documentation:

    * %s - message source
    * %t - message text
    * %l - message priority level (1 .. 7)
    * %p - message priority (Fatal, Critical, Error, Warning, Notice, Information, Debug, Trace)
    * %q - abbreviated message priority (F, C, E, W, N, I, D, T)
    * %P - message process identifier
    * %T - message thread name
    * %I - message thread identifier (numeric)
    * %N - node or host name
    * %U - message source file path (empty string if not set)
    * %u - message source line number (0 if not set)
    * %w - message date/time abbreviated weekday (Mon, Tue, ...)
    * %W - message date/time full weekday (Monday, Tuesday, ...)
    * %b - message date/time abbreviated month (Jan, Feb, ...)
    * %B - message date/time full month (January, February, ...)
    * %d - message date/time zero-padded day of month (01 .. 31)
    * %e - message date/time day of month (1 .. 31)
    * %f - message date/time space-padded day of month ( 1 .. 31)
    * %m - message date/time zero-padded month (01 .. 12)
    * %n - message date/time month (1 .. 12)
    * %o - message date/time space-padded month ( 1 .. 12)
    * %y - message date/time year without century (70)
    * %Y - message date/time year with century (1970)
    * %H - message date/time hour (00 .. 23)
    * %h - message date/time hour (00 .. 12)
    * %a - message date/time am/pm
    * %A - message date/time AM/PM
    * %M - message date/time minute (00 .. 59)
    * %S - message date/time second (00 .. 59)
    * %i - message date/time millisecond (000 .. 999)
    * %c - message date/time centisecond (0 .. 9)
    * %F - message date/time fractional seconds/microseconds (000000 - 999999)
    * %z - time zone differential in ISO 8601 format (Z or +NN.NN)
    * %Z - time zone differential in RFC format (GMT or +NNNN)
    * %E - epoch time (UTC, seconds since midnight, January 1, 1970)
    * %[name] - the value of the message parameter with the given name
    * %% - percent sign

    :param str format: the logging format string. Must be formatted using the above specifiers.

    """
    return _roadrunner.Logger_setFormattingPattern(format)

def Logger_getFormattingPattern():
    """

    Logger.getFormattingPattern()

    get the currently set formatting pattern.

    """
    return _roadrunner.Logger_getFormattingPattern()

def Logger_levelToString(level):
    """

    Logger.levelToString(level)

    gets the textual form of a logging level Enum for a given value.

    :param int level: One of the above listed logging levels.

    """
    return _roadrunner.Logger_levelToString(level)

def Logger_stringToLevel(str):
    """

    Logger.stringToLevel(s)

    parses a string and returns a Logger::Level

    :param str s: the string to parse.

    """
    return _roadrunner.Logger_stringToLevel(str)

def Logger_getColoredOutput():
    """

    Logger.getColoredOutput()

    check if we have colored logging enabled.

    """
    return _roadrunner.Logger_getColoredOutput()

def Logger_setColoredOutput(arg2):
    """

    Logger.setColoredOutput(b)

    enable / disable colored output

    :param boolean b: turn colored logging on or off

    """
    return _roadrunner.Logger_setColoredOutput(arg2)

def Logger_setProperty(name, value):
    """

    Logger.setProperty(name, value)

    Set the color of the output logging messages.

    In the future, we may add additional properties here.

    The following properties are supported:

    * enableColors:      Enable or disable colors.
    * traceColor:        Specify color for trace messages.
    * debugColor:        Specify color for debug messages.
    * informationColor:  Specify color for information messages.
    * noticeColor:       Specify color for notice messages.
    * warningColor:      Specify color for warning messages.
    * errorColor:        Specify color for error messages.
    * criticalColor:     Specify color for critical messages.
    * fatalColor:        Specify color for fatal messages.


    The following color values are supported:

    * default
    * black
    * red
    * green
    * brown
    * blue
    * magenta
    * cyan
    * gray
    * darkgray
    * lightRed
    * lightGreen
    * yellow
    * lightBlue
    * lightMagenta
    * lightCyan
    * white

    :param str name: the name of the value to set.
    :param str value: the value to set.

    """
    return _roadrunner.Logger_setProperty(name, value)

def Logger_log(level, msg):
    """

    Logger.log(level, msg)

    logs a message to the log.

    :param int level: the level to log at.
    :param str msg: the message to log.

    """
    return _roadrunner.Logger_log(level, msg)

def Logger_enablePythonLogging():
    return _roadrunner.Logger_enablePythonLogging()
Logger_enablePythonLogging = _roadrunner.Logger_enablePythonLogging

def Logger_disablePythonLogging():
    return _roadrunner.Logger_disablePythonLogging()
Logger_disablePythonLogging = _roadrunner.Logger_disablePythonLogging

class Compiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Compiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Compiler, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getCompiler(self):
        return _roadrunner.Compiler_getCompiler(self)

    def setCompiler(self, compiler):
        return _roadrunner.Compiler_setCompiler(self, compiler)

    def getCompilerLocation(self):
        return _roadrunner.Compiler_getCompilerLocation(self)

    def setCompilerLocation(self, path):
        return _roadrunner.Compiler_setCompilerLocation(self, path)

    def getSupportCodeFolder(self):
        return _roadrunner.Compiler_getSupportCodeFolder(self)

    def setSupportCodeFolder(self, path):
        return _roadrunner.Compiler_setSupportCodeFolder(self, path)

    def getDefaultTargetTriple(self):
        return _roadrunner.Compiler_getDefaultTargetTriple(self)

    def getProcessTriple(self):
        return _roadrunner.Compiler_getProcessTriple(self)

    def getHostCPUName(self):
        return _roadrunner.Compiler_getHostCPUName(self)

    def getVersion(self):
        return _roadrunner.Compiler_getVersion(self)
    if _newclass:
        getDefaultCompiler = staticmethod(_roadrunner.Compiler_getDefaultCompiler)
    else:
        getDefaultCompiler = _roadrunner.Compiler_getDefaultCompiler
    if _newclass:
        New = staticmethod(_roadrunner.Compiler_New)
    else:
        New = _roadrunner.Compiler_New
    __swig_destroy__ = _roadrunner.delete_Compiler
    __del__ = lambda self: None
Compiler_swigregister = _roadrunner.Compiler_swigregister
Compiler_swigregister(Compiler)

def Compiler_getDefaultCompiler():
    return _roadrunner.Compiler_getDefaultCompiler()
Compiler_getDefaultCompiler = _roadrunner.Compiler_getDefaultCompiler

def Compiler_New():
    return _roadrunner.Compiler_New()
Compiler_New = _roadrunner.Compiler_New

class EventListener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EventListener, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    HALT_SIMULATION = _roadrunner.EventListener_HALT_SIMULATION
EventListener_swigregister = _roadrunner.EventListener_swigregister
EventListener_swigregister(EventListener)

class ExecutableModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExecutableModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExecutableModel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def getExecutableModelDesc(self):
        return _roadrunner.ExecutableModel_getExecutableModelDesc(self)

    def getModelName(self):
        """

        ExecutableModel.getModelName()

        Get the model name specified in the SBML.

        """
        return _roadrunner.ExecutableModel_getModelName(self)


    def setTime(self, _time):
        """

        ExecutableModel.setTime(time)

        Set the model time variable.

        :param time: time the time value to set.

        """
        return _roadrunner.ExecutableModel_setTime(self, _time)


    def getTime(self):
        """

        ExecutableModel.getTime()

        Get the model time. The model originally start at time t=0 and is advaced forward in time by the
        integrator. So, if one ran a simulation from time = 0 to time = 10, the model will then have it's
        time = 10.

        """
        return _roadrunner.ExecutableModel_getTime(self)


    def getNumDepFloatingSpecies(self):
        return _roadrunner.ExecutableModel_getNumDepFloatingSpecies(self)

    def getNumFloatingSpecies(self):
        """

        ExecutableModel.getNumFloatingSpecies()

        Returns the number of floating species in the model.

        """
        return _roadrunner.ExecutableModel_getNumFloatingSpecies(self)


    def getNumIndFloatingSpecies(self):
        return _roadrunner.ExecutableModel_getNumIndFloatingSpecies(self)

    def getNumBoundarySpecies(self):
        """

        ExecutableModel.getNumBoundarySpecies()

        Returns the number of boundary species in the model.

        """
        return _roadrunner.ExecutableModel_getNumBoundarySpecies(self)


    def getNumGlobalParameters(self):
        """

        ExecutableModel.getNumGlobalParameters()


        Returns the number of global parameters in the model.

        """
        return _roadrunner.ExecutableModel_getNumGlobalParameters(self)


    def setGlobalParameterInitValues(self, len, values):
        return _roadrunner.ExecutableModel_setGlobalParameterInitValues(self, len, values)

    def getGlobalParameterInitValues(self, len, values):
        return _roadrunner.ExecutableModel_getGlobalParameterInitValues(self, len, values)

    def getNumCompartments(self):
        """

        ExecutableModel.getNumCompartments()

        Returns the number of compartments in the model.

        :rtype: int

        """
        return _roadrunner.ExecutableModel_getNumCompartments(self)


    def getSupportedIdTypes(self):
        return _roadrunner.ExecutableModel_getSupportedIdTypes(self)

    def getValue(self, id):
        return _roadrunner.ExecutableModel_getValue(self, id)

    def setValue(self, id, value):
        return _roadrunner.ExecutableModel_setValue(self, id, value)

    def getStoichiometry(self, speciesIndex, reactionIndex):
        """

        ExecutableModel.getStoichiometry(speciesIndex, reactionIndex)

        Returns the stochiometric coefficient for the given species index and reaction index.

        Frequently one does not need the full stochiometrix matrix, particularly if the system is
        large and only a single coefficient is needed.


        :param speciesIndex: a floating species index from :meth:`getFloatingSpeciesIds`
        :param reactionIndex: a reaction index from :meth:`getReactionIds`


        Conserved Moieties
        ------------------

        """
        return _roadrunner.ExecutableModel_getStoichiometry(self, speciesIndex, reactionIndex)


    def getNumConservedMoieties(self):
        """

        ExecutableModel.getNumConservedMoieties()

        Returns the number of conserved moieties in the model.

        :rtype: int

        """
        return _roadrunner.ExecutableModel_getNumConservedMoieties(self)


    def getNumRateRules(self):
        return _roadrunner.ExecutableModel_getNumRateRules(self)

    def getRateRuleSymbols(self):
        return _roadrunner.ExecutableModel_getRateRuleSymbols(self)

    def getNumReactions(self):
        """

        ExecutableModel.getNumReactions()

        Returns the number of reactions in the model.

        """
        return _roadrunner.ExecutableModel_getNumReactions(self)


    def getInfo(self):
        """

        ExecutableModel.getInfo()

        get various info about the model.

        """
        return _roadrunner.ExecutableModel_getInfo(self)


    def getNumEvents(self):
        return _roadrunner.ExecutableModel_getNumEvents(self)

    def applyEvents(self, timeEnd, previousEventStatus, initialState, finalState):
        return _roadrunner.ExecutableModel_applyEvents(self, timeEnd, previousEventStatus, initialState, finalState)

    def getEventRoots(self, time, y, gdot):
        return _roadrunner.ExecutableModel_getEventRoots(self, time, y, gdot)
    __swig_destroy__ = _roadrunner.delete_ExecutableModel
    __del__ = lambda self: None

    def getEventIndex(self, eid):
        return _roadrunner.ExecutableModel_getEventIndex(self, eid)

    def getEventId(self, index):
        return _roadrunner.ExecutableModel_getEventId(self, index)

    def setEventListener(self, index, eventHandler):
        return _roadrunner.ExecutableModel_setEventListener(self, index, eventHandler)

    def getFloatingSpeciesAmountRate(self, index, reactionRates):
        return _roadrunner.ExecutableModel_getFloatingSpeciesAmountRate(self, index, reactionRates)

    def reset(self, *args):
        """

        ExecutableModel.reset()

        Reset the floating species concentration to their initial conditions.

        """
        return _roadrunner.ExecutableModel_reset(self, *args)


    def setRandomSeed(self, arg2):
        return _roadrunner.ExecutableModel_setRandomSeed(self, arg2)

    def getRandomSeed(self):
        return _roadrunner.ExecutableModel_getRandomSeed(self)

    def getRandom(self):
        return _roadrunner.ExecutableModel_getRandom(self)

    def getFlags(self):
        return _roadrunner.ExecutableModel_getFlags(self)

    def setFlags(self, arg2):
        return _roadrunner.ExecutableModel_setFlags(self, arg2)
    INTEGRATION = _roadrunner.ExecutableModel_INTEGRATION
    OPTIMIZE_REACTION_RATE_SELECTION = _roadrunner.ExecutableModel_OPTIMIZE_REACTION_RATE_SELECTION

    def getIds(self, types):
        return _roadrunner.ExecutableModel_getIds(self, types)

    def getFloatingSpeciesAmounts(self, *args):
        """

        ExecutableModel.getFloatingSpeciesAmounts([index])

        Get the list of floating species amounts. If no arguments are given, this
        returns all floating species amounts.

        :param index: an optional array of desired floating species indices. i.e. if this model has
                      4 floating species and we want the amounts for the last and first, we
                      would use [3,0] for the index array.
        :type name: numpy.ndarray

        get all the amounts::

          >>> e.getFloatingSpeciesAmounts()
          [15,2,3,20]

        get amounts 3 and 0::

          >>> getFloatingSpeciesAmounts([3,0])
          [10,15]

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesAmounts(self, *args)


    def getFloatingSpeciesConcentrationRates(self, *args):
        return _roadrunner.ExecutableModel_getFloatingSpeciesConcentrationRates(self, *args)

    def getFloatingSpeciesConcentrations(self, *args):
        """

        ExecutableModel.getFloatingSpeciesConcentrations([index])

        Returns a vector of floating species concentrations. The order of species is
        given by the order of Ids returned by getFloatingSpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of floating species concentrations.
        :rtype: numpy.ndarray

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesConcentrations(self, *args)


    def getBoundarySpeciesAmounts(self, *args):
        """

        ExecutableModel.getBoundarySpeciesAmounts([index])

        Returns a vector of boundary species amounts. The order of species is
        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species amounts.
        :rtype: numpy.ndarray.

        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species amounts.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesAmounts(self, *args)


    def getBoundarySpeciesConcentrations(self, *args):
        """

        ExecutableModel.getBoundarySpeciesConcentrations([index])

        Returns a vector of boundary species concentrations. The order of species is
        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species concentrations.
        :rtype: numpy.ndarray.

        given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of the boundary species concentrations.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesConcentrations(self, *args)


    def getGlobalParameterValues(self, *args):
        """

        ExecutableModel.getGlobalParameterValues([index])

        Return a vector of global parameter values. The order of species is
        given by the order of Ids returned by getGlobalParameterIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of global parameter values.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getGlobalParameterValues(self, *args)


    def getCompartmentVolumes(self, *args):
        """

        ExecutableModel.getCompartmentVolumes([index])

        Returns a vector of compartment volumes. The order of volumes is
        given by the order of Ids returned by getCompartmentIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of compartment volumes.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getCompartmentVolumes(self, *args)


    def getConservedMoietyValues(self, *args):
        """

        ExecutableModel.getConservedMoietyValues([index])

        Returns a vector of conserved moiety volumes. The order of values is
        given by the order of Ids returned by getConservedMoietyIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of conserved moiety values.
        :rtype: numpy.ndarray.

        """
        return _roadrunner.ExecutableModel_getConservedMoietyValues(self, *args)


    def getReactionRates(self, *args):
        """

        ExecutableModel.getReactionRates([index])

        Returns a vector of reaction rates (reaction velocity) for the current state of the model. The
        order of reaction rates is given by the order of Ids returned by getReactionIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of reaction rates.
        :rtype: numpy.ndarray



        Stoichiometry
        -------------

        """
        return _roadrunner.ExecutableModel_getReactionRates(self, *args)


    def getFloatingSpeciesInitConcentrations(self):
        """

        ExecutableModel.getFloatingSpeciesInitConcentrations([index])

        Returns a vector of floating species initial concentrations. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialConcentrationIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of floating species initial concentrations.
        :rtype: numpy.ndarray

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitConcentrations(self)


    def getFloatingSpeciesInitAmounts(self):
        """

        ExecutableModel.getFloatingSpeciesInitAmounts([index])

        Returns a vector of floating species initial amounts. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialConcentrationIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: an array of floating species initial amounts.
        :rtype: numpy.ndarray

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitAmounts(self)


    def getCompartmentInitVolumes(self):
        return _roadrunner.ExecutableModel_getCompartmentInitVolumes(self)

    def getFloatingSpeciesIds(self):
        """

        ExecutableModel.getFloatingSpeciesIds()

        Return a list of floating species sbml ids.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesIds(self)


    def getFloatingSpeciesConcentrationIds(self):
        """

        ExecutableModel.getFloatingSpeciesConcentrationIds()

        Return a list of floating species concentration ids.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesConcentrationIds(self)


    def getBoundarySpeciesIds(self):
        """

        ExecutableModel.getBoundarySpeciesIds()

        Returns a vector of boundary species Ids.

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: a list of boundary species ids.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesIds(self)


    def getBoundarySpeciesConcentrationIds(self):
        """

        ExecutableModel.getBoundarySpeciesConcentrationIds()

        Returns a vector of boundary species concentration Ids.

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: a list of boundary species ids.

        """
        return _roadrunner.ExecutableModel_getBoundarySpeciesConcentrationIds(self)


    def getGlobalParameterIds(self):
        """

        ExecutableModel.getGlobalParameterIds([index])

        Return a list of global parameter ids.

        :returns: a list of global parameter ids.

        """
        return _roadrunner.ExecutableModel_getGlobalParameterIds(self)


    def getCompartmentIds(self):
        """

        ExecutableModel.getCompartmentIds([index])

        Returns a vector of compartment identifier symbols.

        :param index: A array of compartment indices indicating which compartment ids to return.
        :type index: None or numpy.ndarray
        :returns: a list of compartment ids.

        """
        return _roadrunner.ExecutableModel_getCompartmentIds(self)


    def getConservedMoietyIds(self):
        """

        ExecutableModel.getConservedMoietyIds([index])

        Returns a vector of conserved moiety identifier symbols.


        :param index: A array of compartment indices indicating which compartment ids to return.
        :type index: None or numpy.ndarray
        :returns: a list of compartment ids.

        """
        return _roadrunner.ExecutableModel_getConservedMoietyIds(self)


    def getReactionIds(self):
        """

        ExecutableModel.getReactionIds()

        Returns a vector of reaction Ids.

        :param numpy.ndarray index: (optional) an index array indicating which items to return.
        :returns: a list of reaction ids.

        """
        return _roadrunner.ExecutableModel_getReactionIds(self)


    def getFloatingSpeciesInitAmountIds(self):
        """

        ExecutableModel.getFloatingSpeciesInitAmountIds()

        get a list of the floating species amount initial amount selection symbols.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitAmountIds(self)


    def getFloatingSpeciesInitConcentrationIds(self):
        """

        ExecutableModel.getFloatingSpeciesInitConcentrationIds()

        get a list of the floating species amount initial concentration selection symbols.

        """
        return _roadrunner.ExecutableModel_getFloatingSpeciesInitConcentrationIds(self)


    def getEventIds(self):
        """

        ExecutableModel.getEventIds()

        Returns a list of event ids.

        :returns: a list of event ids.


        Misc
        ----

        """
        return _roadrunner.ExecutableModel_getEventIds(self)


    def getAllTimeCourseComponentIds(self):
        """

        ExecutableModel.getAllTimeCourseComponentIds([index])

        Return a list of all component ids. The list includes ids of amount/concentration of
        floating species, boundary species, global parameters, compartments, and reactions, as well as `time`.

        :returns: a list of all component ids widely used in time course selections.

        """

        return (['time'] + self.getFloatingSpeciesIds() + self.getBoundarySpeciesIds()
        + self.getFloatingSpeciesConcentrationIds() + self.getBoundarySpeciesConcentrationIds()
        + self.getGlobalParameterIds() + self.getCompartmentIds() + self.getReactionIds())


    def setFloatingSpeciesAmounts(self, *args):
        """

        ExecutableModel.setFloatingSpeciesAmounts([index], values)

        Use this to set the entire set of floating species amounts in one call.
        The order of species is given by the order of Ids returned by getFloatingSpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be
                                    an array of all the values to set.
        :param numpy.ndarray values: the values to set.

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesAmounts(self, *args)


    def setFloatingSpeciesConcentrations(self, *args):
        """

        ExecutableModel.setFloatingSpeciesConcentrations([index], values)

        Use this to set the entire set of floating species concentrations in one call.
        The order of species is given by the order of Ids returned by getFloatingSpeciesIds()


        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.
        :param numpy.ndarray values: the values to set.

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesConcentrations(self, *args)


    def setBoundarySpeciesConcentrations(self, *args):
        """

        ExecutableModel.setBoundarySpeciesConcentrations([index], values)

        Use this to set the entire set of boundary species concentrations in one call.
        The order of species is given by the order of Ids returned by getBoundarySpeciesIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.

        :param numpy.ndarray values: the values to set.

        Compartments
        ------------

        """
        return _roadrunner.ExecutableModel_setBoundarySpeciesConcentrations(self, *args)


    def setGlobalParameterValues(self, *args):
        """

        ExecutableModel.setGlobalParameterValues([index], values)

        Use this to set the entire set of global parameters in one call.
        The order of parameters is given by the order of Ids returned by getGlobalParameterIds()


        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the values to set.
        :param numpy.ndarray values: the values to set.

        Reactions
        ---------

        """
        return _roadrunner.ExecutableModel_setGlobalParameterValues(self, *args)


    def setCompartmentVolumes(self, *args):
        """

        ExecutableModel.setCompartmentVolumes([index], values)

        Sets a vector of compartment volumes.

        If the index vector is not give, then the values vector treated as a vector of all
        compartment volumes to set. If index is given, then  values should have the same
        length as index.

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.

        :param numpy.ndarray values: the values to set.



        Global Parameters
        -----------------

        """
        return _roadrunner.ExecutableModel_setCompartmentVolumes(self, *args)


    def setConservedMoietyValues(self, *args):
        """

        ExecutableModel.setConservedMoietyValues([index], values)

        Sets a vector of conserved moiety values.

        *Note* This method currently only updates the conserved moiety values, it does
        not update the initial species condition from which the values were calculated.

        If the index vector is not given, then the values vector treated as a vector of all
        values to set. If index is given, then  values should have the same
        length as index.

        :param numpy.ndarray index: (optional) an index array indicating which items to set,
                                    or if no index array is given, the first param should be an
                                    array of all the  values to set.
        :param numpy.ndarray values: the values to set.



        Events
        ------------------

        """
        return _roadrunner.ExecutableModel_setConservedMoietyValues(self, *args)


    def setFloatingSpeciesInitConcentrations(self, *args):
        """

        ExecutableModel.setFloatingSpeciesInitConcentrations([index], values)

        Set a vector of floating species initial concentrations. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialAmountIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesInitConcentrations(self, *args)


    def setFloatingSpeciesInitAmounts(self, *args):
        """

        ExecutableModel.setFloatingSpeciesInitAmounts([index], values)

        Set a vector of floating species initial amounts. The order of species is
        given by the order of Ids returned by getFloatingSpeciesInitialAmountIds()

        :param numpy.ndarray index: (optional) an index array indicating which items to return.




        Boundary Species
        ----------------

        """
        return _roadrunner.ExecutableModel_setFloatingSpeciesInitAmounts(self, *args)


    def setCompartmentInitVolumes(self, *args):
        return _roadrunner.ExecutableModel_setCompartmentInitVolumes(self, *args)

    def getCurrentStoichiometryMatrix(self):
        return _roadrunner.ExecutableModel_getCurrentStoichiometryMatrix(self)

    def __getitem__(self, id):
        return _roadrunner.ExecutableModel___getitem__(self, id)

    def __setitem__(self, id, value):
        return _roadrunner.ExecutableModel___setitem__(self, id, value)

    def __repr__(self):
        return _roadrunner.ExecutableModel___repr__(self)

    def getEvent(self, *args):
        return _roadrunner.ExecutableModel_getEvent(self, *args)


    def keys(self, types=_roadrunner.SelectionRecord_ALL):
        return self.getIds(types)

    def values(self, types=_roadrunner.SelectionRecord_ALL):
        return [self.getValue(k) for k in self.keys(types)]

    def items(self, types=_roadrunner.SelectionRecord_ALL):
        return [(k, self.getValue(k)) for k in self.keys(types)]

    def __len__(self):
        return len(self.keys())

    def iteritems(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over (key, value) pairs
        """
        return self.items(types).__iter__()

    def iterkeys(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's keys
        """
        return self.keys(types).__iter__()

    def itervalues(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's values
        """
        return self.values(types).__iter__()

ExecutableModel_swigregister = _roadrunner.ExecutableModel_swigregister
ExecutableModel_swigregister(ExecutableModel)

class ExecutableModelFactory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExecutableModelFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExecutableModelFactory, name)
    __repr__ = _swig_repr
    if _newclass:
        createModel = staticmethod(_roadrunner.ExecutableModelFactory_createModel)
    else:
        createModel = _roadrunner.ExecutableModelFactory_createModel

    def __init__(self):
        this = _roadrunner.new_ExecutableModelFactory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_ExecutableModelFactory
    __del__ = lambda self: None
ExecutableModelFactory_swigregister = _roadrunner.ExecutableModelFactory_swigregister
ExecutableModelFactory_swigregister(ExecutableModelFactory)

def ExecutableModelFactory_createModel(sbml, dict=None):
    return _roadrunner.ExecutableModelFactory_createModel(sbml, dict)
ExecutableModelFactory_createModel = _roadrunner.ExecutableModelFactory_createModel

VERSIONSTR_BASIC = _roadrunner.VERSIONSTR_BASIC
VERSIONSTR_COMPILER = _roadrunner.VERSIONSTR_COMPILER
VERSIONSTR_DATE = _roadrunner.VERSIONSTR_DATE
VERSIONSTR_LIBSBML = _roadrunner.VERSIONSTR_LIBSBML
VERSIONSTR_JITCOMPILER = _roadrunner.VERSIONSTR_JITCOMPILER
VERSIONSTR_GIT_BRANCH = _roadrunner.VERSIONSTR_GIT_BRANCH
VERSIONSTR_GIT_COMMIT = _roadrunner.VERSIONSTR_GIT_COMMIT

def getVersionStr(*args):
    return _roadrunner.getVersionStr(*args)
getVersionStr = _roadrunner.getVersionStr

def getCopyrightStr():
    return _roadrunner.getCopyrightStr()
getCopyrightStr = _roadrunner.getCopyrightStr
class RoadRunner(_object):
    """

    RoadRunner.__init__(uriOrSBML = , options = None)

    Creates a new RoadRunner object. If the first argument is specified,
    it should be a string containing either the contents of an SBML document,
    or a formatted URI specifying the path or location of a SBML document.

    If options is given, it should be a LoadSBMLOptions object.

    If no arguments are given, a document may be loaded at any future time
    using the load method.

    :param uriOrSBML: a URI, local path or SBML document contents.
    :type name: str (optional)

    :param options: (LoadSBMLOptions) an options object specifying how the
                    SBML document should be loaded
    :type name: str (optional)

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoadRunner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoadRunner, name)

    def __init__(self, *args):
        this = _roadrunner.new_RoadRunner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_RoadRunner
    __del__ = lambda self: None

    def getInstanceID(self):
        """

        RoadRunner.getInstanceID()

        When there are multiple instances of RoadRunner, this is the instance id.

        """
        return _roadrunner.RoadRunner_getInstanceID(self)


    def getInstanceCount(self):
        """

        RoadRunner.getInstanceCount()

        Number of currently running RoadRunner instances.

        """
        return _roadrunner.RoadRunner_getInstanceCount(self)


    def getParamPromotedSBML(sArg):
        """

        RoadRunner.getParamPromotedSBML(*args)

        Takes an SBML document or path to an SBML document and changes all of the local parameters
        to be global parameters.

        :param str SBML: the contents or path to an SBML document
        :rtype: str

        """
        return _roadrunner.RoadRunner_getParamPromotedSBML(sArg)

    getParamPromotedSBML = staticmethod(getParamPromotedSBML)

    def getInfo(self):
        """

        RoadRunner.getInfo()

        return info about the current state of the object

        :rtype: str

        """
        return _roadrunner.RoadRunner_getInfo(self)


    def getCompiler(self):
        """

        RoadRunner.getCompiler()

        Return the JIT :class:`Compiler` object currently being used.
        This object provides various information about the current processor and system.

        """
        return _roadrunner.RoadRunner_getCompiler(self)


    def getIntegrator(self):
        """

        RoadRunner.getIntegrator()

        get the integrator which is currently being used to
        time evolve the system.

        """
        return _roadrunner.RoadRunner_getIntegrator(self)


    def getIntegratorByName(self, name):
        return _roadrunner.RoadRunner_getIntegratorByName(self, name)

    def makeIntegrator(self, name):
        return _roadrunner.RoadRunner_makeIntegrator(self, name)

    def getSteadyStateSolver(self):
        return _roadrunner.RoadRunner_getSteadyStateSolver(self)

    def getExistingIntegratorNames(self):
        return _roadrunner.RoadRunner_getExistingIntegratorNames(self)
    if _newclass:
        getRegisteredIntegratorNames = staticmethod(_roadrunner.RoadRunner_getRegisteredIntegratorNames)
    else:
        getRegisteredIntegratorNames = _roadrunner.RoadRunner_getRegisteredIntegratorNames
    if _newclass:
        getRegisteredSteadyStateSolverNames = staticmethod(_roadrunner.RoadRunner_getRegisteredSteadyStateSolverNames)
    else:
        getRegisteredSteadyStateSolverNames = _roadrunner.RoadRunner_getRegisteredSteadyStateSolverNames
    if _newclass:
        ensureSolversRegistered = staticmethod(_roadrunner.RoadRunner_ensureSolversRegistered)
    else:
        ensureSolversRegistered = _roadrunner.RoadRunner_ensureSolversRegistered

    def setIntegrator(self, name):
        return _roadrunner.RoadRunner_setIntegrator(self, name)

    def integratorExists(self, name):
        return _roadrunner.RoadRunner_integratorExists(self, name)

    def setSteadyStateSolver(self, name):
        return _roadrunner.RoadRunner_setSteadyStateSolver(self, name)

    def steadyStateSolverExists(self, name):
        return _roadrunner.RoadRunner_steadyStateSolverExists(self, name)

    def isModelLoaded(self):
        """

        RoadRunner.isModelLoaded()

        Return True if model was loaded; False otherwise

        """
        return _roadrunner.RoadRunner_isModelLoaded(self)


    def clearModel(self):
        return _roadrunner.RoadRunner_clearModel(self)

    def oneStep(self, currentTime, stepSize, reset=True):
        """

        RoadRunner.oneStep(startTime, stepSize)

        Carry out a one step integration of the model. The method takes two arguments,
        the current time and the step size to us in the integration. The method returns
        the new time which will be currentTime + StepSize::

            newTime = rr.oneStep (10, 0.5)

        """
        return _roadrunner.RoadRunner_oneStep(self, currentTime, stepSize, reset)


    def internalOneStep(self, currentTime, stepSize, reset=True):
        return _roadrunner.RoadRunner_internalOneStep(self, currentTime, stepSize, reset)

    def getSimulationData(self):
        return _roadrunner.RoadRunner_getSimulationData(self)

    def setOptions(self, arg2):
        return _roadrunner.RoadRunner_setOptions(self, arg2)

    def getSBML(self, level=0, version=0):
        """

        RoadRunner.getSBML()

        Returns the original SBML model that was loaded into roadrunner.

        :rtype: str

        Selections
        ----------

        """
        return _roadrunner.RoadRunner_getSBML(self, level, version)


    def getCurrentSBML(self, level=0, version=0):
        """

        RoadRunner.getCurrentSBML()

        Returns the current state of the model in the form of an SBML string.

        That is the SBML will reflect the current state of the model and not the
        original SBML that was loaded into RoadRunner.

        :rtype: str

        """
        return _roadrunner.RoadRunner_getCurrentSBML(self, level, version)


    def reset(self, *args):
        """

        RoadRunner.reset()

        This method resets all the floating species concentrations to their initial values.

        """
        return _roadrunner.RoadRunner_reset(self, *args)


    def resetSelectionLists(self):
        """

        RoadRunner.resetSelectionLists()

        Resets time course and steady state selection lists to defaults



        Model Access
        ------------

        """
        return _roadrunner.RoadRunner_resetSelectionLists(self)


    def _getModel(self):
        """

        RoadRunner.getModel()

        Function form of the RoadRunner.model property, identical to model.

        """
        return _roadrunner.RoadRunner__getModel(self)


    def _load(self, uriOrSBML, options=None):
        """

        RoadRunner.load(uriOrDocument)

        Loads an SBML document, given a string for file path, URI, or contents.

        This method also accepts HTTP URI for remote files, however this feature is currently limited
        to the Mac version, plan on enabling HTTP loading of SBML documents on Windows and Linux
        shortly.

        Some examples of loading files on Mac or Linux::

            >>> r.load("myfile.xml")                               # load a file from the current directory
            >>> r.load("/Users/Fred/myfile.xml")                   # absolute path
            >>> r.load("http://sbml.org/example_system.xml")       # remote file


        Or on Windows:

            >>> r.load("myfile.xml")                                  # load a file from the current directory
            >>> r.load("file://localhost/c:/Users/Fred/myfile.xml")   # using a URI

        One may also load the contents of a document::

            >>> myfile = open("myfile.xml, "r")
            >>> contents = file.read()
            >>> r.load(contents)

        In future version, we will also support loading directly from a libSBML Document object.

        :param uriOrDocument: A string which may be a local path, URI or contents of an SBML document.
        :type name: str

        """
        return _roadrunner.RoadRunner__load(self, uriOrSBML, options)


    def createSelection(self, str):
        """

        RoadRunner.createSelection(sel)

        Create a new selection based on a selection string

        :rtype: roadrunner.SelectionRecord

        """
        return _roadrunner.RoadRunner_createSelection(self, str)


    def _setSelections(self, selections):
        return _roadrunner.RoadRunner__setSelections(self, selections)

    def getSelectedValues(self):
        """

        RoadRunner.getSelectedValues()

        returns the values selected with SimulateOptions for the current model time / timestep

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getSelectedValues(self)


    def _getIndependentFloatingSpeciesIds(self):
        return _roadrunner.RoadRunner__getIndependentFloatingSpeciesIds(self)

    def _getDependentFloatingSpeciesIds(self):
        return _roadrunner.RoadRunner__getDependentFloatingSpeciesIds(self)

    def getFloatingSpeciesInitialConcentrationIds(self):
        return _roadrunner.RoadRunner_getFloatingSpeciesInitialConcentrationIds(self)

    def getSupportedIdTypes(self):
        """

        RoadRunner.getSupportedIdTypes()

        Returns a bitfield representing the element ID types which can be used with e.g.
        RoadRunner.getValue

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getSupportedIdTypes(self)


    def setValue(self, id, value):
        return _roadrunner.RoadRunner_setValue(self, id, value)

    def getFloatingSpeciesAmountsNamedArray(self):
        return _roadrunner.RoadRunner_getFloatingSpeciesAmountsNamedArray(self)

    def getFloatingSpeciesConcentrationsNamedArray(self):
        return _roadrunner.RoadRunner_getFloatingSpeciesConcentrationsNamedArray(self)

    def getBoundarySpeciesAmountsNamedArray(self):
        return _roadrunner.RoadRunner_getBoundarySpeciesAmountsNamedArray(self)

    def getBoundarySpeciesConcentrationsNamedArray(self):
        return _roadrunner.RoadRunner_getBoundarySpeciesConcentrationsNamedArray(self)

    def getRatesOfChange(self):
        """

        RoadRunner::getRatesOfChange()

        Returns the rates of change of all floating species. The order of species is 
        given by the order of Ids returned by getFloatingSpeciesIds()

        :returns: a named array of floating species rates of change.
        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getRatesOfChange(self)


    def getIndependentRatesOfChange(self):
        """

        RoadRunner::getIndependentRatesOfChange()

        Returns the rates of change of all independent floating species. The order of species is 
        given by the order of Ids returned by getIndependentFloatingSpeciesIds()

        :returns: a named array of independent floating species rates of change.
        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getIndependentRatesOfChange(self)


    def getDependentRatesOfChange(self):
        """

        RoadRunner::getDependentRatesOfChange()

        Returns the rates of change of all dependent floating species. The order of species is 
        given by the order of Ids returned by getDependentFloatingSpeciesIds()

        :returns: a named array of dependent floating species rates of change.
        :rtype: numpy.ndarray



        Floating Species Initial Conditions
        -----------------------------------
        RoadRunner stores all initial conditions separately from the model state variables. This means that
        you can update the initial conditions at any time, and it does not affect the current state of the
        model. To reset the model, that is, reset it to its original state, or a new original state where
        what has changed the initial conditions use the :meth:`~ExecutableModel.reset()` method.

        The following methods allow access to the floating species initial condition values:

        """
        return _roadrunner.RoadRunner_getDependentRatesOfChange(self)


    def getFullJacobian(self):
        """

        RoadRunner.getFullJacobian()

        Compute the full Jacobian at the current operating point.

        This is the Jacobian of ONLY the floating species.

        """
        return _roadrunner.RoadRunner_getFullJacobian(self)


    def getReducedJacobian(self, h=-1.0):
        """

        RoadRunner.getReducedJacobian()

        Returns the *reduced* Jacobian for the independent species. This matrix will be non-singular
        for models that include moiety-conserved cycles.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getReducedJacobian(self, h)


    def getFullEigenValues(self):
        """

        RoadRunner.getFullEigenValues()


        Calculates the eigen values of the Full Jacobian as a real matrix, first column real part, second
        column imaginary part.

        Note, only valid for pure reaction kinetics models (no rate rules, no floating species rules and
        time invariant stoichiometry).

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getFullEigenValues(self)


    def getReducedEigenValues(self):
        """

        RoadRunner.getReducedEigenValues()


        Calculates the eigen values of the Reduced Jacobian as a real matrix, first column real part, second
        column imaginary part.

        Only valid if moiety conversion is enabled.

        Note, only valid for pure reaction kinetics models (no rate rules, no floating species rules and
        time invariant stoichiometry).

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getReducedEigenValues(self)


    def getLinkMatrix(self):
        """

        RoadRunner.getLinkMatrix()

        Returns the full link matrix, L for the current model. The Link matrix is an m by r matrix where m
        is the number of floating species and r the rank of the stoichiometric matrix, N.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getLinkMatrix(self)


    def getNrMatrix(self):
        """

        RoadRunner.getNrMatrix()

        Returns the reduced stoichiometry matrix, :math:`N_R`, which will have only r rows where r is the rank of
        the full stoichiometry matrix. The matrix will be reordered such that the rows of :math:`N_R` are independent.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getNrMatrix(self)


    def getKMatrix(self):
        """

        RoadRunner.getKMatrix()

        Returns the K matrix, :math:`ker(N_R)`, (right nullspace of Nr)
        The K matrix has the structure, :math:`[I K0]'`

        :rtype: numpy.ndarray


        Analysis
        --------

        """
        return _roadrunner.RoadRunner_getKMatrix(self)


    def getReducedStoichiometryMatrix(self):
        """

        RoadRunner.getReducedStoichiometryMatrix()

        get the reduced stochiometry matrix. If conservation conversion is enabled,
        this is the matrix that coresponds to the independent species.

        A synonym for getNrMatrix().

        """
        return _roadrunner.RoadRunner_getReducedStoichiometryMatrix(self)


    def getFullStoichiometryMatrix(self):
        """

        RoadRunner.getFullStoichiometryMatrix()


        Get the stoichiometry matrix that coresponds to the full model, even it
        it was converted via conservation conversion.

        """
        return _roadrunner.RoadRunner_getFullStoichiometryMatrix(self)


    def getExtendedStoichiometryMatrix(self):
        """

        RoadRunner.getExtendedStoichiometryMatrix()


        Returns the full stoichiometric matrix plus additional rows for boundary
        species and source/sink nodes. Use this if you want to apply detailed
        balance to the network as a whole.

        """
        return _roadrunner.RoadRunner_getExtendedStoichiometryMatrix(self)


    def getL0Matrix(self):
        """

        RoadRunner.getL0Matrix()

        Returns the L0 matrix for the current model. The L0 matrix is an (m-r) by r matrix that expresses
        the dependent reaction rates in terms of the independent rates. m is the number of floating species
        and r is the rank of the stoichiometry matrix.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getL0Matrix(self)


    def getConservationMatrix(self):
        """

        RoadRunner.getConservationMatrix()

        Returns a conservation matrix :math:`\\Gamma` which is a :math:`c \\times m` matrix
        where :math:`c` is the number of conservation laws and :math:`m` the number of species.

        """
        return _roadrunner.RoadRunner_getConservationMatrix(self)


    def getUnscaledConcentrationControlCoefficientMatrix(self):
        """

        RoadRunner.getUnscaledConcentrationControlCoefficientMatrix()

        Returns the unscaled concentration control coefficient matrix.

        """
        return _roadrunner.RoadRunner_getUnscaledConcentrationControlCoefficientMatrix(self)


    def getScaledConcentrationControlCoefficientMatrix(self):
        """

        RoadRunner.getScaledConcentrationControlCoefficientMatrix()

        Returns the m by n matrix of scaled concentration control coefficients where m is the number
        of floating species and n the number of reactions.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getScaledConcentrationControlCoefficientMatrix(self)


    def getUnscaledFluxControlCoefficientMatrix(self):
        """

        RoadRunner.getUnscaledFluxControlCoefficientMatrix()

        Returns the unscaled flux control coefficient matrix.

        """
        return _roadrunner.RoadRunner_getUnscaledFluxControlCoefficientMatrix(self)


    def getScaledFluxControlCoefficientMatrix(self):
        """

        RoadRunner.getScaledFluxControlCoefficientMatrix()

        Returns the n by n matrix of scaled flux control coefficients where n is the number of reactions.

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getScaledFluxControlCoefficientMatrix(self)


    def getEigenValueIds(self):
        """

        RoadRunner.getEigenValueIds()

        returns a list of selection symbols for the eigenvalues of the floating species. The eigen value
        selection symbol is ``eigen(XX)``, where ``XX`` is the floating species name.

        """
        return _roadrunner.RoadRunner_getEigenValueIds(self)


    def getUnscaledParameterElasticity(self, reactionName, parameterName):
        """

        RoadRunner.getUnscaledParameterElasticity(reactionId, parameterId)

         Returns the unscaled elasticity for a named reaction with respect to a
         named parameter

        :param str reactionId: the SBML id of a reaction.
        :param str parameterId: the SBML id of a parameter.
        :rtype: double

        """
        return _roadrunner.RoadRunner_getUnscaledParameterElasticity(self, reactionName, parameterName)


    def getFrequencyResponse(self, startFrequency, numberOfDecades, numberOfPoints, parameterName, variableName, useDB, useHz):
        """

        RoadRunner.getFrequencyResponse(startFrequency, numberOfDecades, numberOfPoints, parameterName, variableName, useDB, useHz)

        Compute the frequency response

        :rtype: numpy.ndarray

        """
        return _roadrunner.RoadRunner_getFrequencyResponse(self, startFrequency, numberOfDecades, numberOfPoints, parameterName, variableName, useDB, useHz)


    def _setConservedMoietyAnalysis(self, value):
        return _roadrunner.RoadRunner__setConservedMoietyAnalysis(self, value)

    def _getConservedMoietyAnalysis(self):
        return _roadrunner.RoadRunner__getConservedMoietyAnalysis(self)

    def getExtendedVersionInfo():
        """

        RoadRunner.getExtendedVersionInfo()

        getVersion plus info about dependent libs versions.

        """
        return _roadrunner.RoadRunner_getExtendedVersionInfo()

    getExtendedVersionInfo = staticmethod(getExtendedVersionInfo)

    def getDiffStepSize(self):
        """

        RoadRunner.getDiffStepSize()

        Returns the differential step size used in getCC and getuCC. Both functions
        use a 4th order finite difference method for calculating the derivative. The
        default value is 0.05.

          rr.getDiffStepSize ()
          0.05

        :rtype: double

        """
        return _roadrunner.RoadRunner_getDiffStepSize(self)


    def setDiffStepSize(self, val):
        """

        RoadRunner.setDiffStepSize(value)

        Sets the differential step size used in getCC and getuCC.

          rr.setDiffStepSize (0.05)

        """
        return _roadrunner.RoadRunner_setDiffStepSize(self, val)


    def getSteadyStateThreshold(self):
        return _roadrunner.RoadRunner_getSteadyStateThreshold(self)

    def setSteadyStateThreshold(self, val):
        return _roadrunner.RoadRunner_setSteadyStateThreshold(self, val)

    def getuCC(self, variableName, parameterName):
        """

        RoadRunner.getuCC(variableId, parameterId)

        Get unscaled control coefficient with respect to a global parameter.

        :param variableId: must be either a reaction or floating species.

        :param parameterId: must be either a global parameter, boundary species, or
                            conserved sum.

        """
        return _roadrunner.RoadRunner_getuCC(self, variableName, parameterName)


    def getCC(self, variableName, parameterName):
        """

        RoadRunner.getCC(variable, parameter)

        Returns a scaled control coefficient with respect to a global parameter.

        For example::

          rr.getCC ('J1', 'Vmax')
          rr.getCC ('S1', 'Xo')
          rr.getCC ('S2', 'Km')

        The first returns a flux control coefficient with respect to flux J1. The second and third
        return concentration control coefficients with respect to species S1 and S2.

        :param variable: The id of a dependent variable of the coefficient, for example a
                         flux or species concentration.

        :param parameter: The id of the independent parameter, for example a kinetic constant
                          or boundary species

        :returns: the value of the control coefficient returned to the caller.

        :rtype: double

        """
        return _roadrunner.RoadRunner_getCC(self, variableName, parameterName)


    def getuEE(self, *args):
        """

        RoadRunner.getuEE(reactionId, parameterId)

        Get unscaled elasticity coefficient with respect to a global parameter or species.

        """
        return _roadrunner.RoadRunner_getuEE(self, *args)


    def getEE(self, *args):
        """

        RoadRunner.getEE(reactionId, parameterId, steadyState=True)

        Retrieve a single elasticity coefficient with respect to a global parameter.

        For example::

          x = rr.getEE ('J1', 'Vmax')

        :param str variable: The dependent variable of the coefficient, for example a flux or
                             species concentration.
        :param str parameter: The independent parameter, for example a kinetic constant or boundary
                              species
        :param Boolean steadyState: should the steady state value be computed.

        """
        return _roadrunner.RoadRunner_getEE(self, *args)


    def getUnscaledElasticityMatrix(self):
        """

        RoadRunner.getUnscaledElasticityMatrix()

        Returns the unscaled species elasticity matrix at the current operating point.

        """
        return _roadrunner.RoadRunner_getUnscaledElasticityMatrix(self)


    def getScaledElasticityMatrix(self):
        """

        RoadRunner.getScaledElasticityMatrix()

        Returns the scaled elasticity matrix at the current operating point.

        :rtype: numpy.ndarray


        Stochiometric Analysis
        ----------------------

        """
        return _roadrunner.RoadRunner_getScaledElasticityMatrix(self)


    def getScaledFloatingSpeciesElasticity(self, reactionName, speciesName):
        """

        RoadRunner.getScaledFloatingSpeciesElasticity(reactionId, speciesId)

        Returns the scaled elasticity for a given reaction and given species.

        :param str reactionId: the SBML id of a reaction.
        :param str speciesId: the SBML id of a species.
        :rtype: double

        """
        return _roadrunner.RoadRunner_getScaledFloatingSpeciesElasticity(self, reactionName, speciesName)


    def getUnscaledSpeciesElasticity(self, reactionId, speciesIndex):
        """

        RoadRunner.getUnscaledSpeciesElasticity(reactionIndx, speciesIndx)

        Get a single species elasticity value.


        :param int reactionIndx: index of reaction
        :param int speciesIndx: index of species.

        """
        return _roadrunner.RoadRunner_getUnscaledSpeciesElasticity(self, reactionId, speciesIndex)


    def mcaSteadyState(self):
        return _roadrunner.RoadRunner_mcaSteadyState(self)

    def steadyState(self, dict=None):
        """

        RoadRunner.steadyState()

        Attempt to evaluate the steady state for the model. The method returns
        a value that indicates how close the solution is to the steady state.
        The smaller the value the better. Values less than 1E-6 usually indicate a
        steady state has been found. If necessary the method can be called a
        second time to improve the solution.

        :returns: the sum of squares of the steady state solution.

        :rtype: double

        """
        return _roadrunner.RoadRunner_steadyState(self, dict)


    def steadyStateApproximate(self, dict=None):
        """

        RoadRunner.steadyStateApproximate()

        Attempt to approximate the steady state for the model by running integration
        for a specified amount of time. This function is ideal for the case where
        steady state solution does exist but the solver cannot find the 
        solution due to singular Jacobian, etc. The method returns
        a value that indicates how close the solution is to the steady state.
        The smaller the value the better. Values less than 1E-6 usually indicate a
        steady state has been found. If necessary the method can be called a
        second time to improve the solution.

        :returns: the sum of squares of the approximated steady state solution.

        :rtype: double

        """
        return _roadrunner.RoadRunner_steadyStateApproximate(self, dict)


    def steadyStateNamedArray(self, dict=None):
        return _roadrunner.RoadRunner_steadyStateNamedArray(self, dict)

    def _setSteadyStateSelections(self, steadyStateSelections):
        return _roadrunner.RoadRunner__setSteadyStateSelections(self, steadyStateSelections)

    def getSteadyStateValues(self):
        """

        RoadRunner.getSteadyStateValues()

        Performs a steady state calculation (evolves the system to a steady
        state), then calculates and returns the set of values specified by
        the steady state selections. The variable steadyStateSelections is used
        to determine which values are returned.

             >>> rr.steadyStateSelections = ['S1']
             >>> rr.getSteadyStateValues()
             array([ 0.54314239])

        :returns: a numpy array corresponding to the values specified by steadyStateSelections

        :rtype: numpy.ndarray



        Metabolic control analysis
        --------------------------

        In the special case when an SBML model is a purely reaction kinetics model -- no rate rules, no
        assignment rules for chemical species, and time invariant stoichiometry, specialized analysis methods
        related to metabolic control analysis are applicable. These methods are described in this section.

        """
        return _roadrunner.RoadRunner_getSteadyStateValues(self)


    def getSteadyStateSelectionStrings(self):
        return _roadrunner.RoadRunner_getSteadyStateSelectionStrings(self)

    def getSteadyStateValuesNamedArray(self):
        return _roadrunner.RoadRunner_getSteadyStateValuesNamedArray(self)

    def getConservedMoietyValues(self):
        return _roadrunner.RoadRunner_getConservedMoietyValues(self)

    def getConservedMoietyIds(self):
        return _roadrunner.RoadRunner_getConservedMoietyIds(self)
    __swig_setmethods__["__simulateOptions"] = _roadrunner.RoadRunner___simulateOptions_set
    __swig_getmethods__["__simulateOptions"] = _roadrunner.RoadRunner___simulateOptions_get
    if _newclass:
        __simulateOptions = _swig_property(_roadrunner.RoadRunner___simulateOptions_get, _roadrunner.RoadRunner___simulateOptions_set)
    __swig_setmethods__["options"] = _roadrunner.RoadRunner_options_set
    __swig_getmethods__["options"] = _roadrunner.RoadRunner_options_get
    if _newclass:
        options = _swig_property(_roadrunner.RoadRunner_options_get, _roadrunner.RoadRunner_options_set)

    def __repr__(self):
        return _roadrunner.RoadRunner___repr__(self)

    def __str__(self):
        return _roadrunner.RoadRunner___str__(self)

    def _simulate(self, opt):
        return _roadrunner.RoadRunner__simulate(self, opt)

    def _getValue(self, *args):
        """

        RoadRunner.getValue(sel)

        Returns the value for a given selection.

        :param sel: a selection that is either a string or a SelectionRecord that was
                    obtained from createSelection
        :type sel: str or SelectionRecord

        """
        return _roadrunner.RoadRunner__getValue(self, *args)


    def __getitem__(self, id):
        return _roadrunner.RoadRunner___getitem__(self, id)

    def __setitem__(self, id, value):
        return _roadrunner.RoadRunner___setitem__(self, id, value)

    def getIds(self, types):
        """

        RoadRunner.getIds()

        Return a list of selection ids that this object can select on.

        :rtype: list

        """
        return _roadrunner.RoadRunner_getIds(self, types)


    def _getSelections(self):
        return _roadrunner.RoadRunner__getSelections(self)

    def _getSteadyStateSelections(self):
        return _roadrunner.RoadRunner__getSteadyStateSelections(self)

    def getValue(self, *args):
        import re
        reg = re.compile(r'eigen\s*\(\s*(\w*)\s*\)\s*$')
        regarr = re.split(reg, args[0])

        if len(regarr) > 1:
           eig_r = _roadrunner.RoadRunner__getValue(self, 'eigenReal(' + str(regarr[1]) + ')')
           eig_i = _roadrunner.RoadRunner__getValue(self, 'eigenImag(' + str(regarr[1]) + ')')
           return complex(eig_r, eig_i)
        else:
            return _roadrunner.RoadRunner__getValue(self, *args)

    def setValues(self, keys, values):
        for key, val in zip(keys, values):
            _roadrunner.RoadRunner_setValue(self, key, val)

    def getModel(self):
        return self._getModel()

    def _setConservedMoietyAnalysisProxy(self, value):
        self._setConservedMoietyAnalysis(value)
        self._makeProperties()

    __swig_getmethods__["selections"] = _getSelections # DEPRECATED
    __swig_setmethods__["selections"] = _setSelections # DEPRECATED
    __swig_getmethods__["timeCourseSelections"] = _getSelections
    __swig_setmethods__["timeCourseSelections"] = _setSelections
    __swig_getmethods__["steadyStateSelections"] = _getSteadyStateSelections
    __swig_setmethods__["steadyStateSelections"] = _setSteadyStateSelections
    __swig_getmethods__["conservedMoietyAnalysis"] = _getConservedMoietyAnalysis
    __swig_setmethods__["conservedMoietyAnalysis"] = _setConservedMoietyAnalysisProxy
    __swig_getmethods__["model"] = _getModel
    __swig_getmethods__["integrator"] = getIntegrator
    __swig_setmethods__["integrator"] = setIntegrator

    if _newclass:
        selections = property(_getSelections, _setSelections)
        timeCourseSelections = property(_getSelections, _setSelections)
        steadyStateSelections = property(_getSteadyStateSelections, _setSteadyStateSelections)
        conservedMoietyAnalysis=property(_getConservedMoietyAnalysis, _setConservedMoietyAnalysis)
        model = property(getModel)
        integrator = property(getIntegrator)


    # static list of properties added to the RoadRunner
    # class object
    _properties = []

    def _makeProperties(self):

    #global _properties

    # always clear the old properties
        for s in RoadRunner._properties:
            if s in RoadRunner.__swig_getmethods__:
                del RoadRunner.__swig_getmethods__[s]
            if s in RoadRunner.__swig_setmethods__:
                del RoadRunner.__swig_setmethods__[s]
            if hasattr(RoadRunner, s):
                delattr(RoadRunner, s)

    # properties now empty
        RoadRunner._properties = []

    # check if we should make new properties
        if Config.getValue(Config.ROADRUNNER_DISABLE_PYTHON_DYNAMIC_PROPERTIES):
            return

    # can't make properties without a model.
        if self.getModel() is None:
            return

        def mk_fget(sel): return lambda self: self.getModel().__getitem__(sel)
        def mk_fset(sel): return lambda self, val: self.getModel().__setitem__(sel, val)


        def makeProperty(name, sel):
            fget = mk_fget(sel)
            fset = mk_fset(sel)
            RoadRunner.__swig_getmethods__[name] = fget
            RoadRunner.__swig_setmethods__[name] = fset
            setattr(RoadRunner, name, property(fget, fset))
            RoadRunner._properties.append(name)

        model = self.getModel()
        for s in model.getFloatingSpeciesIds():
            makeProperty(s, "[" + s + "]")  # concentrations
            makeProperty(s + "_amt", s)     # amounts


        for s in model.getBoundarySpeciesIds():
            makeProperty(s, "[" + s + "]")  # concentrations
            makeProperty(s + "_amt", s)     # amounts


        for s in model.getGlobalParameterIds() + model.getCompartmentIds() + model.getReactionIds() + model.getConservedMoietyIds():
            makeProperty(s, s)



    # Set up the python dyanic properties for model access,
    # save the original init method
    _swig_init = __init__

    def _new_init(self, *args):
    # if called with https, use Python for transport
        if len(args) >= 1:
            p = args[0]
            if hasattr(p,'startswith') and p.startswith('https://'):
                try:
    # Python3
                    from urllib.request import urlopen
                except ImportError:
    # Python2
                    from urllib2 import urlopen
                sbml = urlopen(p).read()
                try:
                    sbml = str(sbml.decode())
                except:
                    pass
                RoadRunner._swig_init(self, sbml)
                RoadRunner._makeProperties(self)
                return
    # Otherwise, use regular init
        RoadRunner._swig_init(self, *args)
        RoadRunner._makeProperties(self)

    # set the ctor to use the new init
    __init__ = _new_init




    def load(self, *args):
        self._load(*args)
        RoadRunner._makeProperties(self)


    def keys(self, types=_roadrunner.SelectionRecord_ALL):
        return self.getIds(types)

    def values(self, types=_roadrunner.SelectionRecord_ALL):
        return [self.getValue(k) for k in self.keys(types)]

    def items(self, types=_roadrunner.SelectionRecord_ALL):
        return [(k, self.getValue(k)) for k in self.keys(types)]

    def __len__(self):
        return len(self.keys())

    def iteritems(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over (key, value) pairs
        """
        return self.items(types).__iter__()

    def iterkeys(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's keys
        """
        return self.keys(types).__iter__()

    def itervalues(self, types=_roadrunner.SelectionRecord_ALL):
        """
        return an iterator over the mapping's values
        """
        return self.values(types).__iter__()

    def simulate(self, start=None, end=None, points=None, selections=None, steps=None):
        '''
        Simulate the current SBML model.

        simulate accepts a up to four positional arguments. The first four (optional) arguments are treated as:

        1: start (the simulation starting time)

        2: end (the simulation end time)

        3: points (the number of output points)

        4: List of Selections.

        3: steps (the number of output steps, can be only used when number points are not supplied)

        All five of the positional arguments are optional. If any of the positional arguments are
        supplied as a list of strings, then they are interpreted as a list of selections.


        There is only one correct way to call simulate. If one positional argument is specified,
        it is the start time. If two are specified, they are the start and end time.
        The third argument is the number of output points!
        The fourth argument, if it is supplied, must be a list of strings that correspond to
        proper timecourse selections as in timeCourseSelections.
        The fifth argument, if supplied via keyword, is the number of intervals, not the
        number of points. Specifying intervals and points is an error.
        '''

    # fix issue #401 - this will check if a list was positioned at 3rd position. This allows users to
    # omit positional arguement points. This is un-Pythonic, but implemented for the sake of novice users.
        if type(points) == list:
            selections = points
            points = None

    # check for errors
        import collections
        import sys
        import warnings
        if selections is not None:
    # check that selections is a sequence
            if not isinstance(selections, collections.Sequence):
                raise ValueError('Expected a sequence type for selections')

    # check that selections contains only strings
            for x in selections:
                if sys.version_info >= (3,0):
                    if not isinstance(x, str):
                        raise ValueError('Expected selections to be a sequence of strings')
                else:
                    if not isinstance(x, basestring):
                        raise ValueError('Expected selections to be a sequence of strings')

        if points is not None and steps is not None:
            raise ValueError('Cannot specify both points and steps in simulate call')

        if points is not None:
            if points < 2:
                raise ValueError('Number of points cannot be less than 2')

        if steps is not None:
            if steps < 1:
                raise ValueError('Number of steps cannot be less than 1')

    # end error checking

        o = self.__simulateOptions
        originalSteps = o.steps

        if self.getIntegrator().hasValue('variable_step_size'):
            if self.getIntegrator().getValue('variable_step_size') == True:
                o.steps = 0

        if start is not None:
            o.start = start

        if end is not None:
            o.end = end

        if points is not None:
            o.steps = points - 1

        if selections is not None:
            self.timeCourseSelections = selections

        if steps is not None:
            o.steps = steps

        result = self._simulate(o)

        o.steps = originalSteps

        if result.shape[0] > Config.getValue(Config.MAX_OUTPUT_ROWS):
            warnings.warn("Simulation returned more points than max output rows specified. "
                          "Try incresing the number of maximum output rows or minimum step size.")

        return result

    def __simulateOld(self, *args, **kwargs):
        """
        DEPRECATED!!!!!!!!!!!!!!!!
        WILL BE REMOVED

        Simulate the current SBML model.

        simulate accepts a up to four positional arguments. The first four (optional) arguments are treated as:

        1: start (the simulation starting time)

        2: end (the simulation end time)

        3: steps (the number of output points)

        4: List of Selections.

        All four of the positional arguments are optional. If any of the positional arguments are
        supplied as a list of strings, then they are interpreted as a list of selections.


        There is only one correct way to call simulate. If one positional argument is specified,
        it is the start time. If two are specified, they are the start and end time.
        The third argument is the number of output points!
        The fourth argument, if it is supplied, must be a list of strings that correspond to
        proper timecourse selections as in timeCourseSelections.
        The fifth argument, if supplied via keyword, is the number of intervals, not the
        number of points. Specifying intervals and points is an error.

        Do NOT pass a `SimulateOptions` object to this function. SimulateOptions is DEPRECATED.

        Keyword arguments:

        integrator
            DEPRECATED: use setIntegrator method

        sel or selections
            A list of strings specifying what values to display in the output.

        plot
            DEPRECATED: use plot method.

        end
            The simulation end time. Note, setting the end time automatically sets
            the duration accordingly and visa versa.

        resetModel
            DEPRECATED

        reset
            DEPRECATED: use reset method.

        start
            The start time of the simulation time-series data. Often this is 0,
            but not necessarily.

        steps
            The number of steps at which the output is sampled. The samples are evenly spaced.
            When a simulation system calculates the data points to record, it will typically
            divide the duration by the number of time steps. Thus, for N steps, the output
            will have N+1 data rows.

        stiff
            DEPRECATED: use solver API (this setting only available for some solvers).

        seed
            DEPRECATED: use solver API (this setting only available for some solvers).


        :returns: a numpy array with each selected output time series being a
         column vector, and the 0'th column is the simulation time (if time is selected as an
         output).
        :rtype: numpy.ndarray
        """

        doPlot = False
        showPlot = True

    # cleanup tasks
        post_tasks = []

    # user specified number of steps via 3rd arg or steps=xxx
        haveSteps = False

    # variableStep = True was specified in args
        haveVariableStep = False
        o = self.__simulateOptions

        def steps_restore(v):
            def f():
                o.steps = v
            return f
        post_tasks.append(steps_restore(o.steps))

        o.steps = 50
        if self.getIntegrator().hasValue('variable_step_size'):
            if self.getIntegrator().getValue('variable_step_size') == True:
                o.steps = 0
        stepsSpecified = False

    # did the options originally have a seed, if so, don't delete it when we're done
        hadSeed = "seed" in o

    # check if we have just a sim options
        if len(args) >= 1:
            if type(args[0]) == type(self.__simulateOptions):
                o = args[0]
            elif type(args[0]) == list:
    # its a selection list
                self.timeCourseSelections = args[0]
            elif isinstance(args[0], (int, float)):
    # treat it as a number
                o.start = args[0]
            else:
                raise ValueError("argument 1 must be either a number, list or "
                                 "SimulateOptions object, recieved: {0}".format(str(args[0])))

    # second arg is treated as sim end time
        if len(args) >= 2:
            if type(args[1]) == list:
    # its a selection list
                self.timeCourseSelections = args[1]
            elif isinstance(args[1], (int, float)):
    # treat it as a number
                o.end = args[1]
            else:
                raise ValueError("argument 2 must be either a number, list or "
                                 "SimulateOptions object, recieved: {0}".format(str(args[1])))


    # third arg is treated as number of points
        if len(args) >= 3:
            if type(args[2]) == list:
    # its a selection list
                self.timeCourseSelections = args[2]
            elif isinstance(args[2], (int, float)):
    # treat it as a number
                o.steps = args[2]-1
                stepsSpecified = True
                if o.steps < 1:
                  raise RuntimeError('Number of points must be 2 or more')
                haveSteps = True
            else:
                raise ValueError("argument 3 must be either a number, list or "
                                 "SimulateOptions object, recieved: {0}".format(str(args[2])))

    # forth arg may be a list (currently)
        if len(args) >= 4:
            if type(args[3]) == list:
    # its a selection list
                self.timeCourseSelections = args[3]
            else:
                raise ValueError("argument 4 (if given) must be a list of timeCourseSelections "
                                 ", recieved: {0}".format(str(args[3])))


    # go through the list of keyword args
        for k,v in kwargs.items():

    # changing integrators.
            if k == "integrator":
                if type(v) == str:
    # this automatically sets the variable / fixed time step
    # according to integrator type, raises exception if invalid
    # integrator string.
                    self.setIntegrator(v)
                else:
                    raise Exception("{0} is invalid argument for integrator, integrator name must be a string.".format(v))
                continue

    # specifying timeCourseSelections:
            if k == "timeCourseSelections" or k == "sel":
                self.timeCourseSelections = v
                continue

            if k == "steps":
                o.steps = v
                stepsSpecified = True
                continue

            if k == "start":
                o.start = v
                continue

            if k == "end":
                o.end = v
                continue

    # reset model, also accept 'reset'
            if k == "reset" or k == "resetModel":
                o.resetModel = v
                continue

    # check if variableStep was explicitly specified, this overrides the steps
    # positional arg
            if k == "variableStep":
                raise KeyError('Do NOT pass variableStep to simulate. Use integrator API: r.getIntegrator().setValue("variable_step_size", True)')
                haveVariableStep = True
                self.getIntegrator().setValue('variable_step_size', v)
                if not stepsSpecified:
                    o.steps = 0
                continue

            if k == "plot":
                raise RuntimeError('plot argument is deprecated, use plot method')
                continue

            if k == "show":
                showPlot = v
                continue

            if k == "stiff" and self.getIntegrator().hasValue('stiff'):
                raise KeyError('Do NOT pass stiff to simulate. Use the integrator API: r.getIntegrator().setValue("stiff", True)')
                def stiff_restore(v):
                    def f():
                        self.getIntegrator().setValue('stiff', v)
                    return f
                self.getIntegrator().setValue('stiff', kwargs[k])
                post_tasks.append(stiff_restore(self.getIntegrator().getValue('stiff')))
                continue

    # if its not one of these, just set the item on the dict, and
    # if the inegrator cares about it, it will use it.
    # if its one of these, set it.
            raise KeyError('No such argument: {}'.format(k))



    # if we are doing a stochastic sim,
    # explicit options of variableStep trumps everything,
    # if not explicit, variableStep is if number of steps was specified,
    # if no steps, varStep = true, false otherwise.
        if self.getIntegrator().getIntegrationMethod() == \
            Integrator.Stochastic and not haveVariableStep:
            self.getIntegrator().setValue('variable_step_size', not haveSteps)

    # the options are set up, now actually run the simuation...
        result = self._simulate(o)

        if not hadSeed:
            del o["seed"]

        if doPlot:
            self.plot(result=None, loc='upper left', show=showPlot)

    # revert any settings we changed
        for x in post_tasks:
            x()

        return result

    # ---------------------------------------------------------------------
    # Reset Methods
    # ---------------------------------------------------------------------
    def resetToOrigin(self):
        """ Reset model to state when first loaded.

        This resets the model back to the state when it was FIRST loaded,
        this includes all init() and parameters such as k1 etc.

        identical to:
            r.reset(SelectionRecord.ALL)
        """
        self.reset(SelectionRecord.ALL)

    def resetAll(self):
        """ Reset all model variables to CURRENT init(X) values.

        This resets all variables, S1, S2 etc to the CURRENT init(X) values. It also resets all
        parameters back to the values they had when the model was first loaded.
        """
        self.reset(SelectionRecord.TIME |
                   SelectionRecord.RATE |
                   SelectionRecord.FLOATING |
                   SelectionRecord.GLOBAL_PARAMETER)

    def resetParameter(self):
        """ Reset parameters to CURRENT init(X) values.

        This resets all parameters to the CURRENT init(X) values.
        """
        self.reset(SelectionRecord.GLOBAL_PARAMETER)

    def getAvailableIntegrators(self):
        """
        get a list of available integrator names.
        """
        return self.getExistingIntegratorNames()


    def plot(self, result=None, loc='upper left', show=True):
        """
        RoadRunner.plot([show])

        Plot the previously run simulation result using Matplotlib.

        This takes the contents of the simulation result and builds a
        legend from the selection list.


        If the optional prameter 'show' [default is True] is given, the pylab
        show() method is called.
        """

        try:
            import matplotlib.pyplot as p
        except ImportError:
            raise ImportError('Could not import matplotlib - please install matplotlib to enable plotting functionality')

        result = self.getSimulationData()

        if result is None:
            raise Exception("no simulation result")

        rval = []

    # check if standard numpy array
        if result.dtype.names is None:

            timeCourseSelections = self.timeCourseSelections

            if len(result.shape) != 2 or result.shape[1] != len(timeCourseSelections):
                raise Exception("simulation result columns not equal to number of selections, likely a simulation has not been run")

            times = result[:,0]

            for i in range(1, len(timeCourseSelections)):
                series = result[:,i]
                name = timeCourseSelections[i]
                rval.append(p.plot(times, series, label=str(name), linewidth=2))

    # result is structured array
        else:
            if len(result.dtype.names) < 1:
                raise Exception('no columns to plot')

            time = result.dtype.names[0]

            for name in result.dtype.names[1:]:
                rval.append(p.plot(result[time], result[name], label=name, linewidth=2))

        if show:
            p.show()

        return rval

    def plotLegend(self):
        try:
            import matplotlib.pyplot as p
        except ImportError:
            raise ImportError('Could not import matplotlib - please install matplotlib to enable plotting functionality')
        p.legend()

    def showPlot(self):
        try:
            import matplotlib.pyplot as p
        except ImportError:
            raise ImportError('Could not import matplotlib - please install matplotlib to enable plotting functionality')
        p.show()

    def getIndependentFloatingSpeciesIds(self):
        return list(self._getIndependentFloatingSpeciesIds())

    def getDependentFloatingSpeciesIds(self):
        return list(self._getDependentFloatingSpeciesIds())

    def getReactionRates(self):
        return self.getModel().getReactionRates()

    if _newclass:
        integrator = property(getIntegrator, setIntegrator)

    def setIntegratorSetting(self, integratorName, settingName, value):
        import sys
        if sys.version_info >= (3,0):
            if not isinstance(integratorName, str):
                raise ValueError('Expected integratorName to be a string')
            if not isinstance(settingName, str):
                raise ValueError('Expected settingName to be a string')
        else:
            if not isinstance(integratorName, basestring):
                raise ValueError('Expected integratorName to be a string')
            if not isinstance(settingName, basestring):
                raise ValueError('Expected settingName to be a string')

    # store original integrator and switch back to it afterwards
        origIntegrator = self.getIntegrator().getName()

        self.setIntegrator(integratorName)
        self.getIntegrator().setValue(settingName, value)
        self.setIntegrator(origIntegrator)

    @property
    def steadyStateSolver(self):
        '''The current steady state solver'''
        return self.getSteadyStateSolver()

    @steadyStateSolver.setter
    def steadyStateSolver(self, v):
        self.setSteadyStateSolver(v)

    def _diffstep_getter(self):
        '''Differential step size used in MCA'''
        return self.getDiffStepSize()

    def _diffstep_stter(self, v):
        print('diffstep.setter')
        self.setDiffStepSize(v)

    __swig_getmethods__['diffstep'] = _diffstep_getter
    __swig_setmethods__['diffstep'] = _diffstep_stter

    if _newclass:
        diffstep = property(_diffstep_getter, _diffstep_stter)

    def _steadyStateThresh_getter(self):
        '''Steady state threshold used in MCA'''
        return self.getSteadyStateThreshold()

    def _steadyStateThresh_setter(self, v):
        self.setSteadyStateThreshold(v)

    __swig_getmethods__['steadyStateThresh'] = _steadyStateThresh_getter
    __swig_setmethods__['steadyStateThresh'] = _steadyStateThresh_setter

    if _newclass:
        steadyStateThresh = property(_steadyStateThresh_getter, _steadyStateThresh_setter)

RoadRunner_swigregister = _roadrunner.RoadRunner_swigregister
RoadRunner_swigregister(RoadRunner)

def RoadRunner_getParamPromotedSBML(sArg):
    """

    RoadRunner.getParamPromotedSBML(*args)

    Takes an SBML document or path to an SBML document and changes all of the local parameters
    to be global parameters.

    :param str SBML: the contents or path to an SBML document
    :rtype: str

    """
    return _roadrunner.RoadRunner_getParamPromotedSBML(sArg)

def RoadRunner_getRegisteredIntegratorNames():
    return _roadrunner.RoadRunner_getRegisteredIntegratorNames()
RoadRunner_getRegisteredIntegratorNames = _roadrunner.RoadRunner_getRegisteredIntegratorNames

def RoadRunner_getRegisteredSteadyStateSolverNames():
    return _roadrunner.RoadRunner_getRegisteredSteadyStateSolverNames()
RoadRunner_getRegisteredSteadyStateSolverNames = _roadrunner.RoadRunner_getRegisteredSteadyStateSolverNames

def RoadRunner_ensureSolversRegistered():
    return _roadrunner.RoadRunner_ensureSolversRegistered()
RoadRunner_ensureSolversRegistered = _roadrunner.RoadRunner_ensureSolversRegistered

def RoadRunner_getExtendedVersionInfo():
    """

    RoadRunner.getExtendedVersionInfo()

    getVersion plus info about dependent libs versions.

    """
    return _roadrunner.RoadRunner_getExtendedVersionInfo()

class SelectionRecord(_object):
    """

    SelectionRecord.__init__(str)
    Create a new selection record. This constructor really should not be called,
    SelectionRecords should be created by the RoadRunner.createSelection

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectionRecord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SelectionRecord, name)
    TIME = _roadrunner.SelectionRecord_TIME
    CONCENTRATION = _roadrunner.SelectionRecord_CONCENTRATION
    AMOUNT = _roadrunner.SelectionRecord_AMOUNT
    RATE = _roadrunner.SelectionRecord_RATE
    BOUNDARY = _roadrunner.SelectionRecord_BOUNDARY
    FLOATING = _roadrunner.SelectionRecord_FLOATING
    _COMPARTMENT = _roadrunner.SelectionRecord__COMPARTMENT
    _GLOBAL_PARAMETER = _roadrunner.SelectionRecord__GLOBAL_PARAMETER
    REACTION = _roadrunner.SelectionRecord_REACTION
    INITIAL = _roadrunner.SelectionRecord_INITIAL
    CURRENT = _roadrunner.SelectionRecord_CURRENT
    UNSCALED = _roadrunner.SelectionRecord_UNSCALED
    ELASTICITY = _roadrunner.SelectionRecord_ELASTICITY
    CONTROL = _roadrunner.SelectionRecord_CONTROL
    EIGENVALUE_REAL = _roadrunner.SelectionRecord_EIGENVALUE_REAL
    ELEMENT = _roadrunner.SelectionRecord_ELEMENT
    STOICHIOMETRY = _roadrunner.SelectionRecord_STOICHIOMETRY
    UNKNOWN = _roadrunner.SelectionRecord_UNKNOWN
    DEPENDENT = _roadrunner.SelectionRecord_DEPENDENT
    INDEPENDENT = _roadrunner.SelectionRecord_INDEPENDENT
    CONSERVED_MOIETY = _roadrunner.SelectionRecord_CONSERVED_MOIETY
    STATE_VECTOR = _roadrunner.SelectionRecord_STATE_VECTOR
    EVENT = _roadrunner.SelectionRecord_EVENT
    EIGENVALUE_IMAG = _roadrunner.SelectionRecord_EIGENVALUE_IMAG
    EIGENVALUE_COMPLEX = _roadrunner.SelectionRecord_EIGENVALUE_COMPLEX
    UNKNOWN_CONCENTRATION = _roadrunner.SelectionRecord_UNKNOWN_CONCENTRATION
    COMPARTMENT = _roadrunner.SelectionRecord_COMPARTMENT
    GLOBAL_PARAMETER = _roadrunner.SelectionRecord_GLOBAL_PARAMETER
    FLOATING_AMOUNT = _roadrunner.SelectionRecord_FLOATING_AMOUNT
    INDEPENDENT_FLOATING_AMOUNT = _roadrunner.SelectionRecord_INDEPENDENT_FLOATING_AMOUNT
    DEPENDENT_FLOATING_AMOUNT = _roadrunner.SelectionRecord_DEPENDENT_FLOATING_AMOUNT
    BOUNDARY_AMOUNT = _roadrunner.SelectionRecord_BOUNDARY_AMOUNT
    BOUNDARY_CONCENTRATION = _roadrunner.SelectionRecord_BOUNDARY_CONCENTRATION
    FLOATING_CONCENTRATION = _roadrunner.SelectionRecord_FLOATING_CONCENTRATION
    FLOATING_AMOUNT_RATE = _roadrunner.SelectionRecord_FLOATING_AMOUNT_RATE
    FLOATING_CONCENTRATION_RATE = _roadrunner.SelectionRecord_FLOATING_CONCENTRATION_RATE
    GLOBAL_PARAMETER_RATE = _roadrunner.SelectionRecord_GLOBAL_PARAMETER_RATE
    REACTION_RATE = _roadrunner.SelectionRecord_REACTION_RATE
    INITIAL_AMOUNT = _roadrunner.SelectionRecord_INITIAL_AMOUNT
    INITIAL_FLOATING_AMOUNT = _roadrunner.SelectionRecord_INITIAL_FLOATING_AMOUNT
    INITIAL_CONCENTRATION = _roadrunner.SelectionRecord_INITIAL_CONCENTRATION
    INITIAL_FLOATING_CONCENTRATION = _roadrunner.SelectionRecord_INITIAL_FLOATING_CONCENTRATION
    INITIAL_COMPARTMENT = _roadrunner.SelectionRecord_INITIAL_COMPARTMENT
    INITIAL_GLOBAL_PARAMETER = _roadrunner.SelectionRecord_INITIAL_GLOBAL_PARAMETER
    DEPENDENT_INITIAL_GLOBAL_PARAMETER = _roadrunner.SelectionRecord_DEPENDENT_INITIAL_GLOBAL_PARAMETER
    UNSCALED_ELASTICITY = _roadrunner.SelectionRecord_UNSCALED_ELASTICITY
    UNSCALED_CONTROL = _roadrunner.SelectionRecord_UNSCALED_CONTROL
    UNKNOWN_ELEMENT = _roadrunner.SelectionRecord_UNKNOWN_ELEMENT
    ALL = _roadrunner.SelectionRecord_ALL
    ALL_INDEPENDENT = _roadrunner.SelectionRecord_ALL_INDEPENDENT
    ALL_DEPENDENT = _roadrunner.SelectionRecord_ALL_DEPENDENT
    ALL_INDEPENDENT_AMOUNT = _roadrunner.SelectionRecord_ALL_INDEPENDENT_AMOUNT
    ALL_DEPENDENT_AMOUNT = _roadrunner.SelectionRecord_ALL_DEPENDENT_AMOUNT
    ALL_INDEPENDENT_CONCENTRATION = _roadrunner.SelectionRecord_ALL_INDEPENDENT_CONCENTRATION
    ALL_DEPENDENT_CONCENTRATION = _roadrunner.SelectionRecord_ALL_DEPENDENT_CONCENTRATION
    MODEL_STATE = _roadrunner.SelectionRecord_MODEL_STATE
    SBML_INITIALIZE = _roadrunner.SelectionRecord_SBML_INITIALIZE
    __swig_setmethods__["index"] = _roadrunner.SelectionRecord_index_set
    __swig_getmethods__["index"] = _roadrunner.SelectionRecord_index_get
    if _newclass:
        index = _swig_property(_roadrunner.SelectionRecord_index_get, _roadrunner.SelectionRecord_index_set)
    __swig_setmethods__["p1"] = _roadrunner.SelectionRecord_p1_set
    __swig_getmethods__["p1"] = _roadrunner.SelectionRecord_p1_get
    if _newclass:
        p1 = _swig_property(_roadrunner.SelectionRecord_p1_get, _roadrunner.SelectionRecord_p1_set)
    __swig_setmethods__["p2"] = _roadrunner.SelectionRecord_p2_set
    __swig_getmethods__["p2"] = _roadrunner.SelectionRecord_p2_get
    if _newclass:
        p2 = _swig_property(_roadrunner.SelectionRecord_p2_get, _roadrunner.SelectionRecord_p2_set)
    __swig_setmethods__["selectionType"] = _roadrunner.SelectionRecord_selectionType_set
    __swig_getmethods__["selectionType"] = _roadrunner.SelectionRecord_selectionType_get
    if _newclass:
        selectionType = _swig_property(_roadrunner.SelectionRecord_selectionType_get, _roadrunner.SelectionRecord_selectionType_set)

    def __init__(self, *args):
        this = _roadrunner.new_SelectionRecord(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def to_string(self):
        return _roadrunner.SelectionRecord_to_string(self)

    def to_repr(self):
        return _roadrunner.SelectionRecord_to_repr(self)

    def __repr__(self):
        return _roadrunner.SelectionRecord___repr__(self)

    def __str__(self):
        return _roadrunner.SelectionRecord___str__(self)
    __swig_destroy__ = _roadrunner.delete_SelectionRecord
    __del__ = lambda self: None
SelectionRecord_swigregister = _roadrunner.SelectionRecord_swigregister
SelectionRecord_swigregister(SelectionRecord)


def __lshift__(*args):
    return _roadrunner.__lshift__(*args)
__lshift__ = _roadrunner.__lshift__
class PyConservedMoietyConverter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyConservedMoietyConverter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyConservedMoietyConverter, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _roadrunner.new_PyConservedMoietyConverter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_PyConservedMoietyConverter
    __del__ = lambda self: None

    def setDocument(self, fileOrPath):
        """

        PyConservedMoietyConverter.setDocument(sbmlOrURI)

        Sets the source document. This may be either the contents of an sbml docment
        as a string, or the path the the file.

        :param str sbmlOrURI: contents or path of source document
        :returns: an integer indicating success or failure, 0 means success.
        :rtype: int

        """
        return _roadrunner.PyConservedMoietyConverter_setDocument(self, fileOrPath)


    def convert(self):
        """

        PyConservedMoietyConverter.convert()

        Perform the document conversion.

        :returns: an integer indicating success or failure, 0 means success.
        :rtype: int

        """
        return _roadrunner.PyConservedMoietyConverter_convert(self)


    def getDocument(self):
        """

        PyConservedMoietyConverter.getDocument()

        Get the converted document contents.

        :returns: The contents of the converted document, or empty string
                  if there is no source document.

        """
        return _roadrunner.PyConservedMoietyConverter_getDocument(self)

PyConservedMoietyConverter_swigregister = _roadrunner.PyConservedMoietyConverter_swigregister
PyConservedMoietyConverter_swigregister(PyConservedMoietyConverter)

class Solver(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Solver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Solver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_Solver
    __del__ = lambda self: None

    def getName(self):
        return _roadrunner.Solver_getName(self)

    def getSettings(self):
        return _roadrunner.Solver_getSettings(self)

    def resetSettings(self):
        return _roadrunner.Solver_resetSettings(self)

    def getValue(self, key):
        return _roadrunner.Solver_getValue(self, key)

    def hasValue(self, key):
        return _roadrunner.Solver_hasValue(self, key)

    def getNumParams(self):
        return _roadrunner.Solver_getNumParams(self)

    def getParamName(self, n):
        return _roadrunner.Solver_getParamName(self, n)

    def getParamDisplayName(self, n):
        return _roadrunner.Solver_getParamDisplayName(self, n)

    def getParamHint(self, n):
        return _roadrunner.Solver_getParamHint(self, n)

    def getParamDesc(self, n):
        return _roadrunner.Solver_getParamDesc(self, n)

    def getValueAsInt(self, key):
        return _roadrunner.Solver_getValueAsInt(self, key)

    def getValueAsUInt(self, key):
        return _roadrunner.Solver_getValueAsUInt(self, key)

    def getValueAsLong(self, key):
        return _roadrunner.Solver_getValueAsLong(self, key)

    def getValueAsULong(self, key):
        return _roadrunner.Solver_getValueAsULong(self, key)

    def getValueAsFloat(self, key):
        return _roadrunner.Solver_getValueAsFloat(self, key)

    def getValueAsDouble(self, key):
        return _roadrunner.Solver_getValueAsDouble(self, key)

    def getValueAsChar(self, key):
        return _roadrunner.Solver_getValueAsChar(self, key)

    def getValueAsUChar(self, key):
        return _roadrunner.Solver_getValueAsUChar(self, key)

    def getValueAsString(self, key):
        return _roadrunner.Solver_getValueAsString(self, key)

    def getValueAsBool(self, key):
        return _roadrunner.Solver_getValueAsBool(self, key)

    def setValue(self, key, value):
        return _roadrunner.Solver_setValue(self, key, value)

    def getDisplayName(self, key):
        return _roadrunner.Solver_getDisplayName(self, key)

    def getHint(self, *args):
        return _roadrunner.Solver_getHint(self, *args)

    def getDescription(self, *args):
        return _roadrunner.Solver_getDescription(self, *args)

    def getType(self, key):
        return _roadrunner.Solver_getType(self, key)

    def getSettingsRepr(self):
        return _roadrunner.Solver_getSettingsRepr(self)

    def settingsPyDictRepr(self):
        return _roadrunner.Solver_settingsPyDictRepr(self)

    def toString(self):
        return _roadrunner.Solver_toString(self)

    def toRepr(self):
        return _roadrunner.Solver_toRepr(self)

    def __dir__(self):
        x = dir(type(self))
        x += self.getSettings()
        return x

    def __getattr__(self, name):
        if(name in self.getSettings()):
            return Solver.getValue(self, name)
        else:
            return _swig_getattr(self, Integrator, name)

    def __setattr__(self, name, value):
        if(name != 'this' and name in self.getSettings()):
            self.setValue(name, value)
        else:
            _swig_setattr(self, Integrator, name, value)

    def getSetting(self, k):
        return self.getValue(k)

    def setSetting(self, k, v):
        return self.setValue(k, v)

    def setValues(self, keys, values):
        for key, val in zip(keys, values):
            _roadrunner.Solver_setValue(self, key, val)

Solver_swigregister = _roadrunner.Solver_swigregister
Solver_swigregister(Solver)

class Integrator(Solver):
    __swig_setmethods__ = {}
    for _s in [Solver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Integrator, name, value)
    __swig_getmethods__ = {}
    for _s in [Solver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Integrator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Deterministic = _roadrunner.Integrator_Deterministic
    Stochastic = _roadrunner.Integrator_Stochastic
    Hybrid = _roadrunner.Integrator_Hybrid
    Other = _roadrunner.Integrator_Other
    __swig_destroy__ = _roadrunner.delete_Integrator
    __del__ = lambda self: None

    def getIntegrationMethod(self):
        return _roadrunner.Integrator_getIntegrationMethod(self)

    def syncWithModel(self, m):
        return _roadrunner.Integrator_syncWithModel(self, m)

    def loadConfigSettings(self):
        return _roadrunner.Integrator_loadConfigSettings(self)

    def loadSBMLSettings(self, filename):
        return _roadrunner.Integrator_loadSBMLSettings(self, filename)

    def integrate(self, t0, hstep):
        return _roadrunner.Integrator_integrate(self, t0, hstep)

    def restart(self, t0):
        return _roadrunner.Integrator_restart(self, t0)

    def tweakTolerances(self):
        return _roadrunner.Integrator_tweakTolerances(self)

    def setListener(self, arg2):
        return _roadrunner.Integrator_setListener(self, arg2)

    def __str__(self):
        return _roadrunner.Integrator___str__(self)

    def toRepr(self):
        return _roadrunner.Integrator_toRepr(self)

    def _setListener(self, listener):
        return _roadrunner.Integrator__setListener(self, listener)

    def _getListener(self):
        return _roadrunner.Integrator__getListener(self)

    def _clearListener(self):
        return _roadrunner.Integrator__clearListener(self)

    def getListener(self):
        return self._getListener()

    def setListener(self, listener):
        if listener is None:
            self._clearListener()
        else:
            self._setListener(listener)

    __swig_getmethods__["listener"] = getListener
    __swig_setmethods__["listener"] = setListener
    if _newclass:
        listener = property(getListener, setListener)

    def __dir__(self):
        x = dir(type(self))
        x += self.getSettings()
        return x

    def __getattr__(self, name):
        if(name in self.getSettings()):
            return Solver.getValue(self, name)
        else:
            return _swig_getattr(self, Integrator, name)

    def __setattr__(self, name, value):
        if(name != 'this' and name in self.getSettings()):
            self.setValue(name, value)
        else:
            _swig_setattr(self, Integrator, name, value)

    def __repr__(self):
        return self.toRepr()

    def getSetting(self, k):
        return self.getValue(k)

    def setSetting(self, k, v):
        return self.setValue(k, v)

Integrator_swigregister = _roadrunner.Integrator_swigregister
Integrator_swigregister(Integrator)

class IntegratorException(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegratorException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntegratorException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _roadrunner.new_IntegratorException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_IntegratorException
    __del__ = lambda self: None
IntegratorException_swigregister = _roadrunner.IntegratorException_swigregister
IntegratorException_swigregister(IntegratorException)

class SteadyStateSolver(Solver):
    __swig_setmethods__ = {}
    for _s in [Solver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SteadyStateSolver, name, value)
    __swig_getmethods__ = {}
    for _s in [Solver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SteadyStateSolver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SteadyStateSolver
    __del__ = lambda self: None

    def syncWithModel(self, m):
        return _roadrunner.SteadyStateSolver_syncWithModel(self, m)

    def solve(self):
        return _roadrunner.SteadyStateSolver_solve(self)

    def loadConfigSettings(self):
        return _roadrunner.SteadyStateSolver_loadConfigSettings(self)

    def getSettingsRepr(self):
        return _roadrunner.SteadyStateSolver_getSettingsRepr(self)

    def settingsPyDictRepr(self):
        return _roadrunner.SteadyStateSolver_settingsPyDictRepr(self)

    def __str__(self):
        return _roadrunner.SteadyStateSolver___str__(self)

    def toRepr(self):
        return _roadrunner.SteadyStateSolver_toRepr(self)

    def __dir__(self):
        x = dir(type(self))
        x += self.getSettings()
        return x

    def __getattr__(self, name):
        if(name in self.getSettings()):
            return Solver.getValue(self, name)
        else:
            return _swig_getattr(self, Integrator, name)

    def __setattr__(self, name, value):
        if(name != 'this' and name in self.getSettings()):
            self.setValue(name, value)
        else:
            _swig_setattr(self, Integrator, name, value)

    def __repr__(self):
        return self.toRepr()

    def getSetting(self, k):
        return self.getValue(k)

    def setSetting(self, k, v):
        return self.setValue(k, v)

SteadyStateSolver_swigregister = _roadrunner.SteadyStateSolver_swigregister
SteadyStateSolver_swigregister(SteadyStateSolver)

class SteadyStateSolverRegistrar(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SteadyStateSolverRegistrar, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SteadyStateSolverRegistrar, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SteadyStateSolverRegistrar
    __del__ = lambda self: None

    def getName(self):
        return _roadrunner.SteadyStateSolverRegistrar_getName(self)

    def getDescription(self):
        return _roadrunner.SteadyStateSolverRegistrar_getDescription(self)

    def getHint(self):
        return _roadrunner.SteadyStateSolverRegistrar_getHint(self)

    def construct(self, model):
        return _roadrunner.SteadyStateSolverRegistrar_construct(self, model)
SteadyStateSolverRegistrar_swigregister = _roadrunner.SteadyStateSolverRegistrar_swigregister
SteadyStateSolverRegistrar_swigregister(SteadyStateSolverRegistrar)

class SteadyStateSolverFactory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SteadyStateSolverFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SteadyStateSolverFactory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _roadrunner.delete_SteadyStateSolverFactory
    __del__ = lambda self: None

    def New(self, name, m):
        return _roadrunner.SteadyStateSolverFactory_New(self, name, m)

    def registerSteadyStateSolver(self, i):
        return _roadrunner.SteadyStateSolverFactory_registerSteadyStateSolver(self, i)
    if _newclass:
        getInstance = staticmethod(_roadrunner.SteadyStateSolverFactory_getInstance)
    else:
        getInstance = _roadrunner.SteadyStateSolverFactory_getInstance

    def getNumSteadyStateSolvers(self):
        return _roadrunner.SteadyStateSolverFactory_getNumSteadyStateSolvers(self)

    def getListSteadyStateSolverNames(self):
        return _roadrunner.SteadyStateSolverFactory_getListSteadyStateSolverNames(self)

    def getSteadyStateSolverName(self, n):
        return _roadrunner.SteadyStateSolverFactory_getSteadyStateSolverName(self, n)

    def getSteadyStateSolverHint(self, n):
        return _roadrunner.SteadyStateSolverFactory_getSteadyStateSolverHint(self, n)

    def getSteadyStateSolverDescription(self, n):
        return _roadrunner.SteadyStateSolverFactory_getSteadyStateSolverDescription(self, n)
SteadyStateSolverFactory_swigregister = _roadrunner.SteadyStateSolverFactory_swigregister
SteadyStateSolverFactory_swigregister(SteadyStateSolverFactory)

def SteadyStateSolverFactory_getInstance():
    return _roadrunner.SteadyStateSolverFactory_getInstance()
SteadyStateSolverFactory_getInstance = _roadrunner.SteadyStateSolverFactory_getInstance

class PyEventListener(EventListener):
    __swig_setmethods__ = {}
    for _s in [EventListener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyEventListener, name, value)
    __swig_getmethods__ = {}
    for _s in [EventListener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyEventListener, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _roadrunner.new_PyEventListener()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_PyEventListener
    __del__ = lambda self: None

    def setOnTrigger(self, py):
        return _roadrunner.PyEventListener_setOnTrigger(self, py)

    def getOnTrigger(self):
        return _roadrunner.PyEventListener_getOnTrigger(self)

    def setOnAssignment(self, py):
        return _roadrunner.PyEventListener_setOnAssignment(self, py)

    def getOnAssignment(self):
        return _roadrunner.PyEventListener_getOnAssignment(self)

    def fireOnTrigger(self, model, index, eventId):
        return _roadrunner.PyEventListener_fireOnTrigger(self, model, index, eventId)

    def fireOnAssignment(self, model, index, eventId):
        return _roadrunner.PyEventListener_fireOnAssignment(self, model, index, eventId)

    __swig_getmethods__["onTrigger"] = getOnTrigger
    __swig_setmethods__["onTrigger"] = setOnTrigger
    if _newclass: onTrigger = property(getOnTrigger, setOnTrigger)

    __swig_getmethods__["onAssignment"] = getOnAssignment
    __swig_setmethods__["onAssignment"] = setOnAssignment
    if _newclass: onAssignment = property(getOnAssignment, setOnAssignment)

PyEventListener_swigregister = _roadrunner.PyEventListener_swigregister
PyEventListener_swigregister(PyEventListener)

class PyIntegratorListener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyIntegratorListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyIntegratorListener, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _roadrunner.new_PyIntegratorListener()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_PyIntegratorListener
    __del__ = lambda self: None

    def setOnTimeStep(self, py):
        return _roadrunner.PyIntegratorListener_setOnTimeStep(self, py)

    def getOnTimeStep(self):
        return _roadrunner.PyIntegratorListener_getOnTimeStep(self)

    def setOnEvent(self, py):
        return _roadrunner.PyIntegratorListener_setOnEvent(self, py)

    def getOnEvent(self):
        return _roadrunner.PyIntegratorListener_getOnEvent(self)

    __swig_getmethods__["onTimeStep"] = getOnTimeStep
    __swig_setmethods__["onTimeStep"] = setOnTimeStep
    if _newclass: onTimeStep = property(getOnTimeStep, setOnTimeStep)

    __swig_getmethods__["onEvent"] = getOnEvent
    __swig_setmethods__["onEvent"] = setOnEvent
    if _newclass: onEvent = property(getOnEvent, setOnEvent)

PyIntegratorListener_swigregister = _roadrunner.PyIntegratorListener_swigregister
PyIntegratorListener_swigregister(PyIntegratorListener)

class Config(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Config, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Config, name)
    __repr__ = _swig_repr
    LOADSBMLOPTIONS_CONSERVED_MOIETIES = _roadrunner.Config_LOADSBMLOPTIONS_CONSERVED_MOIETIES
    LOADSBMLOPTIONS_RECOMPILE = _roadrunner.Config_LOADSBMLOPTIONS_RECOMPILE
    LOADSBMLOPTIONS_READ_ONLY = _roadrunner.Config_LOADSBMLOPTIONS_READ_ONLY
    LOADSBMLOPTIONS_MUTABLE_INITIAL_CONDITIONS = _roadrunner.Config_LOADSBMLOPTIONS_MUTABLE_INITIAL_CONDITIONS
    LOADSBMLOPTIONS_OPTIMIZE_GVN = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_GVN
    LOADSBMLOPTIONS_OPTIMIZE_CFG_SIMPLIFICATION = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_CFG_SIMPLIFICATION
    LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_COMBINING = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_COMBINING
    LOADSBMLOPTIONS_OPTIMIZE_DEAD_INST_ELIMINATION = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_DEAD_INST_ELIMINATION
    LOADSBMLOPTIONS_OPTIMIZE_DEAD_CODE_ELIMINATION = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_DEAD_CODE_ELIMINATION
    LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER = _roadrunner.Config_LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER
    LOADSBMLOPTIONS_USE_MCJIT = _roadrunner.Config_LOADSBMLOPTIONS_USE_MCJIT
    SIMULATEOPTIONS_STEPS = _roadrunner.Config_SIMULATEOPTIONS_STEPS
    SIMULATEOPTIONS_DURATION = _roadrunner.Config_SIMULATEOPTIONS_DURATION
    SIMULATEOPTIONS_ABSOLUTE = _roadrunner.Config_SIMULATEOPTIONS_ABSOLUTE
    SIMULATEOPTIONS_RELATIVE = _roadrunner.Config_SIMULATEOPTIONS_RELATIVE
    SIMULATEOPTIONS_STRUCTURED_RESULT = _roadrunner.Config_SIMULATEOPTIONS_STRUCTURED_RESULT
    SIMULATEOPTIONS_STIFF = _roadrunner.Config_SIMULATEOPTIONS_STIFF
    SIMULATEOPTIONS_MULTI_STEP = _roadrunner.Config_SIMULATEOPTIONS_MULTI_STEP
    SIMULATEOPTIONS_DETERMINISTIC_VARIABLE_STEP = _roadrunner.Config_SIMULATEOPTIONS_DETERMINISTIC_VARIABLE_STEP
    SIMULATEOPTIONS_STOCHASTIC_VARIABLE_STEP = _roadrunner.Config_SIMULATEOPTIONS_STOCHASTIC_VARIABLE_STEP
    SIMULATEOPTIONS_INTEGRATOR = _roadrunner.Config_SIMULATEOPTIONS_INTEGRATOR
    SIMULATEOPTIONS_INITIAL_TIMESTEP = _roadrunner.Config_SIMULATEOPTIONS_INITIAL_TIMESTEP
    SIMULATEOPTIONS_MINIMUM_TIMESTEP = _roadrunner.Config_SIMULATEOPTIONS_MINIMUM_TIMESTEP
    SIMULATEOPTIONS_MAXIMUM_TIMESTEP = _roadrunner.Config_SIMULATEOPTIONS_MAXIMUM_TIMESTEP
    SIMULATEOPTIONS_MAXIMUM_NUM_STEPS = _roadrunner.Config_SIMULATEOPTIONS_MAXIMUM_NUM_STEPS
    ROADRUNNER_DISABLE_WARNINGS = _roadrunner.Config_ROADRUNNER_DISABLE_WARNINGS
    ROADRUNNER_DISABLE_PYTHON_DYNAMIC_PROPERTIES = _roadrunner.Config_ROADRUNNER_DISABLE_PYTHON_DYNAMIC_PROPERTIES
    SBML_APPLICABLEVALIDATORS = _roadrunner.Config_SBML_APPLICABLEVALIDATORS
    ROADRUNNER_JACOBIAN_STEP_SIZE = _roadrunner.Config_ROADRUNNER_JACOBIAN_STEP_SIZE
    MODEL_RESET = _roadrunner.Config_MODEL_RESET
    CVODE_MIN_ABSOLUTE = _roadrunner.Config_CVODE_MIN_ABSOLUTE
    CVODE_MIN_RELATIVE = _roadrunner.Config_CVODE_MIN_RELATIVE
    SIMULATEOPTIONS_COPY_RESULT = _roadrunner.Config_SIMULATEOPTIONS_COPY_RESULT
    STEADYSTATE_PRESIMULATION = _roadrunner.Config_STEADYSTATE_PRESIMULATION
    STEADYSTATE_PRESIMULATION_MAX_STEPS = _roadrunner.Config_STEADYSTATE_PRESIMULATION_MAX_STEPS
    STEADYSTATE_PRESIMULATION_TIME = _roadrunner.Config_STEADYSTATE_PRESIMULATION_TIME
    STEADYSTATE_APPROX = _roadrunner.Config_STEADYSTATE_APPROX
    STEADYSTATE_APPROX_TOL = _roadrunner.Config_STEADYSTATE_APPROX_TOL
    STEADYSTATE_APPROX_MAX_STEPS = _roadrunner.Config_STEADYSTATE_APPROX_MAX_STEPS
    STEADYSTATE_APPROX_TIME = _roadrunner.Config_STEADYSTATE_APPROX_TIME
    STEADYSTATE_RELATIVE = _roadrunner.Config_STEADYSTATE_RELATIVE
    STEADYSTATE_MAXIMUM_NUM_STEPS = _roadrunner.Config_STEADYSTATE_MAXIMUM_NUM_STEPS
    STEADYSTATE_MINIMUM_DAMPING = _roadrunner.Config_STEADYSTATE_MINIMUM_DAMPING
    STEADYSTATE_BROYDEN = _roadrunner.Config_STEADYSTATE_BROYDEN
    STEADYSTATE_LINEARITY = _roadrunner.Config_STEADYSTATE_LINEARITY
    ROADRUNNER_JACOBIAN_MODE = _roadrunner.Config_ROADRUNNER_JACOBIAN_MODE
    TEMP_DIR_PATH = _roadrunner.Config_TEMP_DIR_PATH
    LOGGER_LOG_FILE_PATH = _roadrunner.Config_LOGGER_LOG_FILE_PATH
    RANDOM_SEED = _roadrunner.Config_RANDOM_SEED
    PYTHON_ENABLE_NAMED_MATRIX = _roadrunner.Config_PYTHON_ENABLE_NAMED_MATRIX
    LLVM_SYMBOL_CACHE = _roadrunner.Config_LLVM_SYMBOL_CACHE
    OPTIMIZE_REACTION_RATE_SELECTION = _roadrunner.Config_OPTIMIZE_REACTION_RATE_SELECTION
    LOADSBMLOPTIONS_PERMISSIVE = _roadrunner.Config_LOADSBMLOPTIONS_PERMISSIVE
    MAX_OUTPUT_ROWS = _roadrunner.Config_MAX_OUTPUT_ROWS
    ALLOW_EVENTS_IN_STEADY_STATE_CALCULATIONS = _roadrunner.Config_ALLOW_EVENTS_IN_STEADY_STATE_CALCULATIONS
    CONFIG_END = _roadrunner.Config_CONFIG_END
    ROADRUNNER_DISABLE_WARNINGS_STEADYSTATE = _roadrunner.Config_ROADRUNNER_DISABLE_WARNINGS_STEADYSTATE
    ROADRUNNER_DISABLE_WARNINGS_CONSERVED_MOIETY = _roadrunner.Config_ROADRUNNER_DISABLE_WARNINGS_CONSERVED_MOIETY
    ROADRUNNER_JACOBIAN_MODE_AMOUNTS = _roadrunner.Config_ROADRUNNER_JACOBIAN_MODE_AMOUNTS
    ROADRUNNER_JACOBIAN_MODE_CONCENTRATIONS = _roadrunner.Config_ROADRUNNER_JACOBIAN_MODE_CONCENTRATIONS

    def getConfigFilePath():
        """

        Config.getConfigFilePath()

        If roadrunner was able to find a configuration file on the file system, its full path is returned
        here. If no file was found, this returns a empty string.

        """
        return _roadrunner.Config_getConfigFilePath()

    getConfigFilePath = staticmethod(getConfigFilePath)

    def setValue(arg1, value):
        """

        Config.setValue(key, value)

        Set the value of a configuration key. The value must be either a string, integer, double or
        boolean. If one wanted to change the value of the default integrator tolerances, one would::

          from roadrunner import Config
          Config.setValue(Config.SIMULATEOPTIONS_ABSOLUTE, 3.14e-12)
          Config.setValue(Config.SIMULATEOPTIONS_RELATIVE, 2.78e-5)


        Or, other options may be set to Boolean or integer values. To enable an optimization features,
        or to set default simulation time steps::

          Config.setValue(Config.LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER, True)
          Config.setValue(Config.SIMULATEOPTIONS_STEPS, 100)

        """
        return _roadrunner.Config_setValue(arg1, value)

    setValue = staticmethod(setValue)
    if _newclass:
        getValue = staticmethod(_roadrunner.Config_getValue)
    else:
        getValue = _roadrunner.Config_getValue

    def readConfigFile(path):
        """

        Config.readConfigFile(path)

        Read all of the values from a configuration file at the given path. This overrides any previously
        stored configuration. This allows users to have any number of configuration files and load them
        at any time. Say someone had to use Windows, and they had a file in thier C: drive, this would be
        loaded via::

          Config.readConfigFile("C:/my_config_file.txt")

        Note, the forward slash works on both Unix and Windows, using the forward slash eliminates the
        need to use a double back slash, "\\\\\\\\".

        """
        return _roadrunner.Config_readConfigFile(path)

    readConfigFile = staticmethod(readConfigFile)

    def writeConfigFile(path):
        """

        Config.writeConfigFile(path)

        Write all of the current configuration values to a file. This could be written to one of the
        default locations, or to any other location, and re-loaded at a later time.



        Available Configuration Parameters
        ----------------------------------
        All of the configuration parameter keys are static attributes of the Config class and are listed
        here. The variable type of the parameter is listed after the key name.

        """
        return _roadrunner.Config_writeConfigFile(path)

    writeConfigFile = staticmethod(writeConfigFile)
    if _newclass:
        stringToKey = staticmethod(_roadrunner.Config_stringToKey)
    else:
        stringToKey = _roadrunner.Config_stringToKey
    if _newclass:
        getKeyList = staticmethod(_roadrunner.Config_getKeyList)
    else:
        getKeyList = _roadrunner.Config_getKeyList

    def __init__(self):
        this = _roadrunner.new_Config()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_Config
    __del__ = lambda self: None
Config_swigregister = _roadrunner.Config_swigregister
Config_swigregister(Config)

def Config_getConfigFilePath():
    """

    Config.getConfigFilePath()

    If roadrunner was able to find a configuration file on the file system, its full path is returned
    here. If no file was found, this returns a empty string.

    """
    return _roadrunner.Config_getConfigFilePath()

def Config_setValue(arg2, value):
    """

    Config.setValue(key, value)

    Set the value of a configuration key. The value must be either a string, integer, double or
    boolean. If one wanted to change the value of the default integrator tolerances, one would::

      from roadrunner import Config
      Config.setValue(Config.SIMULATEOPTIONS_ABSOLUTE, 3.14e-12)
      Config.setValue(Config.SIMULATEOPTIONS_RELATIVE, 2.78e-5)


    Or, other options may be set to Boolean or integer values. To enable an optimization features,
    or to set default simulation time steps::

      Config.setValue(Config.LOADSBMLOPTIONS_OPTIMIZE_INSTRUCTION_SIMPLIFIER, True)
      Config.setValue(Config.SIMULATEOPTIONS_STEPS, 100)

    """
    return _roadrunner.Config_setValue(arg2, value)

def Config_getValue(arg2):
    return _roadrunner.Config_getValue(arg2)
Config_getValue = _roadrunner.Config_getValue

def Config_readConfigFile(path):
    """

    Config.readConfigFile(path)

    Read all of the values from a configuration file at the given path. This overrides any previously
    stored configuration. This allows users to have any number of configuration files and load them
    at any time. Say someone had to use Windows, and they had a file in thier C: drive, this would be
    loaded via::

      Config.readConfigFile("C:/my_config_file.txt")

    Note, the forward slash works on both Unix and Windows, using the forward slash eliminates the
    need to use a double back slash, "\\\\\\\\".

    """
    return _roadrunner.Config_readConfigFile(path)

def Config_writeConfigFile(path):
    """

    Config.writeConfigFile(path)

    Write all of the current configuration values to a file. This could be written to one of the
    default locations, or to any other location, and re-loaded at a later time.



    Available Configuration Parameters
    ----------------------------------
    All of the configuration parameter keys are static attributes of the Config class and are listed
    here. The variable type of the parameter is listed after the key name.

    """
    return _roadrunner.Config_writeConfigFile(path)

def Config_stringToKey(key):
    return _roadrunner.Config_stringToKey(key)
Config_stringToKey = _roadrunner.Config_stringToKey

def Config_getKeyList():
    return _roadrunner.Config_getKeyList()
Config_getKeyList = _roadrunner.Config_getKeyList

VALIDATE_UNITS = _roadrunner.VALIDATE_UNITS
VALIDATE_IDENTIFIER = _roadrunner.VALIDATE_IDENTIFIER
VALIDATE_MATHML = _roadrunner.VALIDATE_MATHML
VALIDATE_SBO = _roadrunner.VALIDATE_SBO
VALIDATE_OVERDETERMINED = _roadrunner.VALIDATE_OVERDETERMINED
VALIDATE_MODELING_PRACTICE = _roadrunner.VALIDATE_MODELING_PRACTICE
VALIDATE_GENERAL = _roadrunner.VALIDATE_GENERAL

def validateSBML(*args):
    return _roadrunner.validateSBML(*args)
validateSBML = _roadrunner.validateSBML

def isStoichDefined(sbml):
    return _roadrunner.isStoichDefined(sbml)
isStoichDefined = _roadrunner.isStoichDefined

def fixMissingStoich(sbml):
    return _roadrunner.fixMissingStoich(sbml)
fixMissingStoich = _roadrunner.fixMissingStoich
class SBMLReader(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBMLReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBMLReader, name)
    __repr__ = _swig_repr
    if _newclass:
        read = staticmethod(_roadrunner.SBMLReader_read)
    else:
        read = _roadrunner.SBMLReader_read
    if _newclass:
        is_sbml = staticmethod(_roadrunner.SBMLReader_is_sbml)
    else:
        is_sbml = _roadrunner.SBMLReader_is_sbml

    def __init__(self):
        this = _roadrunner.new_SBMLReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _roadrunner.delete_SBMLReader
    __del__ = lambda self: None
SBMLReader_swigregister = _roadrunner.SBMLReader_swigregister
SBMLReader_swigregister(SBMLReader)

def SBMLReader_read(sbml_or_uri):
    return _roadrunner.SBMLReader_read(sbml_or_uri)
SBMLReader_read = _roadrunner.SBMLReader_read

def SBMLReader_is_sbml(str):
    return _roadrunner.SBMLReader_is_sbml(str)
SBMLReader_is_sbml = _roadrunner.SBMLReader_is_sbml


RoadRunner.ensureSolversRegistered()
integrators = list(RoadRunner.getRegisteredIntegratorNames())
steadyStateSolvers = list(RoadRunner.getRegisteredSteadyStateSolverNames())
solvers = integrators + steadyStateSolvers

# This file is compatible with both classic and new-style classes.


